<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>分类: Tech Blog - MyEncyclopedia</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">


<link href="/en/categories/Tech-Blog/page/3/" rel="alternate" hreflang="en" />
    


<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="MyEncyclopedia">
<meta property="og:url" content="https://myencyclopedia.github.io/categories/Tech-Blog/page/3/">
<meta property="og:site_name" content="MyEncyclopedia">
<meta property="og:locale">
<meta property="article:author" content="MyEncyclopedia">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://myencyclopedia.github.io">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5><i class="far fa-folder"></i>Tech Blog</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/pytorch-geometric-01-plot-cora/" itemprop="url">Pytorch Geometric 系列教程1：互动可视化Graph数据集</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-09-03T18:45:01.000Z" itemprop="datePublished">9月 4 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 读完 (约 1088 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>Pytorch Geometric 系列将结合 pytorch geometric
类库，从原理结合实践来讲解深度图神经网络。和前几期一样，这一系列所有环境已经为大家封装成了
docker image。预制的 image 中既包含了 pytorch 1.8 和对应的
geometric，networkx，Jubyter notebook 还有画图涉及到的 matplotlib 和
hvplot 类库。除此之外，也包含了预下载的 geometric dateset
和所用到的代码。方便大家一键开始 coding。</p>
<h2 id="获取预制-docker-image">获取预制 Docker Image</h2>
<p>获取docker image 环境的方式，小伙伴们可以通过关注 MyEncyclopedia
公众号并在公众号对话框中回复</p>
<p><code>docker-geometric</code> 后获得</p>
<figure>
<img src="/zh/2021/pytorch-geometric-01-plot-cora/wechat_docker.png" alt="wechat_docker">
<figcaption aria-hidden="true">wechat_docker</figcaption>
</figure>
<p>关于具体使用我制作的 docker image 这个主题，大家可以再公众号或者同名
B站账号，找到 <code>docker 封装工程依赖</code> 一集，
其中包括如下高级用法</p>
<ul>
<li>在 VS Code 中运行 Jupyter notebook</li>
<li>Remote X Window 主机显示渲染图片</li>
<li>docker container 中启动 Jupyter notebook 服务器</li>
<li>共享文件保存文件改动</li>
<li>添加类库后保存镜像改动</li>
</ul>
<figure>
<img src="/zh/2021/pytorch-geometric-01-plot-cora/bili-docker-adv.png" alt="bili-docker-adv">
<figcaption aria-hidden="true">bili-docker-adv</figcaption>
</figure>
<p>如果觉得下载镜像麻烦的小伙伴们，也可以自己准备对应的 python
package，再拷贝下方链接的代码直接运行。</p>
<p>https://mydoc.myencyclopedia.top/pub/code/cora-plot</p>
<p>这个系列涉及到的 python package 包括 - torch-geometric</p>
<ul>
<li><p>networkx</p></li>
<li><p>hvplot</p></li>
<li><p>livelossplot</p></li>
</ul>
<h2 id="启动-jupyter-notebook">启动 Jupyter Notebook</h2>
<p>当预制的 docker image 下载并装载完毕后，通过下面命令来启动 container
内置的 Jupyter notebook 服务器，这样可以使得主机种的浏览器访问到
container 中的服务器。</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8888:8888 -it env-conda-x jupyter notebook --allow-root --ip 0.0.0.0</span><br></pre></td></tr></tbody></table></figure>
<h2 id="内置-cora-数据集">内置 Cora 数据集</h2>
<p>下一步，我们会通过 geometric 类库加载 cora
数据集。这一步通常来说需要从网上下载，但是预制的 docker image
已经为大家下载好了 planetoid 图数据集。Planetoid 包含了 Cora，Pubmed 和
Citeseer。</p>
<p>因此，加载数据集这一步执行非常快</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> torch</span><br><span class="line"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn</span><br><span class="line"><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> torch_geometric.data <span class="hljs-keyword">import</span> Data</span><br><span class="line"><span class="hljs-keyword">from</span> torch_geometric.nn <span class="hljs-keyword">import</span> GATConv</span><br><span class="line"><span class="hljs-keyword">from</span> torch_geometric.datasets <span class="hljs-keyword">import</span> Planetoid</span><br><span class="line"><span class="hljs-keyword">import</span> torch_geometric.transforms <span class="hljs-keyword">as</span> T</span><br><span class="line"></span><br><span class="line">name_data = <span class="hljs-string">'Cora'</span></span><br><span class="line">dataset = Planetoid(root=<span class="hljs-string">'./data/'</span>, name=name_data)</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们将 cora 转换成 networkx 格式。networkx 是 python
中一个比较流行的图类库。我们在后面 visualization 中也会利用networkx
的功能。</p>
<p>Cora 有 7 种节点类型，我们将每种节点类型赋予不同颜色，有助于更好
visualization。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> torch_geometric.utils <span class="hljs-keyword">import</span> to_networkx</span><br><span class="line">cora = to_networkx(dataset.data)</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span>(cora.is_directed())</span><br><span class="line"></span><br><span class="line">node_classes = dataset.data.y.data.numpy()</span><br><span class="line"><span class="hljs-built_in">print</span>(node_classes)</span><br><span class="line"></span><br><span class="line">node_color = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"yellow"</span>,<span class="hljs-string">"peru"</span>,<span class="hljs-string">"violet"</span>,<span class="hljs-string">"cyan"</span>] </span><br><span class="line">node_label = np.array(<span class="hljs-built_in">list</span>(cora.nodes)) </span><br></pre></td></tr></tbody></table></figure>
<p>接着，调用 networkx 的 spring_layout
计算每个节点的弹簧布局下的位置，这一步执行会比较耗时。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx</span><br><span class="line"></span><br><span class="line">pos = nx.layout.spring_layout(cora)</span><br></pre></td></tr></tbody></table></figure>
<p>我们首先来看一下 matplotlib 的渲染效果。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-built_in">len</span>(np.unique(node_classes))):</span><br><span class="line">    node_list = node_label[node_classes == i]</span><br><span class="line">    nx.draw_networkx_nodes(cora, pos, nodelist=<span class="hljs-built_in">list</span>(node_list),</span><br><span class="line">                           node_size=<span class="hljs-number">50</span>,  </span><br><span class="line">                           node_color=node_color[i], </span><br><span class="line">                           alpha=<span class="hljs-number">0.8</span>)</span><br><span class="line"></span><br><span class="line">nx.draw_networkx_edges(cora, pos,width=<span class="hljs-number">1</span>,edge_color=<span class="hljs-string">"black"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>因为 matplotlib 只能画出一张静态图片， 无法做
interaction，也无法动态缩放。因此渲染效果不是特别好，尤其是对于 cora
这种数据量比较大的 graph 尤为显著。</p>
<p>我们看到图片种尽管有七种颜色的节点，但是当中存在的这块密集的点，我们很难看出节点和节点之间的关系。
<img src="/zh/2021/pytorch-geometric-01-plot-cora/cora_networkx.png" alt="cora_networkx"></p>
<p>我们换一个类库 hvplot，它的渲染和交换效果如下。 <img src="/zh/2021/pytorch-geometric-01-plot-cora/hvplot.gif" alt="hvplot"></p>
<p>代码和 matplotlib 大致一致。注意渲染的时候 hvplot
需要将多个图片数据以乘法形式返回，借助 reduce 函数我们将 7
种节点的图相乘，再乘以描绘边的图，呈现出叠加的完整图片。
</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> hvplot.networkx <span class="hljs-keyword">as</span> hvnx</span><br><span class="line">options = {</span><br><span class="line">    <span class="hljs-string">'width'</span>: <span class="hljs-number">800</span>,</span><br><span class="line">    <span class="hljs-string">'height'</span>: <span class="hljs-number">1000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">plt_nodes = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-built_in">len</span>(np.unique(node_classes))):</span><br><span class="line">    nodelist = node_label[node_classes == i]</span><br><span class="line">    plt = hvnx.draw_networkx_nodes(cora, pos, nodelist=<span class="hljs-built_in">list</span>(nodelist), node_color=node_color[i], **options)</span><br><span class="line">    plt_nodes.append(plt)</span><br><span class="line"></span><br><span class="line">plt_edges = hvnx.draw_networkx_edges(cora, pos, arrowstyle=<span class="hljs-string">'-&gt;'</span>, edge_width=<span class="hljs-number">2</span>, colorbar=<span class="hljs-literal">True</span>, **options)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> functools</span><br><span class="line"><span class="hljs-keyword">import</span> operator</span><br><span class="line">plt_edges * functools.reduce(operator.mul, plt_nodes)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/service-math2latex/" itemprop="url">MyEncyclopedia 重磅推出 mathpix 服务：图片转换成Latex源码</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-19T18:45:01.000Z" itemprop="datePublished">8月 20 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 读完 (约 211 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>大家一定都用过神奇的 mathpix 服务，它可以方便大家将数学公式图片转换成
Latex 数学公式。现在 MyEncyclopedia 也推出了手机版和桌面版的 mathpix
服务啦！</p>
<iframe src="//player.bilibili.com/player.html?aid=674980364&amp;bvid=BV1BU4y1E7Be&amp;cid=393607422&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<h2 id="使用流程-登录服务">使用流程 登录服务</h2>
<h3 id="关注-myencyclopedia-公众号">1. 关注 <code>MyEncyclopedia</code>
公众号</h3>
<h3 id="在公众号对话中回复">2. 在公众号对话中回复 <code>?</code></h3>
<figure>
<img src="/zh/2021/service-math2latex/start.png">
<figcaption>
</figcaption>
</figure>
<h3 id="点击-ai在线服务">3. 点击 <code>AI在线服务</code></h3>
<h3 id="在非微信浏览器中打开链接">4. 在非微信浏览器中打开链接</h3>
<figure>
<img src="/zh/2021/service-math2latex/open_browser.png">
<figcaption>
</figcaption>
</figure>
<div>

<h3 id="登录">5. 登录</h3>
<p>目前提供两种方式。
在国内的小伙伴建议使用微信公众号的方式登录，在国外的朋友们可以使用
Google 账号登录。</p>
<h3 id="微信登录按提示在为公众号中输入验证码">5.1
微信登录，按提示在为公众号中输入验证码</h3>
<figure>
<img src="/zh/2021/service-math2latex/wechat_code.png">
<figcaption>
</figcaption>
</figure>
<div>

<h3 id="google登录">5.2 Google登录</h3>
<figure>
<img src="/zh/2021/service-math2latex/google_login.png">
<figcaption>
</figcaption>
</figure>
<div>

<h2 id="使用流程">使用流程</h2>
点击右上方 <code>+</code> 选择图片
<figure>
<img src="/zh/2021/service-math2latex/select.png">
<figcaption>
</figcaption>
</figure>
<div>
<h2 id="等待结果">等待结果</h2>
<p>Output Source 为转换的 Latex 源码</p>
<p>Output Render 为转换源码对应的渲染效果</p>
<figure>
<img src="/zh/2021/service-math2latex/final.png">
<figcaption>
</figcaption>
</figure>
<div>


<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></div></div></div></div></div></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/share-wechat-resources/" itemprop="url">公众号共享资源</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-11T18:45:01.000Z" itemprop="datePublished">8月 12 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 读完 (约 170 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><ul>
<li><p>docker 环境，conda X Window</p>
<p>公众号回复 <code>docker-conda-x</code></p></li>
<li><p>docker 环境，Pytorch OpenNE</p>
<p>公众号回复 <code>docker-openne</code></p></li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0mbQggMo3ynwsJ51JvnzFQ">图神经网络 GCN
Pytorch 版实现代码讲解</a></p>
<p>docker 环境，公众号回复 <code>docker-pygcn</code></p></li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/l1W0CUqsO2-aRUbU8J-_vA">新书推荐&amp;课程视频网盘下载：强化学习与最优控制</a></p>
<p>公众号回复 <code>adp</code></p></li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/COQhJe-ffSkdz5HMXwdr6A">课程视频共享：Illinois大学
CS598 统计强化学习</a> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av929950486">B站链接</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vMlNwCYJqcZTjxCMTMkTdw">分享精品深度强化学习讲座
Berkeley Deep RL Bootcamp 2017</a></p>
<p>公众号回复 <code>rl-bootcamp-ucb-2017</code></p></li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/distribution-normal/" itemprop="url">从零构建统计随机变量生成器之正态分布 Box-Muller方法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-07-09T18:45:01.000Z" itemprop="datePublished">7月 10 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 读完 (约 2106 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>在学习了一些基本的统计变量生成法之后，这次我们来看看如何生成正态分布。它就是大名鼎鼎的
Box-Muller 方法，Box-Muller
的理解过程可以体会到统计模拟的一些精妙思想。</p>
<ul>
<li><a href="/zh/2021/distribution-normal/zh/distribution-discrete-generator.md">从零构建统计随机变量生成器之
离散基础篇</a></li>
<li><a href="/zh/2021/distribution-normal/zh/distribution-inverse-transformation-method.md">从零构建统计随机变量生成器之
用逆变换采样方法构建随机变量生成器</a></li>
<li><a href="/zh/2021/distribution-normal/zh/leetcode-470-rand10.md">深入 LeetCode 470
拒绝采样，状态转移图求期望和一道经典统计求期望题目</a></li>
<li><strong><a href="/zh/2021/distribution-normal/zh/distribution-normal.md">从零构建统计随机变量生成器之 正态分布
Box-Muller方法</a></strong></li>
</ul>
<h2 id="尝试逆变换方法">尝试逆变换方法</h2>
<p>我们先尝试通过标准的逆变换方法来生成正态分布。</p>
<p>正态分布的 PDF 表达式为</p>
<div>
<p><span class="math display">\[
f_Z(z) = \frac{1}{\sqrt{2 \pi}} \exp\left\{-\frac{z^2}{2}\right\}
\]</span></p>
</div>
<p>对应的函数图形是钟形曲线</p>
<p><img src="/zh/2021/distribution-normal/normal-pdf.png"></p>
<p>根据 PDF，其 CDF 的积分形式为 <span class="math display">\[
\Phi(x)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{x} e^{-t^{2} / 2} d t
\]</span></p>
<p>和所有 PDF CDF 关系一样，<span class="math inline">\(\Phi(x)\)</span>
表示 <span class="math inline">\(f_Z\)</span> 累积到 <span class="math inline">\(x\)</span> 点的面积。</p>
<p><img src="/zh/2021/distribution-normal/phi.png"></p>
<p>很不幸的是，<span class="math inline">\(\Phi(x)\)</span>
无法写出一般数学表达式，因而也无法直接用逆变换方法。</p>
<h2 id="二维映射到一维">二维映射到一维</h2>
<p>我们知道，高维正态分布有特殊的性质：它的每一维的分量都是正态分布；单个维度对于其他维度的条件概率分布也是正态分布。</p>
<p>用图来理解这两条性质就是，对于下图的二维正态分布 $ x = [x_1, x_2]^T
$，单独的 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 都服从一维正态分布。</p>
<p>条件概率 <span class="math inline">\(p(x_2|x_1 \approx1)\)</span>
的PDF 对应图中的红线，显然也是一维正态分布。</p>
<p><img src="/zh/2021/distribution-normal/gaussian2d_slice.png"></p>
<p>写一段简单的代码验证二维正态分布的单个分量服从正态分布。</p>
<p>代码中，我们用<code>np.random.normal</code>生成了 10000
个服从二维正态分布的 x, y 点，然后我们丢弃 y，只保留 x，并画出 10000 个
x 的分布。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_normal_1d</span>():</span></span><br><span class="line">    x, _ = np.random.normal(loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>, size=(<span class="hljs-number">2</span>, <span class="hljs-number">10000</span>))</span><br><span class="line">    <span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns</span><br><span class="line">    sns.distplot(x, hist=<span class="hljs-literal">True</span>, kde=<span class="hljs-literal">True</span>, bins=<span class="hljs-number">100</span>, color=<span class="hljs-string">'darkblue'</span>,</span><br><span class="line">                 hist_kws={<span class="hljs-string">'edgecolor'</span>: <span class="hljs-string">'black'</span>},</span><br><span class="line">                 kde_kws={<span class="hljs-string">'linewidth'</span>: <span class="hljs-number">4</span>})</span><br><span class="line">    plt.title(<span class="hljs-string">'PDF Normal 1D from 2D'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/zh/2021/distribution-normal/2d_to_1d.png"></p>
<h2 id="box-muller-原理">Box-Muller 原理</h2>
<p>虽然无法直接用逆变换方法生成一维正态分布，但我们却能通过先生成二维的正态分布，利用上面一节的性质，生成一维正态分布。</p>
<p><strong>而 Box-Muller
就是巧妙生成二维正态分布样本点的方法。</strong></p>
<p>首先，我们来看看二维正态分布可以认为是两个维度是独立的，每个维度都是正态分布。此时，其
PDF 可以写成两个一维正态分布 PDF 的乘积。</p>
<p><img src="/zh/2021/distribution-normal/normal_x_y.png"></p>
<p>这种写法表明，二维正态分布仅用一个 <strong>r
向量</strong>就可以充分表达。注意，r
是向量，不仅有大小还有角度，有两个分量。这两个分量本质上是独立的，这就是
Box-Muller 方法的巧妙之处。也就是，<strong>Box-Muller
通过角度和半径大小两个分量的独立性分别单独生成并转换成 (x, y)
对。</strong></p>
<p>角度分量是在 <span class="math inline">\(2\pi\)</span>
范围均匀采样，这一点比较直觉好理解。</p>
<p>再来看看半径分量 r。我们令 <span class="math display">\[
s = {r^2 \over 2} \Longrightarrow r = \sqrt{2s}
\]</span></p>
<p>则 s 服从指数分布 <span class="math inline">\(\lambda=1\)</span>
。</p>
<p>不信么？我们不妨来做个模拟实验，下图是模拟 10000次二维正态分布 (x, y)
点后转换成 s 的分布。</p>
<p><img src="/zh/2021/distribution-normal/s_exp.png"></p>
<p>模拟和plot 代码如下</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_r_squared</span>():</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_normal_samples</span>(<span class="hljs-params">n</span>):</span></span><br><span class="line">        x, y = np.random.normal(loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>, size=(<span class="hljs-number">2</span>, n))</span><br><span class="line">        <span class="hljs-keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line">    x, y = gen_normal_samples(<span class="hljs-number">10000</span>)</span><br><span class="line">    s = (x * x + y * y)/<span class="hljs-number">2</span></span><br><span class="line">    plot_dist_1d(s, title=<span class="hljs-string">'PDF $s = {{x^2 + y^2}\over{2}} \sim exp(1)$'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_dist_1d</span>(<span class="hljs-params">X, title=<span class="hljs-string">'PDF '</span></span>):</span></span><br><span class="line">    <span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns</span><br><span class="line">    plt.rcParams.update({</span><br><span class="line">        <span class="hljs-string">"text.usetex"</span>: <span class="hljs-literal">True</span>,</span><br><span class="line">        <span class="hljs-string">"font.family"</span>: <span class="hljs-string">"sans-serif"</span>,</span><br><span class="line">        <span class="hljs-string">"font.sans-serif"</span>: [<span class="hljs-string">"Helvetica"</span>]})</span><br><span class="line">    sns.distplot(X, hist=<span class="hljs-literal">True</span>, kde=<span class="hljs-literal">True</span>, bins=<span class="hljs-number">100</span>, color=<span class="hljs-string">'darkblue'</span>,</span><br><span class="line">                 hist_kws={<span class="hljs-string">'edgecolor'</span>: <span class="hljs-string">'black'</span>},</span><br><span class="line">                 kde_kws={<span class="hljs-string">'linewidth'</span>: <span class="hljs-number">4</span>})</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.show()    </span><br></pre></td></tr></tbody></table></figure>
<p>确信了 s 符合指数分布，根据指数分布的 PDF，可以推出二维正态 PDF中的 $
e<sup>{-r</sup>2/2}$ 也符合指数分布，即 <span class="math display">\[
s \sim \exp(1) \Longrightarrow e^{-r^2/2} \sim \exp(1)
\]</span></p>
<p>至此，总结一下Box-Muller方法。我们视二维正态分布PDF为独立两部分的乘积，第一部分是在
<span class="math inline">\(2\pi\)</span>
范围中的均匀分布，代表了二维平面中的角度 <span class="math inline">\(\theta\)</span>，第二部分为 <span class="math inline">\(\lambda=1\)</span> 的指数分布，代表半径大小。</p>
<p><img src="/zh/2021/distribution-normal/normal_decompose.png"></p>
<p>Box-Muller 方法通过两个服从 [0, 1] 均匀分布的样本
u1和u2，转换成独立的角度和半径样本，具体过程如下</p>
<ol type="1">
<li><p>生成 [0, 1] 的均匀分布 u1，利用逆变换采样方法转换成 exp(1)
样本，此为二维平面点半径 r</p></li>
<li><p>生成 [0, 1] 的均匀分布 u2，乘以 <span class="math inline">\(2\pi\)</span>，即为样本点的角度 <span class="math inline">\(\theta\)</span></p></li>
<li><p>将 r 和 <span class="math inline">\(\theta\)</span> 转换成 x, y
坐标下的点。</p></li>
</ol>
<p>理解了整个过程的意义，下面的代码就很直白。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normal_box_muller</span>():</span></span><br><span class="line">    <span class="hljs-keyword">import</span> random</span><br><span class="line">    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt, log, pi, cos, sin</span><br><span class="line">    u1 = random.random()</span><br><span class="line">    u2 = random.random()</span><br><span class="line">    r = sqrt(-<span class="hljs-number">2</span> * log(u1))</span><br><span class="line">    theta = <span class="hljs-number">2</span> * pi * u2</span><br><span class="line">    z0 = r * cos(theta)</span><br><span class="line">    z1 = r * sin(theta)</span><br><span class="line">    <span class="hljs-keyword">return</span> z0, z1</span><br></pre></td></tr></tbody></table></figure>
<p>接下来，我们来看看 Box-Muller 法生成的二维标准正态分布动画吧</p>
<p><img src="/zh/2021/distribution-normal/gaussian2d_anim.gif"></p>
<h2 id="拒绝采样极坐标方法">拒绝采样极坐标方法</h2>
<p>Box-Muller 方法还有一种形式，称为极坐标形式，属于拒绝采样方法。</p>
<h3 id="生成独立的-u-v-和-s">1. 生成独立的 u, v 和 s</h3>
<p>分别生成 [0, 1] 均匀分布 u 和 v。令 <span class="math inline">\(s =
r^2 = u^2 + v^2\)</span>。如果 s = 0或 s ≥ 1，则丢弃 u 和 v
，并尝试另一对 (u , v)。因为 u 和 v
是均匀分布的，并且因为只允许单位圆内的点，所以 s
的值也将均匀分布在开区间 (0, 1) 中。<strong>注意，这里的 s
的意义虽然也为半径，但不同于基本方法中的 s。</strong>这里 s 取值范围为
(0, 1) ，目的是通过 s 生成指数分布，而基本方法中的 s 取值范围为 [0,
+∞]，表示二维正态分布 PDF 采样点的半径。复用符号 s
的原因是为了对应维基百科中关于基本方法和极坐标方法的数学描述。</p>
<p>我们用代码来验证 s 服从 (0, 1) 范围上的均匀分布。 </p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_polar_s</span>():</span></span><br><span class="line">    <span class="hljs-keyword">import</span> random</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        u = random.uniform(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        v = random.uniform(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        s = u * u + v * v</span><br><span class="line">        <span class="hljs-keyword">if</span> s &gt;= <span class="hljs-number">1.0</span> <span class="hljs-keyword">or</span> s == <span class="hljs-number">0.0</span>:</span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        <span class="hljs-keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_polar_s</span>():</span></span><br><span class="line">    s = [gen_polar_s() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>) ]</span><br><span class="line">    plot_dist_1d(s, title=<span class="hljs-string">'PDF Polar $s = u^2 + v^2$'</span>)</span><br></pre></td></tr></tbody></table></figure> <img src="/zh/2021/distribution-normal/pdf_polar_s.png"><p></p>
<h3 id="将-u-v-s-转换成-x-y">2. 将 u, v, s 转换成 x, y</h3>
<p>若将 $s = R^2 uniform(0, 1) $ 看成是基本方法中的
u1，就可以用同样的方式转换成指数分布，用以代表二维PDF的半径。</p>
<p>同时，根据下图，<span class="math inline">\(\cos \theta\)</span> 和
<span class="math inline">\(\sin \theta\)</span> 可以直接用 u, v, R
表示出来，并不需要通过三角函数显示计算出 <span class="math inline">\(\theta\)</span>。有了半径， <span class="math inline">\(\cos \theta\)</span> 和 <span class="math inline">\(\sin \theta\)</span> ，则可以直接计算出 x, y
坐标，（下面用 <span class="math inline">\(z_0, z_1\)</span> 代替 <span class="math inline">\(x, y\)</span>）。</p>
<p><img src="/zh/2021/distribution-normal/BoxMullerTransformPolar.png"></p>
<p><span class="math display">\[
z_{0}=\sqrt{-2 \ln U_{1}} \cos \left(2 \pi U_{2}\right)=\sqrt{-2 \ln
s}\left(\frac{u}{\sqrt{s}}\right)=u \cdot \sqrt{\frac{-2 \ln s}{s}}
\]</span></p>
<p><span class="math display">\[
z_{1}=\sqrt{-2 \ln U_{1}} \sin \left(2 \pi U_{2}\right)=\sqrt{-2 \ln
s}\left(\frac{v}{\sqrt{s}}\right)=v \cdot \sqrt{\frac{-2 \ln s}{s}}
\]</span></p>
<p>同样，Box-Muller 极坐标方法的代码和公式一致。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normal_box_muller_polar</span>():</span></span><br><span class="line">    <span class="hljs-keyword">import</span> random</span><br><span class="line">    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt, log</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        u = random.uniform(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        v = random.uniform(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        s = u * u + v * v</span><br><span class="line">        <span class="hljs-keyword">if</span> s &gt;= <span class="hljs-number">1.0</span> <span class="hljs-keyword">or</span> s == <span class="hljs-number">0.0</span>:</span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        z0 = u * sqrt(-<span class="hljs-number">2</span> * log(s) / s)</span><br><span class="line">        z1 = v * sqrt(-<span class="hljs-number">2</span> * log(s) / s)</span><br><span class="line">        <span class="hljs-keyword">return</span> z0, z1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="拒绝采样的效率">拒绝采样的效率</h3>
<p>极坐标方法与基本方法的不同之处在于它是一种拒绝采样。因此，它会丢弃一些生成的随机数，但可能比基本方法更快，因为它计算更简单：<strong>避免使用昂贵的三角函数</strong>，并且在数值上更稳健。极坐标方法丢弃了生成总输入对的
1 − <em>π</em> /4 ≈ 21.46%，即需要 4/ <em>π</em> ≈ 1.2732
个输入随机数，输出一个随机采样。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/share-harvard-ECON2355-Unleashing-Novel-Data-at-Scale/" itemprop="url">[Harvard 2021] ECON 2355 - Unleashing Novel Data at Scale</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-06-22T18:45:01.000Z" itemprop="datePublished">6月 23 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 读完 (约 1121 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><h2 id="bilibili">BiliBili</h2>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Lw411o7um" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/0032b7734f2c510bf35ebe2a658273d231ed61f0.png)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">20:19:08</span>
            </div>
            <div class="bvideo-info">
                <p class="title">[Harvard 2021] ECON 2355 - Unleashing Novel Data at Scale</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>125</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>0</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">MyEncyclopedia公号</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h2 id="lecture-1---introduction-to-unleashing-novel-data-at-scale">Lecture
1 - Introduction to Unleashing Novel Data at Scale</h2>
<ul>
<li>Why data accessibility is so central to the advancement of knowledge
in economics (with some historical background)</li>
<li>An overview of the data curation pipeline
<ul>
<li>Step 1: Detect document layouts</li>
<li>Step 2: OCR</li>
<li>Step 3: Post-processing and database assembly</li>
<li>Step 4: Convert information into computable format</li>
</ul></li>
<li>Why is the material covered in this course useful to social
scientists?
<ul>
<li>Why there won’t be an app/commercial product capable of end-to-end
processing of social science documents anytime soon</li>
<li>Why manual data entry often falls short</li>
<li>Why our problems differ from those that are the central focus of
computer science and the digital humanities</li>
</ul></li>
<li>At its core, deep learning is an optimization problem, which
economists are well-trained to understand. It would be really
unfortunate if we did not take full advantage of the very powerful
methods that deep learning offers, which we are well poised to
utilize</li>
</ul>
<h2 id="lecture-2---why-deep-learning">Lecture 2 - Why Deep
Learning?</h2>
<p>This post compares rule-based and deep learning-based approaches to
data curation. It discusses their requirements and why rule-based
approaches often (but not always) produce disappointing results when
applied to social science data.</p>
<ul>
<li>An overview of the syllabus (ultimately, the course had a few
deviations from the original syllabus, based on student interests; final
syllabus posted in the course section of this website)</li>
<li>There are two distinct approaches to automated data curation
<ul>
<li>Tell the computer how to process the data by defining a set of
rules</li>
<li>Let the computer learn how to process the data from empirical
examples, using deep learning</li>
</ul></li>
<li>Overview of rules, how they are used to process image scans and
text, why they often fail, and why they sometimes succeed</li>
<li>Deep learning, how it contrasts with rule-based approaches, and its
requirements</li>
<li>Does the noise from rule-based approaches really matter?</li>
</ul>
<h2 id="lecture-4---convolutional-neural-networks">Lecture 4 -
Convolutional Neural Networks</h2>
<ul>
<li>A brief overview of convolutions</li>
<li>Benchmark datasets for image classification (following the ConvNent
literature requires familiarity with the benchmarks)</li>
<li>Image classification with a linear classifier (and its
shortcomings)</li>
<li>CNN architectures
<ul>
<li>AlexNet</li>
<li>VGG</li>
<li>GoogLeNet</li>
<li>ResNet</li>
<li>ResNext</li>
</ul></li>
</ul>
<h2 id="lecture-5---image-classification-training-neural-nets">Lecture 5
- Image Classification; Training Neural Nets</h2>
<p>This post covers two topics: using CNNs for image classification (a
very useful task) and training neural networks in practice. Much of the
information about training neural nets is essential to implementing deep
learning-based approaches, whether with CNNs or with some other
architecture.</p>
<h3 id="image-classification">Image Classification</h3>
<ul>
<li>Loss functions for classification
<ul>
<li>SVM</li>
<li>Softmax</li>
</ul></li>
<li>Deep document classification</li>
</ul>
<h3 id="training-neural-nets">Training Neural Nets</h3>
<ul>
<li>Activation functions</li>
<li>Data pre-processing</li>
<li>Initialization</li>
<li>Optimization</li>
<li>Regularization</li>
<li>Batch normalization</li>
<li>Dropout</li>
<li>Data augmentation</li>
<li>Transfer learning</li>
<li>Setting hyperparameters</li>
<li>Monitoring the learning process</li>
</ul>
<h2 id="lecture-6---other-computer-vision-problems-including-object-detection">Lecture
6 - Other Computer Vision Problems (Including Object Detection)</h2>
<p>This post covers object detection as well as the related problems of
semantic segmentation, localization, and instance segmentation. Object
detection is core to document image analysis, as it is used to determine
the coordinates and classes of different document layout regions. The
other problems covered are closely related.</p>
<ul>
<li>Semantic segmentation</li>
<li>Localization</li>
<li>Object detection
<ul>
<li>Region CNNs</li>
<li>Fast R-CNN</li>
<li>Faster R-CNN</li>
<li>Mask R-CNN</li>
<li>Features pyramids</li>
</ul></li>
<li>Instance segmentation</li>
<li>Other frameworks (YOLO)</li>
</ul>
<h2 id="lecture-7---object-detection-in-practice">Lecture 7 - Object
Detection in Practice</h2>
<ul>
<li>Selecting an object detection model</li>
<li>Overview of Detectron2</li>
<li>How-to in D2</li>
</ul>
<h2 id="lecture-8---labeling-and-deep-visualization">Lecture 8 -
Labeling and Deep Visualization</h2>
<h3 id="labeling">Labeling</h3>
<ul>
<li>Active learning for layout annotation</li>
<li>Labeling hacks</li>
</ul>
<h3 id="deep-visualization">Deep visualization</h3>
<ul>
<li>Basic visualization approaches</li>
<li>Gradient based ascent</li>
<li>Deep Dream</li>
</ul>
<h2 id="lecture-9---generative-adversarial-networks">Lecture 9 -
Generative Adversarial Networks</h2>
<ul>
<li>Overview: supervised and unsupervised learning; generative
models</li>
<li>Generative adversarial networks</li>
<li>CycleGAN</li>
</ul>
<h2 id="lecture-10---ocr-architecture">Lecture 10 - OCR
Architecture</h2>
<ul>
<li>Overview of the OCR problem</li>
<li>Recurrent neural networks</li>
<li>LSTMs</li>
<li>Connectionist temporal classification</li>
<li>Putting it together</li>
</ul>
<h2 id="lecture-11---ocr-and-post-processing-in-practice">Lecture 11 -
OCR and Post-Processing in Practice</h2>
<p>This post discusses OCR, both off-the-shelf and how to implement a
customized OCR model. It discusses how Layout Parser can be used for
end-to-end document image analysis, and provides concrete examples of
creating variable domains during post-processing. It also provides an
overview of the second half of the knowledge base, which covers NLP.</p>
<ul>
<li><p>Off-the-shelf OCR</p></li>
<li><p>Designing customized OCR</p></li>
<li><p>Putting it altogether (and Layout Parser)</p></li>
<li><p>Creating variable domains</p></li>
<li><p>An overview of the second half of the course (NLP)</p></li>
</ul>
<h2 id="lecture-12---models-of-words">Lecture 12 - Models of Words</h2>
<ul>
<li><p>Traditional models of words</p></li>
<li><p>Word2Vec</p></li>
<li><p>GloVe</p></li>
<li><p>Evaluation</p></li>
<li><p>Interpreting word vectors</p></li>
<li><p>Problems with word vectors</p></li>
</ul>
<h2 id="lecture-13---language-modeling-and-other-topics-in-nlp">Lecture
13 - Language Modeling and Other Topics in NLP</h2>
<p>This post provides an introduction to language modeling, as well as
several other important topics: dependency parsing, named entity
recognition (NER), and labeling for NLP. Due to time constraints, the
course is able to provide only a very brief introduction to topics like
dependency parsing and NER, which have traditionally been quite central
questions in NLP research.</p>
<ul>
<li>Language Modeling
<ul>
<li>Count based models</li>
<li>Bag of words</li>
<li>RNN (review)</li>
<li>LSTM (review)</li>
</ul></li>
<li>Dependency parsing</li>
<li>Named entity recognition</li>
<li>Labeling for NLP</li>
</ul>
<h2 id="lecture-14---seq2seq-and-machine-translation">Lecture 14 -
Seq2Seq and Machine Translation</h2>
<p>Machine translation has pioneered some of the most productive
innovations in neural-based NLP and hence is useful to study even for
those who care little about machine translation per se. We will focus in
particular on seq2seq and attention.</p>
<ul>
<li>Statistical machine translation</li>
<li>Neural machine translation</li>
</ul>
<h2 id="lecture-15---attention-is-all-you-need">Lecture 15 - Attention
is All You Need</h2>
<p>This post introduces the Transformer, a seq2seq model based entirely
on attention that has transformed NLP. Given the importance of this
paper, there are a bunch of very well-done web resources about it, cited
in the lecture and below, that I recommend checking out directly (there
are others who have much more of a comparative advantage in presenting
seminal NLP papers than I do!).</p>
<ul>
<li><p>A recap of attention</p></li>
<li><p>The Transformer</p>
<ul>
<li>The encoder
<ul>
<li>Encoder self-attention</li>
<li>Positional embeddings</li>
<li>Add and normalize</li>
</ul></li>
<li>The decoder
<ul>
<li>Encoder-decoder attention</li>
<li>Decoder self-attention</li>
</ul></li>
<li>Linear and softmax layers</li>
<li>Training</li>
</ul></li>
</ul>
<h2 id="lecture-16---transformer-based-language-models">Lecture 16 -
Transformer-Based Language Models</h2>
<p>This post provides an overview of various Transformer-based language
models, discussing their architectures and which are best-suited for
different contexts.</p>
<ul>
<li>Overview</li>
<li>Contextualized word embeddings</li>
<li>Models
<ul>
<li>GPT</li>
<li>BERT</li>
<li>RoBERTa</li>
<li>DistilBERT</li>
<li>ALBERT</li>
<li>T5</li>
<li>GPT2/GPT3</li>
<li>Transformers XL</li>
<li>XLNet</li>
<li>Longformer</li>
<li>BigBird</li>
</ul></li>
<li>Recap and what to use</li>
</ul>
<h2 id="lecture-17---understanding-transformers-visualization-and-sentiment-analysis">Lecture
17 - Understanding Transformers, Visualization, and Sentiment
Analysis</h2>
<p>This post covers a variety of topics around Transformer-based
language models: understanding how Transformer attention works,
understanding what information is contained in their embeddings,
visualizing embeddings, and using Transformer-based models to conduct
sentiment analysis.</p>
<ul>
<li><p>What do Transformer-based models attend to?</p></li>
<li><p>What’s in an embedding?</p></li>
<li><p>Visualizing embeddings</p></li>
<li><p>Sentiment analysis</p></li>
</ul>
<h2 id="lecture-18---nlp-with-noisy-text">Lecture 18 - NLP with Noisy
Text</h2>
<ul>
<li>The Canonical Deep NLP Training Corpus</li>
<li>A definition of noise</li>
<li>The problem with noise</li>
<li>Approaches for denoising</li>
</ul>
<h2 id="lecture-19---retrieval-and-question-answering">Lecture 19 -
Retrieval and Question Answering</h2>
<ul>
<li>Reading comprehension</li>
<li>Open-domain question answering</li>
</ul>
<h2 id="lecture-20---zero-shot-and-few-shot-learning-in-nlp">Lecture 20
- Zero-Shot and Few-Shot Learning in NLP</h2>
<ul>
<li><p>What it means to learn in just a few shots</p></li>
<li><p>Zero-shot and few-shot learning in practice</p></li>
</ul>
<h2 id="lecture-21---transformers-for-computer-vision">Lecture 21 -
Transformers for Computer Vision</h2>
<ul>
<li>Transformers for computer vision</li>
<li>Transformers for image classification</li>
<li>Transformers for object detection</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/vlog-paper-mine/" itemprop="url">Paper Explained: MINE - Mutual Information Neural Estimation (2018)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-06-14T18:45:01.000Z" itemprop="datePublished">6月 15 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 读完 (约 9 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><h2 id="youtube">YouTube</h2>
<style>.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }
  .embed-container iframe, .embed-container object, .embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  </style>

<div class="embed-container"><iframe src="https://www.youtube.com/embed/jEu_S8Og7T0" allowfullscreen="" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div>
<h2 id="bilibili">BiliBili</h2>
<iframe src="//player.bilibili.com/player.html?aid=758599126&amp;bvid=BV1f64y1R76t&amp;cid=353987045&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/leetcode-470-rand10/" itemprop="url">深入 LeetCode 470 拒绝采样，状态转移图求期望和一道经典统计求期望题目</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-05-28T18:45:01.000Z" itemprop="datePublished">5月 29 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 读完 (约 2430 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>在这篇文章中，我们从一道LeetCode 470
题目出发，通过系统地思考，引出拒绝采样（Reject
Sampling）的概念，并探索比较三种拒绝采样地解法；接着借助状态转移图来定量计算采样效率；最后，我们利用同样的方法来解一道稍微复杂些的经典抛硬币求期望的统计面试题目。</p>
<h2 id="leetcode-470-用-rand7-实现-rand10">Leetcode 470 用 Rand7() 实现
Rand10()</h2>
<p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法
rand10 生成 1 到 10 范围内的均匀随机整数。</p>
<p>不要使用系统的 Math.random() 方法。</p>
<p><strong>思考</strong></p>
<ul>
<li><p>rand7()调用次数的 期望值 是多少 ?</p></li>
<li><p>你能否尽量少调用 rand7() ?</p></li>
</ul>
<h2 id="思维过程">思维过程</h2>
<p>我们已有 rand7() 等概率生成了 [1, 7] 中的数字，我们需要等概率生成 [1,
10] 范围内的数字。第一反应是调用一次rand7()
肯定是不够的，因为覆盖的范围不够。那么，就需要至少2次调用 rand7()
才能生成一次 rand10()，但是还要保证 [1, 10]
的数字生成概率相等，这个是难点。 现在我们先来考虑反问题，给定rand10()
生成 rand7()。这个应该很简单，调用一次 rand10() 得到 [1, 10]，如果是 8,
9, 10
，则丢弃，重新开始，否则返回。想必大家都能想到这个朴素的方法，这种思想就是统计模拟中的拒绝采样（Reject
Sampling）。</p>
<p>有了上面反问题的思考，我们可能会想到，rand7() 可以生成 rand5()，覆盖
[1, 5]的范围，如果将区间 [1, 10] 分成两个5个值的区间 [1, 5] 和 [6,
10]，那么 rand7() 可以通过先等概率选择区间 [1, 5] 或 [6,
10]，再通过rand7() 生成 rand5()就可以了。这个问题就<strong>等价于先用
rand7() 生成 rand2()，决定了 [1, 5] 还是 [6, 10]，再通过rand7() 生成
rand5() 。</strong></p>
<h2 id="解法一rand2-rand5">解法一：rand2() + rand5()</h2>
<p>我们来实现这种解法。下图为调用两次 rand7() 生成 rand10
数值的映射关系：横轴表示第一次调用，1，2，3决定选择区间 [1, 5]
，4，5，6选择区间 [6, 10]。灰色部分表示结果丢弃，重新开始
（注，若第一次得到7无需再次调用 rand7()）。</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/space_slow.png">
<figcaption>
</figcaption>
</figure>
<p>有了上图，我们很容易写出如下 AC 代码。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 408 ms, faster than 23.80% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 16.7 MB, less than 90.76% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand10</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            a = rand7()</span><br><span class="line">            <span class="hljs-keyword">if</span> a &lt;= <span class="hljs-number">3</span>:</span><br><span class="line">                b = rand7()</span><br><span class="line">                <span class="hljs-keyword">if</span> b &lt;= <span class="hljs-number">5</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> b</span><br><span class="line">            <span class="hljs-keyword">elif</span> a &lt;= <span class="hljs-number">6</span>:</span><br><span class="line">                b = rand7()</span><br><span class="line">                <span class="hljs-keyword">if</span> b &lt;= <span class="hljs-number">5</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> b + <span class="hljs-number">5</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="标准解法rand49">标准解法：rand49()</h2>
<p>从提交的结果来看，第一种解法慢于多数解法。原因是我们的调用 rand7()
的采样效率比较低，第一次有 1/7 的概率结果丢弃，第二次有
2/7的概率被丢弃。</p>
<p>如何在第一种解法的基础上提高采样效率呢？直觉告诉我们一种做法是降低上述
7x7 表格中灰色格子的面积。此时，会想到我们<strong>通过两次 rand7()
已经构建出来 rand49()</strong>了，那么再生成 rand10()
也规约成基本问题了。</p>
<p>下图为 rand49() 和 rand10() 的数字对应关系。</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/space_std.png">
<figcaption>
</figcaption>
</figure>
<p>实现代码比较简单。注意，while True 可以去掉，用递归来代替。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 376 ms, faster than 54.71% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 16.9 MB, less than 38.54% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand10</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            a, b = rand7(),  rand7()</span><br><span class="line">            num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b</span><br><span class="line">            <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">40</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="更快的做法">更快的做法</h2>
<p>上面的提交结果发现标准解法在运行时间上有了不少提高，处于中等位置。我们继续思考，看看能否再提高采样效率。</p>
<p>观察发现，rand49() 有 9/49 的概率，生成的值被丢弃，原因是 [41, 49]
只有 9
个数，不足10个。倘若此时能够将这种状态保持下去，那么只需再调用一次
rand7() 而不是从新开始情况下至少调用两次 rand7()， 就可以得到
rand10()了。也就是说，当 rand49() 生成了 [41, 49]
范围内的数的话等价于我们先调用了一次
rand9()，那么依样画葫芦，我们接着调用 rand7() 得到了 rand63()。63
分成了6个10个值的区间后，剩余 3 个数。此时，又等价于
rand3()，循环往复，调用了 rand7() 得到了 rand21()，最后若rand21()
不幸得到21，等价于
rand1()，此时似乎我们走投无路，只能回到最初的状态，一切从头再来了。</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/space_fast.png">
<figcaption>
</figcaption>
</figure>
<p>改进算法代码如下。注意这次击败了 92.7%的提交。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 344 ms, faster than 92.72% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 16.7 MB, less than 90.76% of Python3 online submissions for Implement Rand10() Using Rand7().</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand10</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            a, b = rand7(),  rand7()</span><br><span class="line">            num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b</span><br><span class="line">            <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line">            a = num - <span class="hljs-number">40</span></span><br><span class="line">            b = rand7()</span><br><span class="line">            num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b</span><br><span class="line">            <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">60</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line">            a = num - <span class="hljs-number">60</span></span><br><span class="line">            b = rand7()</span><br><span class="line">            num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b</span><br><span class="line">            <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="采样效率计算">采样效率计算</h2>
<p>通过代码提交的结果和大致的分析，我们已经知道三个解法在采样效率依次变得更快。现在我们来定量计算这三个解法。</p>
<p>我们考虑生成一个 rand10() 平均需要调用多少次
rand7()，作为采样效率的标准。</p>
<p>一种思路是可以通过模拟方法，即将上述每个解法模拟多次，然后用总的
rand7() 调用次数除以 rand10()
的生成次数即可。下面以解法三为例写出代码</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># The rand7() API is already defined for you.</span></span><br><span class="line">rand7_c = <span class="hljs-number">0</span></span><br><span class="line">rand10_c = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand7</span>():</span></span><br><span class="line">    <span class="hljs-keyword">global</span> rand7_c</span><br><span class="line">    rand7_c += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">import</span> random</span><br><span class="line">    <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)</span><br><span class="line">    </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand10</span>():</span></span><br><span class="line">    <span class="hljs-keyword">global</span> rand10_c</span><br><span class="line">    rand10_c += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        a, b = rand7(), rand7()</span><br><span class="line">        num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b</span><br><span class="line">        <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line">        a = num - <span class="hljs-number">40</span>   <span class="hljs-comment"># [1, 9]</span></span><br><span class="line">        b = rand7()</span><br><span class="line">        num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b  <span class="hljs-comment"># [1, 63]</span></span><br><span class="line">        <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">60</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line">        a = num - <span class="hljs-number">60</span>  <span class="hljs-comment"># [1, 3]</span></span><br><span class="line">        b = rand7()</span><br><span class="line">        num = (a - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + b  <span class="hljs-comment"># [1, 21]</span></span><br><span class="line">        <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> num % <span class="hljs-number">10</span> + <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        rand10()</span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'<span class="hljs-subst">{rand10_c}</span> <span class="hljs-subst">{<span class="hljs-built_in">round</span>(rand7_c/rand10_c, <span class="hljs-number">2</span>)}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，发现解法三的采样效率稳定在 2.19。</p>
<h2 id="采样效率精确计算">采样效率精确计算</h2>
<h3 id="计算解法二">计算解法二</h3>
<p>为了精确计算三个解法的采样效率，我们通过代码得到对应的状态转移图来帮助计算。</p>
<p>例如，解法一可以对应到下图：初始状态 Start 节点中的 +2
表示经过此节点会产生 2次 rand7() 的代价。从 Start 节点有 40/49
的概率到达被接受状态 AC，有 9/49 概率到达拒绝状态 REJ。REJ
需要从头开始，则用虚线表示重新回到 Start节点，<strong>也就是说 REJ
的代价等价于 Start</strong>。注意，从某个节点出发的所有边之和为1。</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/graph_std.png">
<figcaption>
</figcaption>
</figure>
<p>有了上述状态转移关系图，我们令初始状态的平均代价为 <span class="math inline">\(C_2\)</span>，则可以写成递归表达式，因为其中 REJ
的代价就是 <span class="math inline">\(C_2\)</span>，即</p>
<p><span class="math display">\[
C_2 = 2 + (\frac{40}{49}\cdot0 + \frac{9}{49} C_2)
\]</span></p>
<p>解得 <span class="math inline">\(C_2\)</span></p>
<p><span class="math display">\[
C_2 = 2.45
\]</span></p>
<h3 id="计算解法一">计算解法一</h3>
<p>同样的，对于另外两种解法，虽然略微复杂，也可以用同样的方法求得。</p>
<p>解法一的状态转移图为</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/graph_slow.png">
<figcaption>
</figcaption>
</figure>
<p>递归方程表达式为</p>
<p><span class="math display">\[
C_1 = 1+\frac{3}{7} \cdot (1+\frac{5}{7} \cdot 0 + \frac{2}{7} \cdot
C_1) \cdot2+ \frac{1}{7} \cdot (C_1)
\]</span></p>
<p>解得 <span class="math inline">\(C_1\)</span></p>
<p><span class="math display">\[
C_1 = \frac{91}{30} \approx 3.03
\]</span></p>
<h3 id="计算解法三">计算解法三</h3>
<p>最快的解法三状态转移图为</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/graph_fast.png">
<figcaption>
</figcaption>
</figure>
<p>递归方程表达式为</p>
<p><span class="math display">\[
C_3 = 2+\frac{40}{49} \cdot 0 + \frac{9}{49} (1+\frac{60}{63} \cdot 0 +
\frac{3}{63} \cdot (1+\frac{20}{21} \cdot 0 + \frac{1}{21} \cdot C_3))
\]</span></p>
<p>解得 <span class="math inline">\(C_3\)</span> <span class="math display">\[
C_3 = \frac{329}{150} \approx 2.193
\]</span></p>
<p>至此总结一下，三个解法的平均代价为 <span class="math display">\[
C_1 \approx 3.03 &gt; C_2 = 2.45 &gt; C_3 \approx 2.193
\]</span> 这些值和我们通过模拟得到的结果一致。</p>
<h2 id="稍难些的经典概率求期望题目">稍难些的经典概率求期望题目</h2>
<p>至此，LeetCode 470
我们已经分析透彻。现在，我们已经可以很熟练的将此类拒绝采样的问题转变成有概率的状态转移图，再写成递推公式去求平均采样的代价（即期望）。这里，如果大家感兴趣的话不妨再来看一道略微深入的经典统计概率求期望的题目。</p>
<p>问题：给定一枚抛正反面概率一样的硬币，求连续抛硬币直到两个正面（正面记为H，两个正面HH）的平均次数。例如：HTTHH是一个连续次数为5的第一次出现HH的序列。</p>
<p>分析问题画出状态转移图：我们令初始状态下得到第一个HH的平均长度记为
S，那么下一次抛硬币有 1/2 机会是 T，此时状态等价于初始状态，另有 1/2
机会是 H，我们记这个状态下第一次遇见HH的平均长度为
H（下图蓝色节点）。从此蓝色节点出发，当下一枚硬币是H则结束，是T是返回初始状态。于是构建出下图。</p>
<figure>
<img src="/zh/2021/leetcode-470-rand10/graph_hh.png">
<figcaption>
</figcaption>
</figure>
<p>这个问题稍微复杂的地方在于我们有两个未知状态互相依赖，但问题的本质和方法是一样的，分别从
S 和 H 出发考虑状态的概率转移，可以写成如下两个方程式：</p>
<div>
<p><span class="math display">\[
\left\{
\begin{array}{c}
S =&amp;\frac{1}{2} \cdot(1+H) + \frac{1}{2} \cdot(1+S) \\
H =&amp;\frac{1}{2} \cdot 1 + \frac{1}{2} \cdot(1+S)
\end{array}
\right.
\]</span></p>
</div>
<p>解得</p>
<div>
<p><span class="math display">\[
\left\{
\begin{array}{c}
H= 4 \\
S = 6
\end{array}
\right.
\]</span></p>
</div>
<p>因此，平均下来，需要6次抛硬币才能得到
HH，这个是否和你直觉的猜测一致呢？</p>
<p>这个问题还可以有另外一问，可以作为思考题让大家来练习一下：第一次得到
HT 的平均次数是多少？这个是否和 HH 一样呢？</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/rl-ppo-1984/" itemprop="url">深度强化学习之：PPO训练红白机1942</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-05-08T18:45:01.000Z" itemprop="datePublished">5月 9 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2804 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>本篇是深度强化学习动手系列文章，自MyEncyclopedia公众号文章<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457480980&amp;idx=1&amp;sn=ef919157726080caf9eebb3aaa8314f9&amp;chksm=87bc993ab0cb102c399687912b65d6a38994f2cb9ac87b531bf0ca2eaf119b8db0ea84e45916&amp;scene=21#wechat_redirect">深度强化学习之：DQN训练超级玛丽闯关</a>发布后收到不少关注和反馈，这一期，让我们实现目前主流深度强化学习算法PPO来打另一个红白机经典游戏1942。</p>
<p>相关文章链接如下：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457481574&amp;idx=1&amp;sn=712e92f15d5488dcb73470c9a6420a04&amp;chksm=87bc8748b0cb0e5eb839afe27712dd990ad3d4a2083b923593a499f8a1c4ada37e6dfa1db7e0&amp;scene=21#wechat_redirect">强化学习开源环境集</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457481652&amp;idx=1&amp;sn=ddc083c1a7ce4930b4302384c507cbd5&amp;chksm=87bc879ab0cb0e8c6e68d5f7f5638e09b7167576edc7c8ed075531ec221630356eea7ff4ad56&amp;scene=21#wechat_redirect">视频论文解读：PPO算法</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457481622&amp;idx=1&amp;sn=dbdce93433de31c68e99da08afb8699c&amp;chksm=87bc87b8b0cb0eaed487d3c553ad565513b07c887692bce33d83b1424926cd367d5d5f75ea5f&amp;scene=21#wechat_redirect">视频论文解读：组合优化的强化学习方法</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457481507&amp;idx=1&amp;sn=0ae5e2c434973d35d45f3b794ffe52e3&amp;chksm=87bc870db0cb0e1ba11aa778283faee8fbba750e6208d56d663b689ee7ccdb31cb036365a41e&amp;scene=21#wechat_redirect">解读TRPO论文，深度强化学习结合传统优化方法</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457481304&amp;idx=1&amp;sn=35eb9c72f2ed4feaff57db64e3dd0932&amp;chksm=87bc8676b0cb0f6013a71f5e16229e48e63a9fc30bd8695a761904a915f9482a224cb6e19217&amp;scene=21#wechat_redirect">解读深度强化学习基石论文：函数近似的策略梯度方法</a></p>
<h2 id="nes-1942-环境安装">NES 1942 环境安装</h2>
<p>红白机游戏环境可以由OpenAI Retro来模拟，OpenAI Retro还在 Gym
集成了其他的经典游戏环境，包括Atari 2600，GBA，SNES等。</p>
<p>不过，受到版权原因，除了一些基本的rom，大部分游戏需要自行获取rom。</p>
<p>环境准备部分相关代码如下</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gym-retro</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m retro.import /path/to/your/ROMs/directory/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="openai-gym-输入动作类型">OpenAI Gym 输入动作类型</h2>
<p>在创建 retro
环境时，可以在retro.make中通过参数use_restricted_actions指定 action
space，即按键的配置。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = retro.make(game=<span class="hljs-string">'1942-Nes'</span>, use_restricted_actions=retro.Actions.FILTERED)</span><br></pre></td></tr></tbody></table></figure>
<p>可选参数如下，FILTERED，DISCRETE和MULTI_DISCRETE
都可以指定过滤的动作，过滤动作需要通过配置文件加载。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actions</span>(<span class="hljs-params">Enum</span>):</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Different settings for the action space of the environment</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    ALL = <span class="hljs-number">0</span>  <span class="hljs-comment">#: MultiBinary action space with no filtered actions</span></span><br><span class="line">    FILTERED = <span class="hljs-number">1</span>  <span class="hljs-comment">#: MultiBinary action space with invalid or not allowed actions filtered out</span></span><br><span class="line">    DISCRETE = <span class="hljs-number">2</span>  <span class="hljs-comment">#: Discrete action space for filtered actions</span></span><br><span class="line">    MULTI_DISCRETE = <span class="hljs-number">3</span>  <span class="hljs-comment">#: MultiDiscete action space for filtered actions</span></span><br></pre></td></tr></tbody></table></figure>
<p>DISCRETE和MULTI_DISCRETE 是 Gym 里的
Action概念，它们的基类都是gym.spaces.Space，可以通过
sample()方法采样，下面具体一一介绍。</p>
<ul>
<li>Discrete：对应一维离散空间，例如，Discrete(n=4) 表示 [0, 3]
范围的整数。</li>
</ul>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> Discrete</span><br><span class="line">space = Discrete(<span class="hljs-number">4</span>)</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure>
<p>输出是</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Box：对应多维连续空间，每一维的范围可以用 [low，high] 指定。
举例，Box(low=-1.0, high=2, shape=(3, 4,), dtype=np.float32) 表示 shape
是 [3, 4]，每个范围在 [-1, 2] 的float32型 tensor。</li>
</ul>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> Box</span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line">space = Box(low=-<span class="hljs-number">1.0</span>, high=<span class="hljs-number">2.0</span>, shape=(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), dtype=np.float32)</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure>
<p>输出是 </p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-0.7538084   0.96901214  0.38641307 -0.05045208]</span><br><span class="line"> [-0.85486996  1.3516271   0.3222616   1.2540635 ]</span><br><span class="line"> [-0.29908678 -0.8970335   1.4869047   0.7007356 ]]</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>MultiBinary: 0或1的多维离散空间。例如，MultiBinary([3,2]) 表示 shape
是3x2的0或1的tensor。 <figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> MultiBinary</span><br><span class="line">space = MultiBinary([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>输出是</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1 0]</span><br><span class="line"> [1 1]</span><br><span class="line"> [0 0]]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>MultiDiscrete：多维整型离散空间。例如，MultiDiscrete([5,2,2])
表示三维Discrete空间，第一维范围在 [0-4]，第二，三维范围在[0-1]。</li>
</ul>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> MultiDiscrete</span><br><span class="line">space = MultiDiscrete([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure>
<p>输出是</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2 1 0]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Tuple：组合成 tuple 复合空间。举例来说，可以将
Box，Discrete，Discrete组成tuple 空间：Tuple(spaces=(Box(low=-1.0,
high=1.0, shape=(3,), dtype=np.float32), Discrete(n=3),
Discrete(n=2)))</li>
</ul>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> *</span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line">space = <span class="hljs-type">Tuple</span>(spaces=(Box(low=-<span class="hljs-number">1.0</span>, high=<span class="hljs-number">1.0</span>, shape=(<span class="hljs-number">3</span>,), dtype=np.float32), Discrete(n=<span class="hljs-number">3</span>), Discrete(n=<span class="hljs-number">2</span>)))</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure>
<p>输出是</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(array([ 0.22640526,  0.75286865, -0.6309239 ], dtype=float32), 0, 1)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Dict：组合成有名字的复合空间。例如，Dict({'position':Discrete(2),
'velocity':Discrete(3)}) <figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.spaces <span class="hljs-keyword">import</span> *</span><br><span class="line">space = <span class="hljs-type">Dict</span>({<span class="hljs-string">'position'</span>:Discrete(<span class="hljs-number">2</span>), <span class="hljs-string">'velocity'</span>:Discrete(<span class="hljs-number">3</span>)})</span><br><span class="line"><span class="hljs-built_in">print</span>(space.sample())</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>输出是</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(<span class="hljs-string">'position'</span>, 1), (<span class="hljs-string">'velocity'</span>, 1)])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="nes-1942-动作空间配置">NES 1942 动作空间配置</h2>
<p>了解了 gym/retro 的动作空间，我们来看看1942的默认动作空间
</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env = retro.make(game=<span class="hljs-string">'1942-Nes'</span>)</span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">"The size of action is: "</span>, env.action_space.shape)</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The size of action is:  (9,)</span><br></pre></td></tr></tbody></table></figure>
<p>表示有9个 Discrete 动作，包括 start, select这些控制键。</p>
<p>从训练1942角度来说，我们希望指定最少的有效动作取得最好的成绩。根据经验，我们知道这个游戏最重要的键是4个方向加上
fire
键。限定游戏动作空间，官方的做法是在创建游戏环境时，指定预先生成的动作输入配置文件。但是这个方式相对麻烦，我们采用了直接指定按键的二进制表示来达到同样的目的，此时，需要设置
use_restricted_actions=retro.Actions.FILTERED。</p>
<p>下面的代码限制了6种按键，并随机play。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">action_list = [</span><br><span class="line">    <span class="hljs-comment"># No Operation</span></span><br><span class="line">    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">    <span class="hljs-comment"># Left</span></span><br><span class="line">    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">    <span class="hljs-comment"># Right</span></span><br><span class="line">    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">    <span class="hljs-comment"># Down</span></span><br><span class="line">    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">    <span class="hljs-comment"># Up</span></span><br><span class="line">    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">    <span class="hljs-comment"># B</span></span><br><span class="line">    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_play</span>(<span class="hljs-params">env, action_list, sleep_seconds=<span class="hljs-number">0.01</span></span>):</span></span><br><span class="line">    env.viewer = <span class="hljs-literal">None</span></span><br><span class="line">    state = env.reset()</span><br><span class="line">    score = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):</span><br><span class="line">        env.render()</span><br><span class="line">        time.sleep(sleep_seconds)</span><br><span class="line">        action = np.random.randint(<span class="hljs-built_in">len</span>(action_list))</span><br><span class="line"></span><br><span class="line">        next_state, reward, done, _ = env.step(action_list[action])</span><br><span class="line">        state = next_state</span><br><span class="line">        score += reward</span><br><span class="line">        <span class="hljs-keyword">if</span> done:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Episode Score: "</span>, score)</span><br><span class="line">            env.reset()</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">            </span><br><span class="line">env = retro.make(game=<span class="hljs-string">'1942-Nes'</span>, use_restricted_actions=retro.Actions.FILTERED)</span><br><span class="line">random_play(env, action_list)</span><br></pre></td></tr></tbody></table></figure>
<p>来看看其游戏效果，全随机死的还是比较快。</p>
<figure>
<img src="/zh/2021/rl-ppo-1984/random.gif">
<figcaption>
</figcaption>
</figure>
<h2 id="图像输入处理">图像输入处理</h2>
<p>一般对于通过屏幕像素作为输入的RL
end-to-end训练来说，对图像做预处理很关键。因为原始图像较大，一方面我们希望能尽量压缩图像到比较小的tensor，另一方面又要保证关键信息不丢失，比如子弹的图像不能因为图片缩小而消失。另外的一个通用技巧是将多个连续的frame合并起来组成立体的frame，这样可以有效表示连贯动作。</p>
<p>下面的代码通过 pipeline 将游戏每帧原始图像从shape (224, 240, 3)
转换成 (4, 84, 84)，也就是原始的 width=224，height=240，rgb=3转换成
width=84，height=240，stack_size=4的黑白图像。具体 pipeline为</p>
<ol type="1">
<li><p>MaxAndSkipEnv：每两帧过滤一帧图像，减少数据量。</p></li>
<li><p>FrameDownSample：down sample 图像到指定小分辨率
84x84，并从彩色降到黑白。</p></li>
<li><p>FrameBuffer：合并连续的4帧，形成 (4, 84, 84) 的图像输入</p></li>
</ol>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_env</span>():</span></span><br><span class="line">    env = retro.make(game=<span class="hljs-string">'1942-Nes'</span>, use_restricted_actions=retro.Actions.FILTERED)</span><br><span class="line">    env = MaxAndSkipEnv(env, skip=<span class="hljs-number">2</span>)</span><br><span class="line">    env = FrameDownSample(env, (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span><br><span class="line">    env = FrameBuffer(env, <span class="hljs-number">4</span>)</span><br><span class="line">    env.seed(<span class="hljs-number">0</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> env</span><br></pre></td></tr></tbody></table></figure>
<p>观察图像维度变换</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env = retro.make(game=<span class="hljs-string">'1942-Nes'</span>, use_restricted_actions=retro.Actions.FILTERED)</span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Initial shape: "</span>, env.observation_space.shape)</span><br><span class="line"></span><br><span class="line">env = build_env(env)</span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Processed shape: "</span>, env.observation_space.shape)</span><br></pre></td></tr></tbody></table></figure>
<p>确保shape 从 (224, 240, 3) 转换成 (4, 84, 84)</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initial shape:  (224, 240, 3)</span><br><span class="line">Processed shape:  (4, 84, 84)</span><br></pre></td></tr></tbody></table></figure>
<p>FrameDownSample实现如下，我们使用了 cv2
类库来完成黑白化和图像缩放</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameDownSample</span>(<span class="hljs-params">ObservationWrapper</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, env, exclude, width=<span class="hljs-number">84</span>, height=<span class="hljs-number">84</span></span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(FrameDownSample, self).__init__(env)</span><br><span class="line">        self.exclude = exclude</span><br><span class="line">        self.observation_space = Box(low=<span class="hljs-number">0</span>,</span><br><span class="line">                                     high=<span class="hljs-number">255</span>,</span><br><span class="line">                                     shape=(width, height, <span class="hljs-number">1</span>),</span><br><span class="line">                                     dtype=np.uint8)</span><br><span class="line">        self._width = width</span><br><span class="line">        self._height = height</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">observation</span>(<span class="hljs-params">self, observation</span>):</span></span><br><span class="line">        <span class="hljs-comment"># convert image to gray scale</span></span><br><span class="line">        screen = cv2.cvtColor(observation, cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># crop screen [up: down, left: right]</span></span><br><span class="line">        screen = screen[self.exclude[<span class="hljs-number">0</span>]:self.exclude[<span class="hljs-number">2</span>], self.exclude[<span class="hljs-number">3</span>]:self.exclude[<span class="hljs-number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># to float, and normalized</span></span><br><span class="line">        screen = np.ascontiguousarray(screen, dtype=np.float32) / <span class="hljs-number">255</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># resize image</span></span><br><span class="line">        screen = cv2.resize(screen, (self._width, self._height), interpolation=cv2.INTER_AREA)</span><br><span class="line">        <span class="hljs-keyword">return</span> screen</span><br></pre></td></tr></tbody></table></figure>
<p>MaxAndSkipEnv，每两帧过滤一帧</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxAndSkipEnv</span>(<span class="hljs-params">Wrapper</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, env=<span class="hljs-literal">None</span>, skip=<span class="hljs-number">4</span></span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(MaxAndSkipEnv, self).__init__(env)</span><br><span class="line">        self._obs_buffer = deque(maxlen=<span class="hljs-number">2</span>)</span><br><span class="line">        self._skip = skip</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, action</span>):</span></span><br><span class="line">        total_reward = <span class="hljs-number">0.0</span></span><br><span class="line">        done = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._skip):</span><br><span class="line">            obs, reward, done, info = self.env.step(action)</span><br><span class="line">            self._obs_buffer.append(obs)</span><br><span class="line">            total_reward += reward</span><br><span class="line">            <span class="hljs-keyword">if</span> done:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        max_frame = np.<span class="hljs-built_in">max</span>(np.stack(self._obs_buffer), axis=<span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> max_frame, total_reward, done, info</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        self._obs_buffer.clear()</span><br><span class="line">        obs = self.env.reset()</span><br><span class="line">        self._obs_buffer.append(obs)</span><br><span class="line">        <span class="hljs-keyword">return</span> obs</span><br></pre></td></tr></tbody></table></figure>
<p>FrameBuffer，将最近的4帧合并起来</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameBuffer</span>(<span class="hljs-params">ObservationWrapper</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, env, num_steps, dtype=np.float32</span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(FrameBuffer, self).__init__(env)</span><br><span class="line">        obs_space = env.observation_space</span><br><span class="line">        self._dtype = dtype</span><br><span class="line">        self.observation_space = Box(low=<span class="hljs-number">0</span>, high=<span class="hljs-number">255</span>, shape=(num_steps, obs_space.shape[<span class="hljs-number">0</span>], obs_space.shape[<span class="hljs-number">1</span>]), dtype=self._dtype)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        frame = self.env.reset()</span><br><span class="line">        self.buffer = np.stack(arrays=[frame, frame, frame, frame])</span><br><span class="line">        <span class="hljs-keyword">return</span> self.buffer</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">observation</span>(<span class="hljs-params">self, observation</span>):</span></span><br><span class="line">        self.buffer[:-<span class="hljs-number">1</span>] = self.buffer[<span class="hljs-number">1</span>:]</span><br><span class="line">        self.buffer[-<span class="hljs-number">1</span>] = observation</span><br><span class="line">        <span class="hljs-keyword">return</span> self.buffer</span><br></pre></td></tr></tbody></table></figure>
<p>最后，visualize
处理后的图像，同样还是在随机play中，确保关键信息不丢失</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_play_preprocessed</span>(<span class="hljs-params">env, action_list, sleep_seconds=<span class="hljs-number">0.01</span></span>):</span></span><br><span class="line">    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">    env.viewer = <span class="hljs-literal">None</span></span><br><span class="line">    state = env.reset()</span><br><span class="line">    score = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):</span><br><span class="line">        time.sleep(sleep_seconds)</span><br><span class="line">        action = np.random.randint(<span class="hljs-built_in">len</span>(action_list))</span><br><span class="line"></span><br><span class="line">        plt.imshow(state[-<span class="hljs-number">1</span>], cmap=<span class="hljs-string">"gray"</span>)</span><br><span class="line">        plt.title(<span class="hljs-string">'Pre Processed image'</span>)</span><br><span class="line">        plt.pause(sleep_seconds)</span><br><span class="line"></span><br><span class="line">        next_state, reward, done, _ = env.step(action_list[action])</span><br><span class="line">        state = next_state</span><br><span class="line">        score += reward</span><br><span class="line">        <span class="hljs-keyword">if</span> done:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Episode Score: "</span>, score)</span><br><span class="line">            env.reset()</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br></pre></td></tr></tbody></table></figure>
<p>matplotlib 动画输出</p>
<figure>
<img src="/zh/2021/rl-ppo-1984/preprocess.gif">
<figcaption>
</figcaption>
</figure>
<h2 id="cnn-actor-critic">CNN Actor &amp; Critic</h2>
<p>Actor 和 Critic 模型相同，输入是 (4, 84, 84) 的图像，输出是 [0, 5]
的action index。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>(<span class="hljs-params">nn.Module</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, input_shape, num_actions</span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(Actor, self).__init__()</span><br><span class="line">        self.input_shape = input_shape</span><br><span class="line">        self.num_actions = num_actions</span><br><span class="line"></span><br><span class="line">        self.features = nn.Sequential(</span><br><span class="line">            nn.Conv2d(input_shape[<span class="hljs-number">0</span>], <span class="hljs-number">32</span>, kernel_size=<span class="hljs-number">8</span>, stride=<span class="hljs-number">4</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">4</span>, stride=<span class="hljs-number">2</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(self.feature_size(), <span class="hljs-number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="hljs-number">512</span>, self.num_actions),</span><br><span class="line">            nn.Softmax(dim=<span class="hljs-number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span></span><br><span class="line">        x = self.features(x)</span><br><span class="line">        x = x.view(x.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        dist = Categorical(x)</span><br><span class="line">        <span class="hljs-keyword">return</span> dist</span><br></pre></td></tr></tbody></table></figure>
<h2 id="ppo核心代码">PPO核心代码</h2>
<p>先计算 <span class="math inline">\(r_t(\theta)\)</span>，这里采用了一个技巧，对 <span class="math inline">\(\pi_\theta\)</span> 取 log，相减再取
exp，这样可以增强数值稳定性。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dist = self.actor_net(state)</span><br><span class="line">new_log_probs = dist.log_prob(action)</span><br><span class="line">ratio = (new_log_probs - old_log_probs).exp()</span><br><span class="line">surr1 = ratio * advantage</span><br></pre></td></tr></tbody></table></figure>
<p>surr1 对应PPO论文中的 <span class="math inline">\(L^{CPI}\)</span></p>
<figure>
<img src="/zh/2021/rl-ppo-1984/L_CPI.PNG">
<figcaption>
</figcaption>
</figure>
<p>然后计算 surr2，对应 <span class="math inline">\(L^{CLIP}\)</span>
中的 clip 部分，clip可以由 torch.clamp 函数实现。<span class="math inline">\(L^{CLIP}\)</span> 则对应 actor_loss。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">surr2 = torch.clamp(ratio, <span class="hljs-number">1.0</span> - self.clip_param, <span class="hljs-number">1.0</span> + self.clip_param) * advantage</span><br><span class="line">actor_loss = - torch.<span class="hljs-built_in">min</span>(surr1, surr2).mean()</span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="/zh/2021/rl-ppo-1984/L_CLIP.PNG">
<figcaption>
</figcaption>
</figure>
<p>最后，计算总的 loss <span class="math inline">\(L_t^{CLIP+VF+S}\)</span>，包括
actor_loss，critic_loss 和 policy的 entropy。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entropy = dist.entropy().mean()</span><br><span class="line"></span><br><span class="line">critic_loss = (return_ - value).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean()</span><br><span class="line">loss = actor_loss + <span class="hljs-number">0.5</span> * critic_loss - <span class="hljs-number">0.001</span> * entropy</span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="/zh/2021/rl-ppo-1984/loss.PNG">
<figcaption>
</figcaption>
</figure>
<p>上述完整代码如下</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.ppo_epoch):</span><br><span class="line">    <span class="hljs-keyword">for</span> state, action, old_log_probs, return_, advantage <span class="hljs-keyword">in</span> sample_batch():</span><br><span class="line">        dist = self.actor_net(state)</span><br><span class="line">        value = self.critic_net(state)</span><br><span class="line"></span><br><span class="line">        entropy = dist.entropy().mean()</span><br><span class="line">        new_log_probs = dist.log_prob(action)</span><br><span class="line"></span><br><span class="line">        ratio = (new_log_probs - old_log_probs).exp()</span><br><span class="line">        surr1 = ratio * advantage</span><br><span class="line">        surr2 = torch.clamp(ratio, <span class="hljs-number">1.0</span> - self.clip_param, <span class="hljs-number">1.0</span> + self.clip_param) * advantage</span><br><span class="line"></span><br><span class="line">        actor_loss = - torch.<span class="hljs-built_in">min</span>(surr1, surr2).mean()</span><br><span class="line">        critic_loss = (return_ - value).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean()</span><br><span class="line"></span><br><span class="line">        loss = actor_loss + <span class="hljs-number">0.5</span> * critic_loss - <span class="hljs-number">0.001</span> * entropy</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># Minimize the loss</span></span><br><span class="line">        self.actor_optimizer.zero_grad()</span><br><span class="line">        self.critic_optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.actor_optimizer.step()</span><br><span class="line">        self.critic_optimizer.step()</span><br></pre></td></tr></tbody></table></figure>
<p>补充一下 GAE 的计算，advantage 根据公式</p>
<figure>
<img src="/zh/2021/rl-ppo-1984/gae.PNG">
<figcaption>
</figcaption>
</figure>
<p>可以转换成如下代码</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_gae</span>(<span class="hljs-params">self, next_value</span>):</span></span><br><span class="line">    gae = <span class="hljs-number">0</span></span><br><span class="line">    returns = []</span><br><span class="line">    values = self.values + [next_value]</span><br><span class="line">    <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.rewards))):</span><br><span class="line">        delta = self.rewards[step] + self.gamma * values[step + <span class="hljs-number">1</span>] * self.masks[step] - values[step]</span><br><span class="line">        gae = delta + self.gamma * self.tau * self.masks[step] * gae</span><br><span class="line">        returns.insert(<span class="hljs-number">0</span>, gae + values[step])</span><br><span class="line">    <span class="hljs-keyword">return</span> returns</span><br></pre></td></tr></tbody></table></figure>
<h2 id="外层-training-代码">外层 Training 代码</h2>
<p>外层调用代码基于随机 play 的逻辑，agent.act()封装了采样和 forward
prop，agent.step() 则封装了 backprop 和参数学习迭代的逻辑。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i_episode <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_epoch + <span class="hljs-number">1</span>, n_episodes + <span class="hljs-number">1</span>):</span><br><span class="line">    state = env.reset()</span><br><span class="line">    score = <span class="hljs-number">0</span></span><br><span class="line">    timestamp = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> timestamp &lt; <span class="hljs-number">10000</span>:</span><br><span class="line">        action, log_prob, value = agent.act(state)</span><br><span class="line">        next_state, reward, done, info = env.step(action_list[action])</span><br><span class="line">        score += reward</span><br><span class="line">        timestamp += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        agent.step(state, action, value, log_prob, reward, done, next_state)</span><br><span class="line">        <span class="hljs-keyword">if</span> done:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            state = next_state</span><br></pre></td></tr></tbody></table></figure>
<h2 id="训练结果">训练结果</h2>
<p>让我们来看看学习的效果吧，注意我们的飞机学到了一些关键的技巧，躲避子弹；飞到角落尽快击毙敌机；一定程度预测敌机出现的位置并预先走到位置。</p>
<div class="bili_video"><iframe src="https://player.bilibili.com/player.html?aid=NaN&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="544" height="452" allowfullscreen="true"> </iframe></div>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/stat-ml-mle-1/" itemprop="url">深入形象地理解极大似然估计(MLE) 1: 引入问题</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-04-03T18:45:01.000Z" itemprop="datePublished">4月 4 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2816 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>导读：极大似然估计(MLE)
是统计机器学习中最基本的概念，但是能真正全面深入地理解它的性质和背后和其他基本理论的关系不是件容易的事情。极大似然估计和以下概念都有着紧密的联系：随机变量，无偏性质（unbiasedness），一致估计（consistent），asymptotic
normality，最优化（optimization），Fisher
Information，MAP（最大后验估计），KL-Divergence，sufficient
statistics等。在众多阐述 MLE
的文章或者课程中，总体来说都比较抽象，注重公式推导。本系列文章受3blue1brown
可视化教学的启发，坚持从第一性原理出发，通过数学原理结合模拟和动画，深入浅出地让读者理解极大似然估计。</p>
<p>相关链接</p>
<h2 id="抛硬币问题">抛硬币问题</h2>
<p>我们来思考这个老套问题，考虑手上有一枚硬币，旋转（抛）硬币得到正反面的概率固定（令正面概率为<span class="math inline">\(\theta^{\star}\)</span>）但未知，我们如何能通过实验推测出
<span class="math inline">\(\theta^{\star}\)</span></p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/toss.gif">
<figcaption>
</figcaption>
</figure>
<p>朴素的想法是，不断尝试抛硬币，随着次数 n 的增多，正面的比例会趋近于
<span class="math inline">\(\theta^{\star}\)</span></p>
<p>对应到数学形式上，令我们对于 <span class="math inline">\(\theta^{\star}\)</span> 的估计为 <span class="math inline">\(\hat{\theta}_{n}\)</span>，则希望 <span class="math display">\[
\hat{\theta}_n = {n_{head} \over n} \to \theta^{\star} \text{  as n }
\to \infty
\]</span></p>
<h2 id="模拟试验代码">模拟试验代码</h2>
<p>假设我们尝试了n次，每次的结果为 <span class="math inline">\(x_i\)</span>，<span class="math inline">\(x_i\)</span>为1（正面） 或
0（反面）。比如试了三次的结果是 [1, 0, 1]，则 <span class="math inline">\(x_1=1, x_2=0,
x_3=1\)</span>。一般，我们将观察到的数据写成向量形式</p>
<p><span class="math display">\[X=[x_1, x_2, x_3]^T=[1, 0,
1]^{T}\]</span></p>
<p>我们知道硬币的正反结果符合伯努利分布，也就是 <span class="math display">\[
\begin{align*}
P_{ber}(x;\theta) =
\left\lbrace
  \begin{array}{r@{}l}
   \theta &amp;\text{  if x=1} \\
   1-\theta &amp;\text{  if x=0}
\end{array}
\right.
\end{align*}
\]</span></p>
<p>因为 x
只有0，1两种取值，因此上式也可以写成等价如下的不含条件分支的形式 <span class="math display">\[
P_{ber} = \theta^x \cdot (1-\theta)^x
\]</span></p>
<p>假设 <span class="math inline">\(\theta^{\star} =
0.7\)</span>，如果做 n=10 次试验，结果应该比较接近7个1，3个0。</p>
<p>下面我们来模拟一下 n=10，看看结果如何。</p>
<p>下面代码的实现上我们直接使用了pytorch 内置的 bernoulli 函数生成 n
个随机变量实例 </p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_coins</span>(<span class="hljs-params">theta, n=<span class="hljs-number">1</span></span>):</span></span><br><span class="line">    <span class="hljs-keyword">import</span> torch</span><br><span class="line">    theta_vec = torch.tensor(n*[theta])</span><br><span class="line">    random_values = torch.bernoulli(theta_vec)</span><br><span class="line">    <span class="hljs-keyword">return</span> random_values</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>让我们来做三次 n=10 的试验</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">    coins = gen_coins(theta=<span class="hljs-number">0.7</span>, n=<span class="hljs-number">10</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'trial <span class="hljs-subst">{i}</span>'</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'head #: <span class="hljs-subst">{<span class="hljs-built_in">sum</span>(coins)}</span>'</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'tail #: <span class="hljs-subst">{<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>-coins)}</span>'</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>()</span><br></pre></td></tr></tbody></table></figure>
<p>能发现 7个1，3个0 确实是比较可能的结果。 </p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trial 0</span><br><span class="line">head <span class="hljs-comment">#: 7.0</span></span><br><span class="line">tail <span class="hljs-comment">#: 3.0</span></span><br><span class="line"></span><br><span class="line">trial 1</span><br><span class="line">head <span class="hljs-comment">#: 9.0</span></span><br><span class="line">tail <span class="hljs-comment">#: 1.0</span></span><br><span class="line"></span><br><span class="line">trial 2</span><br><span class="line">head <span class="hljs-comment">#: 7.0</span></span><br><span class="line">tail <span class="hljs-comment">#: 3.0</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="生成概率">生成概率</h2>
<p>直觉告诉我们，当 <span class="math inline">\(\theta^{\star}=0.7\)</span> 时，根据 $P_{ber}(x;)
$，7个1，3个0 出现的概率应该是最大，6个1，4个0 或者 8个1，2个0
这两种情况出现概率稍小，其他的情况概率更小。通过基本概率和伯努利公式，重复
n 次试验
1和0出现的概率可以由下面公式算出。（注：7个1，3个0不是单一事件，需要乘以组合数算出实际概率）</p>
<p><span class="math display">\[
P_{X} = \theta^{heads} \cdot (1-\theta)^{tails} \cdot {n \choose heads}
\]</span></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>P(X)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>head=0</td>
<td>0.000006</td>
</tr>
<tr class="even">
<td>head=1</td>
<td>0.000138</td>
</tr>
<tr class="odd">
<td>head=2</td>
<td>0.000032</td>
</tr>
<tr class="even">
<td>head=3</td>
<td>0.001447</td>
</tr>
<tr class="odd">
<td>head=4</td>
<td>0.036757</td>
</tr>
<tr class="even">
<td>head=5</td>
<td>0.102919</td>
</tr>
<tr class="odd">
<td>head=6</td>
<td>0.200121</td>
</tr>
<tr class="even">
<td>head=7</td>
<td>0.266828</td>
</tr>
<tr class="odd">
<td>head=8</td>
<td>0.233474</td>
</tr>
<tr class="even">
<td>head=9</td>
<td>0.121061</td>
</tr>
<tr class="odd">
<td>head=10</td>
<td>0.028248</td>
</tr>
</tbody>
</table>
<p>画出图看的很明显，1出现7次的概率确实最大。</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/joint_prob.png">
<figcaption>
</figcaption>
</figure>
<p>回到我们的问题，我们先假定 <span class="math inline">\(\theta^{\star}
= 0.7\)</span> 的硬币做 n=10 次试验的结果就是 7个1，3个0，或者具体序列为
[1, 0, 0, 1, 0, 1, 1, 1, 1, 1]。那么我们希望按照某种方法推测的估计值
<span class="math inline">\(\hat\theta\)</span> 也为 0.7。</p>
<p>若将这个方法也记做 <span class="math inline">\(\hat\theta\)</span>，它是<span class="math inline">\(X\)</span> 的函数，即 <span class="math inline">\(\hat\theta(X=[1, 0, 0, 1, 0, 1, 1, 1, 1,
1]^T)=0.7\)</span></p>
<p>我们如何构建这个方法呢？很显然，<span class="math inline">\(X\)</span> 中 1 的个数就可以胜任，<span class="math inline">\(\hat\theta=\bar
X\)</span>。这个方式确实是正确的，后面的文章我们也会证明它是MLE在伯努利分布参数估计时的计算方法。</p>
<p>但是伯努利分布参数估计的问题中是最简单的情况，背后对应的更一般的问题是：假设我们知道某个过程或者实验生成了某种分布
P，但是不知道它的参数 <span class="math inline">\(\theta\)</span>，如何能通过反复的试验来推断 <span class="math inline">\(\theta\)</span>，同时，我们希望随着试验次数的增多，<span class="math inline">\(\hat\theta\)</span> 能逼近 <span class="math inline">\(\theta\)</span>。</p>
<p>由于过程是有随机性，试验结果 <span class="math inline">\(X\)</span>
并不能确定一定是从 <span class="math inline">\(\hat\theta\)</span>
生成的，因此我们需要对所有 <span class="math inline">\(\theta\)</span>
打分。对于抛硬币试验来说，我们穷举所有在 [0, 1] 范围内的 <span class="math inline">\(\theta\)</span>，定义它的打分函数 <span class="math inline">\(f(\theta)\)</span>，并且希望我们定义的 <span class="math inline">\(f(\theta;X=[1, 0, 0, 1, 0, 1, 1, 1, 1,
1]^T)\)</span> 在 <span class="math inline">\(\theta=0.7\)</span>
时得分最高。推广到一般场景，有如下性质 <span class="math display">\[
f(\theta^\star;X) &gt;= f(\theta;X)
\]</span></p>
<p>如此，我们将推测参数问题转换成了优化问题 <span class="math display">\[
\hat\theta = \theta^{\star} = \operatorname{argmax}_{\theta} f(\theta;
X) = 0.7
\]</span></p>
<h2 id="朴素方法">朴素方法</h2>
<p>一种朴素的想法是，由于 <span class="math inline">\(\theta^\star=0.7\)</span>，因此我们每次的结果应该稍微偏向
1，如果出现了
1，就记0.7分，出现了0，记0.3分，那么我们可以用10个结果的总分来定义总得分，即最大化函数</p>
<p><span class="math display">\[
\begin{equation*}
\begin{aligned}
&amp;\operatorname{argmax}_{\theta} f(\theta) \\
=&amp; \operatorname{argmax}_{\theta} P(x_1) + P(x_2) + ... + P(x_n) \\
=&amp; \operatorname{argmax}_{\theta} P(x_1|\theta) + P(x_2|\theta) +
... + P(x_n|\theta) \\
=&amp; \operatorname{argmax}_{\theta} \sum P(x_i|\theta) \\
\end{aligned}
\end{equation*}
\]</span></p>
<p>很可惜，我们定义的 f 并不符合 <span class="math inline">\(\theta=0.7\)</span> 时取到最大的原则。下面画出了
<span class="math inline">\(\theta\)</span> 在 [0, 1] 范围内 f 值，X
固定为 [1, 0, 0, 1, 0, 1, 1, 1, 1, 1]。显然，极值在 0.5 左右。</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/sum-likelihood_w.gif">
<figcaption>
</figcaption>
</figure>
<p>这种对于观察到的变量实例在整个参数空间打分的方法是最大似然方法的雏形。我们将每次试验结果对于不同
<span class="math inline">\(\theta\)</span>
的打分就是似然函数的概念。</p>
<h2 id="伯努利似然函数likelihood">伯努利似然函数（Likelihood)</h2>
<p>伯努利单个结果的似然函数 <span class="math inline">\(l(\theta)\)</span> 视为 <span class="math inline">\(\theta\)</span>
的函数，x视为给定值，它等价于概率质量函数 PMF</p>
<p><span class="math display">\[
l(\theta|x) = \theta^x \cdot (1-\theta)^x
\]</span></p>
<h2 id="极大似然估计mle">极大似然估计(MLE)</h2>
<p>有了单个结果的似然函数，我们如何定义 <span class="math inline">\(f(\theta)\)</span> 呢？我们定义的 <span class="math inline">\(f(\theta)\)</span> 需要满足，在 <span class="math inline">\(\theta^\star=0.7\)</span> ，<span class="math inline">\(n=10\)</span> 的情况下，试验最有可能的结果是 7
个1，3个0，此时 f 需要在 <span class="math inline">\(\theta=0.7\)</span>
时取到最大值。</p>
<p>极大似然估计(MLE) 为我们定义了合理的 <span class="math inline">\(f(\theta)\)</span>
，和朴素的想法类似，但是这次用单个结果的似然函数连乘而非连加 <span class="math display">\[
L(\theta|X) = l(\theta|x_1) \cdot l(\theta|x_2) \cdot ...l(\theta|x_n) =
\prod l(\theta|x_i)
\]</span></p>
<p>我们再来看一下当 $X=[1, 0, 0, 1, 0, 1, 1, 1, 1, 1] $ 时 <span class="math inline">\(L\)</span> 在 <span class="math inline">\(\theta\)</span> 空间的取值情况，果然，MLE 能在
0.7时取到最大值。</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/prod_likelihood_w.gif">
<figcaption>
</figcaption>
</figure>
<h2 id="对数似然函数">对数似然函数</h2>
<p>最大似然函数 $_{} L() $ 能让我们找到最可能的 <span class="math inline">\(\theta\)</span>，但现实中，我们一般采用最大其 log
的形式。</p>
<p><span class="math display">\[
\begin{equation*}
\begin{aligned}
&amp;\operatorname{argmax}_{\theta} \log L(\theta|X) \\
=&amp; \operatorname{argmax}_{\theta} \log [l(\theta|x_1) \cdot
l(\theta|x_2) \cdot ... \cdot l(\theta|x_n)]   \\
=&amp; \operatorname{argmax}_{\theta} \log l(\theta|x_1) + \log
l(\theta|x_2) \cdot ... + \log l(\theta|x_n)
\end{aligned}
\end{equation*}
\]</span></p>
<p>理论能证明，最大对数似然函数得到的极值等价于最大似然函数。但这么做有什么额外好处呢？</p>
<p>我们先将对数似然函数画出来</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/prod_log_likelihood_w.gif">
<figcaption>
</figcaption>
</figure>
<p>它的极大值也在 0.7，但是我们发现对数似然函数是个 concave
函数。在优化领域，最大化 concave 函数或者最小化 convex
函数可以有非常高效的解法。再仔细看之前的似然函数，它并不是一个 concave
函数。另一个非常重要的好处是，随着 n 的增大，连乘会导致浮点数
underflow，而单个点的对数似然函数的和的形式就不会有这个问题。</p>
<h2 id="pytorch-mle-代码">Pytorch MLE 代码</h2>
<p>就让我们来实践一下，通过 pytorch 梯度上升来找到极值点。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> stats.coin <span class="hljs-keyword">import</span> gen_coins</span><br><span class="line"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">num_head: <span class="hljs-built_in">int</span>, num_tail: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:</span></span><br><span class="line">    <span class="hljs-keyword">import</span> torch</span><br><span class="line">    theta = torch.tensor(<span class="hljs-number">0.5</span>, requires_grad=<span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line">    recent = deque(<span class="hljs-number">3</span>*[<span class="hljs-number">100</span>], maxlen=<span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">    lr = <span class="hljs-number">0.00001</span></span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-built_in">iter</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>):</span><br><span class="line">        loss = -(num_head * torch.log(theta) + num_tail * torch.log(<span class="hljs-number">1</span> - theta))</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="hljs-keyword">with</span> torch.no_grad():</span><br><span class="line">            theta -= lr * theta.grad</span><br><span class="line">            <span class="hljs-comment"># print(f'{iter}: {theta}, {theta.grad}')</span></span><br><span class="line">            recent.append(theta.grad.item())</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">abs</span>(x) &lt; <span class="hljs-number">1</span>, recent)):</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        theta.grad.zero_()</span><br><span class="line">    <span class="hljs-keyword">return</span> theta.item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    data = gen_coins(<span class="hljs-number">0.6</span>, n=<span class="hljs-number">200</span>)</span><br><span class="line"></span><br><span class="line">    num_head = (data.detach() == <span class="hljs-number">1</span>).<span class="hljs-built_in">sum</span>().item()</span><br><span class="line">    num_tail = (data.detach() == <span class="hljs-number">0</span>).<span class="hljs-built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">print</span>(num_head, num_tail)</span><br><span class="line">    <span class="hljs-built_in">print</span>(train(num_head, num_tail))</span><br></pre></td></tr></tbody></table></figure>
<p>一点需要说明的是，在迭代过程中，我们保存最后三个导数的值，当最新的三个导数都很小时就退出迭代。</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if all(map(lambda x: abs(x) &lt; 1, recent))</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，能发现最大化对数似然函数能很稳定的找到 <span class="math inline">\(\theta\)</span>。</p>
<p>现在大家对于伯努利MLE有了一定了解，接着，我们来思考一下最大化似然函数方法是否随着观察次数的增多能不断逼近真实的
<span class="math inline">\(\theta^\star\)</span>呢？</p>
<h2 id="mle-theta-估计的收敛性">MLE <span class="math inline">\(\theta\)</span> 估计的收敛性</h2>
<p><span class="math inline">\(\theta^\star=0.7\)</span>
的情况下，我们来这样做试验，第一次做 n=1生成观察数据 <span class="math inline">\(X_{1}\)</span>，第二次做 n=2生成观察数据 <span class="math inline">\(X_{2}\)</span> <span class="math display">\[
X_1,X_2, X_3, ..., X_N
\]</span> 对于每个数据集 <span class="math inline">\(X_i\)</span>
通过最大似然方法求得估计的 <span class="math inline">\(\hat\theta\)</span> <span class="math display">\[
\hat\theta_1=MLE(X_1), \hat\theta_2=MLE(X_2), ..., \hat\theta_N=MLE(X_N)
\]</span> 将这些 <span class="math inline">\(\hat\theta_i\)</span>
画出来，可以看到，随着 <span class="math inline">\(n \to
\infty\)</span>，<span class="math inline">\(\hat\theta_i \to
\theta^\star=0.7\)</span></p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/bias_w.gif">
<figcaption>
</figcaption>
</figure>
<p>换一个角度来看一下，我们将 <span class="math inline">\(\hat\theta_i\)</span>
数列按照顺序，离散化后再归一化比例，如下图画出来，红色的柱代表了最新的值
<span class="math inline">\(\hat\theta\)</span>。可以发现，初始时候，<span class="math inline">\(\hat\theta\)</span> 在较远离 0.7 的地方出现，随着
n 的增大，出现的位置比较接近 0.7。</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/converge_w.gif">
<figcaption>
</figcaption>
</figure>
<h2 id="mle-theta-估计的偏差和方差">MLE <span class="math inline">\(\theta\)</span> 估计的偏差和方差</h2>
<p>我们已经知道 MLE 方法可以通过观察数据推测出最有可能的 <span class="math inline">\(\hat\theta\)</span>，由于观察数据 <span class="math inline">\(X\)</span> 是伯努利过程产生的，具有随机性，那么
<span class="math inline">\(\hat\theta\)</span> 可以看成是 <span class="math inline">\(\theta^\star\)</span>
的随机变量。我们已经通过上面的试验知道随着试验次数的增大，我们的估计会越来越逼近真实值，现在的问题是对于<strong>固定的n</strong>，<span class="math inline">\(\hat\theta\)</span>
的方差是多少，它的均值是否是无偏的呢？</p>
<p>带着这样的疑问，我们现在做如下试验：</p>
<p>固定 n=10，重复做实验，画出随着次数增多 <span class="math inline">\(\hat\theta\)</span>
的分布，见图中绿色部分。同样的，红色是 n=80 不断试验的分布变换。</p>
<figure>
<img src="/zh/2021/stat-ml-mle-1/theta_variance_w.gif">
<figcaption>
</figcaption>
</figure>
<p>看的出来，随着试验次数的增多 - <span class="math inline">\(\hat\theta_{10}, \hat\theta_{80}\)</span>
都趋近于正态分布</p>
<ul>
<li><p><span class="math inline">\(\hat\theta_{10}\)</span> 的分散度比 $
_{80}$ 要大，即方差要大</p></li>
<li><p><span class="math inline">\(\hat\theta_{10},
\hat\theta_{80}\)</span> 的均值都在 0.7</p></li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2021/leetcode-1029-two-city-scheduling/" itemprop="url">Leetcode 1029 两地调度优化解法（附OR-Tools和PuLP代码）</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-02-19T18:45:01.000Z" itemprop="datePublished">2月 20 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 读完 (约 1850 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><h2 id="leetcode-1029.-两地调度-medium">Leetcode 1029. 两地调度
(medium)</h2>
<p>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B
市的费用为 costs[i][1]。</p>
<p>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N
人抵达。&nbsp;</p>
<p>示例：</p>
<blockquote>
<p>输入：[[10,20],[30,200],[400,50],[30,20]] 输出：110 解释： 第一个人去
A 市，费用为 10。 第二个人去 A 市，费用为 30。 第三个人去 B 市，费用为
50。 第四个人去 B 市，费用为 20。 最低总费用为 10 + 30 + 50 + 20 =
110，每个城市都有一半的人在面试。</p>
</blockquote>
<p>提示：</p>
<p>1 &lt;= costs.length &lt;= 100 costs.length 为偶数 1 &lt;=
costs[i][0], costs[i][1] &lt;= 1000</p>
<p>链接：https://leetcode-cn.com/problems/two-city-scheduling</p>
<h2 id="暴力枚举法">暴力枚举法</h2>
<p>最直接的方式是暴力枚举出所有分组的可能。因为 2N
个人平均分成两组，总数为 <span class="math inline">\({2n \choose
n}\)</span>，是 n 的指数级数量。在文章<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457480569&amp;idx=1&amp;sn=dd90016214931db2f48140d6e269b137&amp;chksm=87bc9b57b0cb12419631a7bcd96b5cd6e6d4081ffdfc49852572a31c4823bda4d42c5e73dcba&amp;scene=21#wechat_redirect">24
点游戏算法题的 Python 函数式实现: 学用itertools，yield，yield from
巧刷题</a>，我们展示如何调用 Python 的
itertools包，这里，我们也用同样的方式产生 [0, 2N]
的所有集合大小为N的可能（保存在left_set_list中），再遍历找到最小值即可。当然，这种解法会TLE，只是举个例子来体会一下暴力做法。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoCitySchedCost</span>(<span class="hljs-params">self, costs: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        L = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(costs))</span><br><span class="line">        <span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations</span><br><span class="line">        left_set_list = [<span class="hljs-built_in">set</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">list</span>(L), <span class="hljs-built_in">len</span>(L)//<span class="hljs-number">2</span>)]</span><br><span class="line"></span><br><span class="line">        min_total = math.inf</span><br><span class="line">        <span class="hljs-keyword">for</span> left_set <span class="hljs-keyword">in</span> left_set_list:</span><br><span class="line">            cost = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> L:</span><br><span class="line">                is_left = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> left_set <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line">                cost += costs[i][is_left]</span><br><span class="line">            min_total = <span class="hljs-built_in">min</span>(min_total, cost)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> min_total</span><br></pre></td></tr></tbody></table></figure>
<h2 id="on-ac解法">O(N) AC解法</h2>
<p>对于组合优化问题来说，例如TSP问题（解法链接 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA4NzkxNzM3Nw==&amp;mid=2457480484&amp;idx=1&amp;sn=bf45afaa2bd987747c34a03b9176e89f&amp;chksm=87bc9b0ab0cb121c311299dbf16a55fe76b2b60d6d9e073f37deec49e28766ca416860a7659c#rd">TSP问题从DP算法到深度学习1：递归DP方法
AC AIZU TSP问题</a>），一般都是
NP-Hard问题，意味着没有多项次复杂度的解法。但是这个问题比较特殊，它增加了一个特定条件：去城市A和城市B的人数相同，也就是我们已经知道两个分组的数量是一样的。我们仔细思考一下这个意味着什么？考虑只有四个人的小规模情况，如果让你来手动规划，你一定不会穷举出所有两两分组的可能，而是比较人与人相对的两个城市的cost差。举个例子，有如下四个人的costs
</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 A:3,  B:1</span><br><span class="line">1 A:99, B:100</span><br><span class="line">2 A:2,  B:2</span><br><span class="line">3 A:3,  B:3</span><br></pre></td></tr></tbody></table></figure> 虽然1号人去城市A（99）cost
很大，但是相比较他去B（100）来说，可以省下 100-99 = 1
的钱，这个钱比0号人去B不去A省下的钱 3-1 = 2
还要多，因此你一定会选择让1号人去A而让0号人去B。<p></p>
<p>有了这个想法，再整理一下，就会发现让某人去哪个城市和他去两个城市的cost
差 $ C_a -
C_b$相关，如果这个值越大，那么他越应该去B。但是最后决定他是否去B取决于他的差在所有人中的排名，由于两组人数相等，因此差能大到排在前一半，则他就去B，在后一半就去A。</p>
<p>按照这个思路，很快能写出代码，代码写法有很多，下面略举一例。代码中由于用到排序，复杂度为
<span class="math inline">\(O(N \cdot \log(N))\)</span>
。这里补充一点，理论上只需找数组中位数的值即可，最好的时间复杂度是 <span class="math inline">\(O(N)\)</span>。</p>
<p>代码实现上，cost_diff_list 将每个人的在原数组的index 和他的cost差组成
pair。即</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(0, cost_0), (1, cost_1), ... ]</span><br></pre></td></tr></tbody></table></figure>
<p>这样我们可以将这个数组按照cost排序，排完序后前面N个元素属于B城市。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 36 ms, faster than 87.77% of Python3 online submissions</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 14.5 MB, less than 14.84% of Python3 online</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoCitySchedCost</span>(<span class="hljs-params">self, costs: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        L = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(costs))</span><br><span class="line">        cost_diff_lst = [(i, costs[i][<span class="hljs-number">0</span>] - costs[i][<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> L]</span><br><span class="line">        cost_diff_lst.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line">        total_cost = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> c, (idx, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cost_diff_lst):</span><br><span class="line">            is_left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> c &lt; <span class="hljs-built_in">len</span>(L) // <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span></span><br><span class="line">            total_cost += costs[idx][is_left]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> total_cost</span><br></pre></td></tr></tbody></table></figure>
<h2 id="转换成整数规划问题">转换成整数规划问题</h2>
<p>这个问题对于略有算法经验的人来说，很类似于背包问题。它们都需要回答N个物品取或者不取，并同时最大最小化总cost。区别在它们的约束条件不一样。这道题的约束是去取（去城市A）和不取（去城市B）的数量一样。这一类问题即
<em>integer
programming</em>，即整数规划。下面我们选取两个比较流行的优化库来展示如何调包解这道题。</p>
<p>首先我们先来formulate这个问题，因为需要表达两个约束条件，我们将每个人的状态分成是否去A和是否去B两个变量。</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[i-th-person][0]: boolean 表示是否去 city a</span><br><span class="line">x[i-th-person][1]: boolean 表示是否去 city b</span><br></pre></td></tr></tbody></table></figure>
<p>这样，问题转换成如下优化模型</p>
<p><span class="math display">\[
\begin{array}{rrclcl}
\displaystyle \min_{x} &amp; costs[i][0] \cdot x[i][0] + costs[i][1]
\cdot x[i][1]\\
\textrm{s.t.} &amp; x[i][0] + x[i][1] =1\\
&amp;x[i][0] + x[i][1] + ... =N    \\
\end{array}
\]</span></p>
<h2 id="google-or-tools">Google OR-Tools</h2>
<p>Google OR-Tools
是业界最好的优化库，下面为调用代码，由于直接对应于上面的数学优化问题，不做赘述。当然
Leetcode上不支持这些第三方的库，肯定也不能AC。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> ortools.sat.python <span class="hljs-keyword">import</span> cp_model</span><br><span class="line"></span><br><span class="line">costs = [[<span class="hljs-number">515</span>,<span class="hljs-number">563</span>],[<span class="hljs-number">451</span>,<span class="hljs-number">713</span>],[<span class="hljs-number">537</span>,<span class="hljs-number">709</span>],[<span class="hljs-number">343</span>,<span class="hljs-number">819</span>],[<span class="hljs-number">855</span>,<span class="hljs-number">779</span>],[<span class="hljs-number">457</span>,<span class="hljs-number">60</span>],[<span class="hljs-number">650</span>,<span class="hljs-number">359</span>],[<span class="hljs-number">631</span>,<span class="hljs-number">42</span>]]</span><br><span class="line"></span><br><span class="line">I = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(costs))</span><br><span class="line"></span><br><span class="line">model = cp_model.CpModel()</span><br><span class="line">x = []</span><br><span class="line">total_cost = model.NewIntVar(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>, <span class="hljs-string">'total_cost'</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I:</span><br><span class="line">    t = []</span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):</span><br><span class="line">        t.append(model.NewBoolVar(<span class="hljs-string">'x[%i,%i]'</span> % (i, j)))</span><br><span class="line">    x.append(t)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Constraints</span></span><br><span class="line"><span class="hljs-comment"># Each person must be assigned to at exact one city</span></span><br><span class="line">[model.Add(<span class="hljs-built_in">sum</span>(x[i][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)) == <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I]</span><br><span class="line"><span class="hljs-comment"># equal number of person assigned to two cities</span></span><br><span class="line">model.Add(<span class="hljs-built_in">sum</span>(x[i][<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I) == (<span class="hljs-built_in">len</span>(I) // <span class="hljs-number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Total cost</span></span><br><span class="line">model.Add(total_cost == <span class="hljs-built_in">sum</span>(x[i][<span class="hljs-number">0</span>] * costs[i][<span class="hljs-number">0</span>] + x[i][<span class="hljs-number">1</span>] * costs[i][<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I))</span><br><span class="line">model.Minimize(total_cost)</span><br><span class="line"></span><br><span class="line">solver = cp_model.CpSolver()</span><br><span class="line">status = solver.Solve(model)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> status == cp_model.OPTIMAL:</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Total min cost = %i'</span> % solver.ObjectiveValue())</span><br><span class="line">    <span class="hljs-built_in">print</span>()</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I:</span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> solver.Value(x[i][j]) == <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-built_in">print</span>(<span class="hljs-string">'People '</span>, i, <span class="hljs-string">' assigned to city '</span>, j, <span class="hljs-string">'  Cost = '</span>, costs[i][j])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>完整代码可以从我的github下载。</p>
<p>https://github.com/MyEncyclopedia/leetcode/blob/master/1029_Two_City_Scheduling/1029_ortool.py</p>
<h2 id="pulp">PuLP</h2>
<p>类似的，另一种流行 python 优化库 PuLP 的代码为</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pulp</span><br><span class="line"></span><br><span class="line">costs = [[<span class="hljs-number">259</span>,<span class="hljs-number">770</span>],[<span class="hljs-number">448</span>,<span class="hljs-number">54</span>],[<span class="hljs-number">926</span>,<span class="hljs-number">667</span>],[<span class="hljs-number">184</span>,<span class="hljs-number">139</span>],[<span class="hljs-number">840</span>,<span class="hljs-number">118</span>],[<span class="hljs-number">577</span>,<span class="hljs-number">469</span>]]   <span class="hljs-comment"># 1859</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(costs))</span><br><span class="line"></span><br><span class="line">items=[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I]</span><br><span class="line">city_a = pulp.LpVariable.dicts(<span class="hljs-string">'left'</span>, items, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, pulp.LpBinary)</span><br><span class="line">city_b = pulp.LpVariable.dicts(<span class="hljs-string">'right'</span>, items, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, pulp.LpBinary)</span><br><span class="line"></span><br><span class="line">m = pulp.LpProblem(<span class="hljs-string">"Two Cities"</span>, pulp.LpMinimize)</span><br><span class="line"></span><br><span class="line">m += pulp.lpSum((costs[i][<span class="hljs-number">0</span>] * city_a[i] + costs[i][<span class="hljs-number">1</span>] * city_b[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Constraints</span></span><br><span class="line"><span class="hljs-comment"># Each person must be assigned to at exact one city</span></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I:</span><br><span class="line">    m += pulp.lpSum([city_a[i] + city_b[i]]) == <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment"># create a binary variable to state that a table setting is used</span></span><br><span class="line">m += pulp.lpSum(city_a[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I) == (<span class="hljs-built_in">len</span>(I) // <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line">m.solve()</span><br><span class="line"></span><br><span class="line">total = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I:</span><br><span class="line">    <span class="hljs-keyword">if</span> city_a[i].value() == <span class="hljs-number">1.0</span>:</span><br><span class="line">        total += costs[i][<span class="hljs-number">0</span>]</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        total += costs[i][<span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Total cost {}"</span>.<span class="hljs-built_in">format</span>(total))</span><br></pre></td></tr></tbody></table></figure>
<p>代码地址为</p>
<p>https://github.com/MyEncyclopedia/leetcode/blob/master/1029_Two_City_Scheduling/1029_pulp.py</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/categories/Tech-Blog/page/2/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="/categories/Tech-Blog/page/4/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/categories/Tech-Blog/">1</a></li>
        
        <li><a class="pagination-link" href="/categories/Tech-Blog/page/2/">2</a></li>
        
        <li><a class="pagination-link is-current" href="/categories/Tech-Blog/page/3/">3</a></li>
        
        <li><a class="pagination-link" href="/categories/Tech-Blog/page/4/">4</a></li>
        
        <li><a class="pagination-link" href="/categories/Tech-Blog/page/5/">5</a></li>
        
        <li><a class="pagination-link" href="/categories/Tech-Blog/page/6/">6</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2023 MyEncyclopedia&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true" aria-controls="dropdown-menu7">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>简体中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu">
            <div class="dropdown-content">
            
                <a href="/categories/Tech-Blog/page/3/" class="dropdown-item">
                    简体中文
                </a>
            
                <a href="/en/categories/Tech-Blog/page/3/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<style>
 .katex-display {
    overflow-x: auto;
    overflow-y: hidden;
    height: 100%;
  }
</style>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        // ...options...
    });
});
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>