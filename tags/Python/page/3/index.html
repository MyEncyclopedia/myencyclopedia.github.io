<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>标签: Python - MyEncyclopedia</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">


<link href="/en/tags/Python/page/3/" rel="alternate" hreflang="en" />
    


<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="MyEncyclopedia">
<meta property="og:url" content="https://myencyclopedia.github.io/tags/Python/page/3/">
<meta property="og:site_name" content="MyEncyclopedia">
<meta property="og:locale">
<meta property="article:author" content="MyEncyclopedia">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://myencyclopedia.github.io">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#Python</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/leetcode-679-24-game/" itemprop="url">Leetcode 679 24 Game 的 Python 函数式实现</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-09-09T18:45:01.000Z" itemprop="datePublished">9月 10 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            17 分钟 读完 (约 2542 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><h2 id="leetcode-679-24-game-hard">Leetcode 679 24 Game (Hard)</h2>
<p>先来介绍一下24点游戏题目，大家一定都玩过，就是给定4个牌面数字，用加减乘除计算24点。</p>
<p>本篇会用两种偏函数式的 Python 3解法来AC 24 Game。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/24-game/">Leetcode 679 24 Game
(Hard)</a> &gt; You have 4 cards each containing a number from 1 to 9.
You need to judge whether they could operated through *, /, +, -, (, )
to get the value of 24.</p>
<blockquote>
<p>Example 1:</p>
<p>Input: [4, 1, 8, 7]</p>
<p>Output: True</p>
<p>Explanation: (8-4) * (7-1) = 24</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>Input: [1, 2, 1, 2]</p>
<p>Output: False</p>
</blockquote>
<h2 id="itertools.permutations">itertools.permutations</h2>
<p>先来介绍一下Python itertools.permutations 的用法，正好用Leetcode
中的Permutation问题来示例。Permutations 的输入可以是List，返回是
generator 实例，用于生成所有排列。简而言之，python 的 generator
可以和List一样，用 for 语句来全部遍历产生的值。和List不同的是，generator
的所有值并不必须全部初始化，一般按需产生从而大量减少内存占用。下面在介绍
yield 时我们会看到如何合理构造 generator。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Leetcode 46
Permutations (Medium)</a> &gt; Given a collection of distinct integers,
return all possible permutations.</p>
<blockquote>
<p>Example:</p>
<p>Input: [1,2,3]</p>
<p>Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</p>
</blockquote>
<p>用 permutations 很直白，代码只有一行。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 36 ms, faster than 91.78% of Python3 online submissions for Permutations.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 13.9 MB, less than 66.52% of Python3 online submissions for Permutations.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> permutations(nums)]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="itertools.combinations">itertools.combinations</h2>
<p>有了排列就少不了组合，itertools.combinations
可以产生给定List的k个元素组合 <span class="math inline">\(\binom{n}{k}\)</span>，用一道算法题来举例，同样也是一句语句就可以AC。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">Leetcode 77
Combinations (Medium)</a></p>
<blockquote>
<p>Given two integers n and k, return all possible combinations of k
numbers out of 1 ... n. You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: n = 4, k = 2</p>
<p>Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>Input: n = 1, k = 1</p>
<p>Output: [[1]]</p>
</blockquote>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 84 ms, faster than 95.43% of Python3 online submissions for Combinations.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 15.2 MB, less than 68.98% of Python3 online submissions for Combinations.</span></span><br><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)), k)]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="itertools.product">itertools.product</h2>
<p>当有多维度的对象需要迭代笛卡尔积时，可以用 product(iter1, iter2,
...)来生成generator，等价于多重 for 循环。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lst <span class="hljs-keyword">for</span> lst <span class="hljs-keyword">in</span> product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])]</span><br><span class="line">[(i, s) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p>这两种方式都生成了如下结果 </p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>再举一个Leetcode的例子来实战product generator。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Leetcode
17. Letter Combinations of a Phone Number (Medium)</a></p>
<blockquote>
<p>Given a string containing digits from 2-9 inclusive, return all
possible letter combinations that the number could represent. A mapping
of digit to letters (just like on the telephone buttons) is given below.
Note that 1 does not map to any letters.</p>
<figure>
<img src="/zh/2020/leetcode-679-24-game/lc-17.png">
<figcaption>
</figcaption>
</figure>
</blockquote>
<blockquote>
<p>Example:</p>
<p>Input: "23"</p>
<p>Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</p>
</blockquote>
<p>举例来说，下面的代码当输入 digits 是 '352' 时，iter_dims 的值是
['def', 'jkl', 'abc']，再输入给 product 后会产生 'dja', 'djb', 'djc',
'eja', 共 3 x 3 x 3 = 27个组合的值。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 24 ms, faster than 94.50% of Python3 online submissions for Letter Combinations of a Phone Number.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 13.7 MB, less than 83.64% of Python3 online submissions for Letter Combinations of a Phone Number.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> product</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> digits == <span class="hljs-string">""</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line">        mapping = {<span class="hljs-string">'2'</span>:<span class="hljs-string">'abc'</span>, <span class="hljs-string">'3'</span>:<span class="hljs-string">'def'</span>, <span class="hljs-string">'4'</span>:<span class="hljs-string">'ghi'</span>, <span class="hljs-string">'5'</span>:<span class="hljs-string">'jkl'</span>, <span class="hljs-string">'6'</span>:<span class="hljs-string">'mno'</span>, <span class="hljs-string">'7'</span>:<span class="hljs-string">'pqrs'</span>, <span class="hljs-string">'8'</span>:<span class="hljs-string">'tuv'</span>, <span class="hljs-string">'9'</span>:<span class="hljs-string">'wxyz'</span>}</span><br><span class="line">        iter_dims = [mapping[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> digits]</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        <span class="hljs-keyword">for</span> lst <span class="hljs-keyword">in</span> product(*iter_dims):</span><br><span class="line">            result.append(<span class="hljs-string">''</span>.join(lst))</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<h2 id="yield-示例">yield 示例</h2>
<p>Python具有独特的itertools
generator，可以花式AC代码，接下来讲解如何进一步构造 generator。Python
定义只要函数中使用了yield关键字，这个函数就是 generator。Generator
在计算机领域的标准名称是
coroutine，即协程，是一种特殊的函数：当返回上层调用时自身能够保存调用栈状态，并在上层函数处理完逻辑后跳入到这个
generator，恢复之前的状态再继续运行下去。Yield语句也举一道经典的Fibonacci
问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">Leetcode
509. Fibonacci Number (Easy)</a></p>
<blockquote>
<p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called
the Fibonacci sequence, such that each number is the sum of the two
preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N)
= F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N).</p>
</blockquote>
<blockquote>
<p>Example 1:</p>
<p>Input: 2</p>
<p>Output: 1</p>
<p>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>Input: 3</p>
<p>Output: 2</p>
<p>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>Input: 4</p>
<p>Output: 3</p>
<p>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p>
</blockquote>
<p>Fibonacci 的一般标准解法是循环迭代方式，可以以O(n)时间复杂度和O(1)
空间复杂度来AC。下面的 yield 版本中，我们构造了fib_next
generator，它保存了最后两个值作为内部迭代状态，外部每调用一次可以得到下一个fib(n)，如此外部只需不断调用直到满足题目给定次数。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 28 ms, faster than 85.56% of Python3 online submissions for Fibonacci Number.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 13.8 MB, less than 58.41% of Python3 online submissions for Fibonacci Number.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, N: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> N &lt;= <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> N</span><br><span class="line">        i = <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">for</span> fib <span class="hljs-keyword">in</span> self.fib_next():</span><br><span class="line">            <span class="hljs-keyword">if</span> i == N:</span><br><span class="line">                <span class="hljs-keyword">return</span> fib</span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib_next</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        f_last2, f_last = <span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            f = f_last2 + f_last</span><br><span class="line">            f_last2, f_last = f_last, f</span><br><span class="line">            <span class="hljs-keyword">yield</span> f</span><br></pre></td></tr></tbody></table></figure>
<h2 id="yield-from-示例">yield from 示例</h2>
<p>上述yield用法之后，再来演示 yield from 的用法。Yield from 始于Python
3.3，用于嵌套generator时的控制转移，一种典型的用法是有多个generator嵌套时，外层的outer_generator
用 yield from 这种方式等价代替如下代码。 </p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_generator</span>():</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_generator():</span><br><span class="line">        <span class="hljs-keyword">yield</span> i</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>用一道算法题目来具体示例。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Leetcode
230. Kth Smallest Element in a BST (Medium)</a></p>
<blockquote>
<p>Given a binary search tree, write a function kthSmallest to find the
kth smallest element in it.</p>
</blockquote>
<blockquote>
<p>Example 1: Input: root = [3,1,4,null,2], k = 1 </p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></tbody></table></figure> Output:
1<p></p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>Input: root = [5,3,6,2,4,null,null,1], k = 3 </p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         5</span><br><span class="line">        / \</span><br><span class="line">       3   6</span><br><span class="line">     /  \</span><br><span class="line">    2    4</span><br><span class="line">  /</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure> Output:
3<p></p>
</blockquote>
<p>直觉思路上，我们只要从小到大有序遍历每个节点直至第k个。因为给定的树是Binary
Search
Tree，有序遍历意味着以左子树、节点本身和右子树的访问顺序递归下去就行。由于ordered_iter是generator，递归调用自己的过程就是嵌套使用generator的过程。下面是yield版本。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 48 ms, faster than 90.31% of Python3 online submissions for Kth Smallest Element in a BST.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 17.9 MB, less than 14.91% of Python3 online submissions for Kth Smallest Element in a BST.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kthSmallest</span>(<span class="hljs-params">self, root: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ordered_iter</span>(<span class="hljs-params">node</span>):</span></span><br><span class="line">            <span class="hljs-keyword">if</span> node:</span><br><span class="line">                <span class="hljs-keyword">for</span> sub_node <span class="hljs-keyword">in</span> ordered_iter(node.left):</span><br><span class="line">                    <span class="hljs-keyword">yield</span> sub_node</span><br><span class="line">                <span class="hljs-keyword">yield</span> node</span><br><span class="line">                <span class="hljs-keyword">for</span> sub_node <span class="hljs-keyword">in</span> ordered_iter(node.right):</span><br><span class="line">                    <span class="hljs-keyword">yield</span> sub_node</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> ordered_iter(root):</span><br><span class="line">            k -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> node.val</span><br></pre></td></tr></tbody></table></figure>
<p>等价于如下 yield from 版本：</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 56 ms, faster than 63.74% of Python3 online submissions for Kth Smallest Element in a BST.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 17.7 MB, less than 73.33% of Python3 online submissions for Kth Smallest Element in a BST.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kthSmallest</span>(<span class="hljs-params">self, root: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ordered_iter</span>(<span class="hljs-params">node</span>):</span></span><br><span class="line">            <span class="hljs-keyword">if</span> node:</span><br><span class="line">                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> ordered_iter(node.left)</span><br><span class="line">                <span class="hljs-keyword">yield</span> node</span><br><span class="line">                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> ordered_iter(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> ordered_iter(root):</span><br><span class="line">            k -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> node.val</span><br></pre></td></tr></tbody></table></figure>
<h2 id="点问题之函数式枚举解法">24 点问题之函数式枚举解法</h2>
<p>看明白了itertools.permuations，combinations，product，yield以及yield
from，我们回到本篇最初的24点游戏问题。</p>
<p>24点游戏的本质是枚举出所有可能运算，如果有一种方式得到24返回True，否则返回Flase。进一步思考所有可能的运算，包括下面三个维度：</p>
<ol type="1">
<li><p>4个数字的所有排列，比如给定 [1, 2, 3, 4]，可以用permutations([1,
2, 3, 4]) 生成这个维度的所有可能</p></li>
<li><p>三个位置的操作符号的全部可能，可以用 product([+, -, *, /],
repeat=3) 生成，具体迭代结果为：[+, +, +]，[+, +, -]，...</p></li>
<li><p>给定了前面两个维度后，还有一个比较不容易察觉但必要的维度：运算优先级。比如在给定数字顺序
[1, 2, 3, 4]和符号顺序 [+, *, -]之后可能的四种操作树</p></li>
</ol>
<figure>
<img src="/zh/2020/leetcode-679-24-game/iter_trees.png">
<figcaption>
四种运算优先级
</figcaption>
</figure>
<p>能否算得24点只需要枚举这三个维度笛卡尔积的运算结果</p>
<p>(维度1：数字组合) x (维度2：符号组合) x (维度3：优先级组合)</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 112 ms, faster than 57.59% of Python3 online submissions for 24 Game.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 13.7 MB, less than 85.60% of Python3 online submissions for 24 Game.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations, product</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iter_trees</span>(<span class="hljs-params">self, op1, op2, op3, a, b, c, d</span>):</span></span><br><span class="line">        <span class="hljs-keyword">yield</span> op1(op2(a, b), op3(c, d))</span><br><span class="line">        <span class="hljs-keyword">yield</span> op1(a, op2(op3(b, c), d))</span><br><span class="line">        <span class="hljs-keyword">yield</span> op1(a, op2(b, op3(c, d)))</span><br><span class="line">        <span class="hljs-keyword">yield</span> op1(op2(a, op3(b, c)), d)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgePoint24</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        mul = <span class="hljs-keyword">lambda</span> x, y: x * y</span><br><span class="line">        plus = <span class="hljs-keyword">lambda</span> x, y: x + y</span><br><span class="line">        div = <span class="hljs-keyword">lambda</span> x, y: x / y <span class="hljs-keyword">if</span> y != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> math.inf</span><br><span class="line">        minus = <span class="hljs-keyword">lambda</span> x, y: x - y</span><br><span class="line"></span><br><span class="line">        op_lst = [plus, minus, mul, div]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> ops <span class="hljs-keyword">in</span> product(op_lst, repeat=<span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> permutations(nums):</span><br><span class="line">                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> self.iter_trees(ops[<span class="hljs-number">0</span>], ops[<span class="hljs-number">1</span>], ops[<span class="hljs-number">2</span>], val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>], val[<span class="hljs-number">2</span>], val[<span class="hljs-number">3</span>]):</span><br><span class="line">                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(v - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">0.0001</span>:</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="点问题之-dfs-yield-from-解法">24 点问题之 DFS yield from
解法</h2>
<p>一种常规的思路是，在四个数组成的集合中先选出任意两个数，枚举所有可能的计算，再将剩余的三个数组成的集合递归调用下去，直到叶子节点只剩一个数，如下图所示。</p>
<figure>
<img src="/zh/2020/leetcode-679-24-game/dfs.png">
<figcaption>
DFS 调用示例
</figcaption>
</figure>
<p>下面的代码是这种思路的 itertools + yield from
解法，recurse方法是generator，会自我递归调用。当只剩下两个数时，用 yield
返回两个数的所有可能运算得出的值，其他非叶子情况下则自我调用使用yield
from，例如4个数任选2个先计算再合成3个数的情况。这种情况下，比较麻烦的是由于4个数可能有相同值，若用
combinations(lst, 2)
先任选两个数，后续要生成剩余两个数加上第三个计算的数的集合代码会繁琐。因此，我们改成任选4个数index中的两个，剩余的indices
可以通过集合操作来完成。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Runtime: 116 ms, faster than 56.23% of Python3 online submissions for 24 Game.</span></span><br><span class="line"><span class="hljs-comment"># Memory Usage: 13.9 MB, less than 44.89% of Python3 online submissions for 24 Game.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations, product, permutations</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgePoint24</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        mul = <span class="hljs-keyword">lambda</span> x, y: x * y</span><br><span class="line">        plus = <span class="hljs-keyword">lambda</span> x, y: x + y</span><br><span class="line">        div = <span class="hljs-keyword">lambda</span> x, y: x / y <span class="hljs-keyword">if</span> y != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> math.inf</span><br><span class="line">        minus = <span class="hljs-keyword">lambda</span> x, y: x - y</span><br><span class="line"></span><br><span class="line">        op_lst = [plus, minus, mul, div]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">lst: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):</span></span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst) == <span class="hljs-number">2</span>:</span><br><span class="line">                <span class="hljs-keyword">for</span> op, values <span class="hljs-keyword">in</span> product(op_lst, permutations(lst)):</span><br><span class="line">                    <span class="hljs-keyword">yield</span> op(values[<span class="hljs-number">0</span>], values[<span class="hljs-number">1</span>])</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># choose 2 indices from lst of length n</span></span><br><span class="line">                <span class="hljs-keyword">for</span> choosen_idx_lst <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lst))), <span class="hljs-number">2</span>):</span><br><span class="line">                    <span class="hljs-comment"># remaining indices not choosen (of length n-2)</span></span><br><span class="line">                    idx_remaining_set = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lst)))) - <span class="hljs-built_in">set</span>(choosen_idx_lst)</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment"># remaining values not choosen (of length n-2)</span></span><br><span class="line">                    value_remaining_lst = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: lst[x], idx_remaining_set))</span><br><span class="line">                    <span class="hljs-keyword">for</span> op, idx_lst <span class="hljs-keyword">in</span> product(op_lst, permutations(choosen_idx_lst)):</span><br><span class="line">                        <span class="hljs-comment"># 2 choosen values are lst[idx_lst[0]], lst[idx_lst[1]</span></span><br><span class="line">                        value_remaining_lst.append(op(lst[idx_lst[<span class="hljs-number">0</span>]], lst[idx_lst[<span class="hljs-number">1</span>]]))</span><br><span class="line">                        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> recurse(value_remaining_lst)</span><br><span class="line">                        value_remaining_lst = value_remaining_lst[:-<span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> recurse(nums):</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(v - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">0.0001</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/rl-sutton-gridworld-1/" itemprop="url">通过代码学Sutton强化学习1：Grid World OpenAI环境和策略评价算法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-09-03T18:45:01.000Z" itemprop="datePublished">9月 4 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2827 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>经典教材Reinforcement Learning: An Introduction
第二版由强化领域权威Richard S. Sutton 和 Andrew G. Barto
完成编写，内容深入浅出，非常适合初学者。在本篇中，引入Grid
World示例，结合强化学习核心概念，并用python代码实现OpenAI
Gym的模拟环境，进一步实现策略评价算法。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/rl_sutton.png">
<figcaption>
</figcaption>
</figure>
<h2 id="grid-world-问题">Grid World 问题</h2>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/grid_world.png">
<figcaption>
</figcaption>
</figure>
<p>第四章例子4.1提出了一个简单的离散空间状态问题：Grid
World，其大致意思是在4x4的网格世界中有14个格子是非终点状态，在这些非终点状态的格子中可以往上下左右四个方向走，直至走到两个终点状态格子，则游戏结束。每走一步，Agent收获reward
-1，表示Agent希望在Grid World中尽早出去。另外，Agent在Grid
World边缘时，无法继续往外只能呆在原地，reward也是-1。</p>
<h2 id="finite-mdp-模型">Finite MDP 模型</h2>
先来回顾一下强化学习的建模基础：有限马尔可夫决策过程（Finite Markov
Decision Process, Finite
MDP）。如下图，强化学习模型将世界抽象成两个实体，强化学习解决目标的主体Agent和其他外部环境。它们之间的交互过程遵从有限马尔可夫决策过程：若Agent在t时间步骤时处于状态
<span class="math inline">\(S_t\)</span>，采取动作 <span class="math inline">\(A_t\)</span>，然后环境根据自身机制，产生Reward
<span class="math inline">\(R_{t+1}\)</span> 并将Agent状态变为 <span class="math inline">\(S_{t+1}\)</span>。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/env_agent.png">
<figcaption>
</figcaption>
</figure>
<p>环境自身机制又称为dynamics，工程上可以看成一个输入(S, A)，输出(S,
R)的方法。由于MDP包含随机过程，某个输入并不能确定唯一输出，而会根据概率分布输出不同的(S,
R)。Finite MDP简化了时间对于模型的影响，因为(S, R)只和(S,
A)有关，不和时间t有关。另外，有限指的是S，A，R的状态数量是有限的。</p>
<p>数学上dynamics可以如下表示</p>
<div>
<p><span class="math display">\[
p\left(s^{\prime}, r \mid s, a\right) \doteq
\operatorname{Pr}\left\{S_{t}=s^{\prime}, R_{t}=r \mid S_{t-1}=s,
A_{t-1}=a\right\}
\]</span></p>
</div>
<p>即是四元组作为输入的概率函数 <span class="math inline">\(p: S \times
R \times S \times A \rightarrow [0, 1]\)</span>。</p>
<p>满足 <span class="math display">\[
\sum_{s^{\prime} \in \mathcal{S}} \sum_{r \in \mathcal{R}}
p\left(s^{\prime}, r \mid s, a\right)=1, \text { for all } s \in
\mathcal{S}, a \in \mathcal{A}(s)
\]</span></p>
以Grid
World为例，当Agent处于编号1的网格时，可以往四个方向走，往任意方向走都只产生一种
S,
R，因为这个简单的游戏是确定性的，不存在某一动作导致stochastic状态。例如，在1号网格往左就到了终点网格（编号0），得到Reward
-1这个规则可以如下表示 <span class="math display">\[
p\left(s^{\prime}=0, r=-1 \mid s=1, a=\text{L}\right) = 1
\]</span> 因此，状态s=1的所有dynamics概率映射为
<div>
<p><span class="math display">\[
\begin{aligned}
p\left(s^{\prime}=0, r=-1 \mid s=1, a=\text{L}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=2, r=-1 \mid s=1, a=\text{R}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=1, r=-1 \mid s=1, a=\text{U}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=5, r=-1 \mid s=1, a=\text{D}\right) &amp;=&amp; 1
\end{aligned}
\]</span></p>
</div>
<h2 id="强化学习的目的">强化学习的目的</h2>
<p>在给定了问题以及定义了强化学习的模型之后，强化学习的目的当然是通过学习让Agent能够学到最佳策略<span class="math inline">\(\pi_{*}\)</span>，也就是在某个状态下的行动分布，记成
<span class="math inline">\(\pi(a|s)\)</span>。对应在数值上的优化目标是Agent在一系列过程中采取某种策略的reward总和的期望（Expected
Return）。下面公式定义了t步往后的reward总和，其中 <span class="math inline">\(\gamma\)</span> 为discount
factor，用于权衡短期和长期reward对于当前Agent的效用影响。等式最后一步的意义是t步后的reward总和等价于t步所获的立即reward
<span class="math inline">\(R_{t+1}\)</span>，加上t+1步后的reward总和
<span class="math inline">\(\gamma G_{t+1}\)</span>。</p>
<div>
<p><span class="math display">\[
\begin{aligned}
G_{t} &amp; \doteq R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\gamma^{3}
R_{t+4}+\cdots \\
&amp;=R_{t+1}+\gamma\left(R_{t+2}+\gamma R_{t+3}+\gamma^{2}
R_{t+4}+\cdots\right) \\
&amp;=R_{t+1}+\gamma G_{t+1}
\end{aligned}
\]</span></p>
</div>
<p>有了reward总和的定义，评价Agent策略 <span class="math inline">\(\pi\)</span> 就可以定义成Agent在状态 s
时采用此策略的Expected Return。</p>
<p><span class="math display">\[
v_{\pi}(s) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]
\]</span></p>
<p>下面公式推导了 <span class="math inline">\(v_{\pi}(s)\)</span>
数值上和相关状态 <span class="math inline">\(s{\prime}\)</span>
的关系：</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{\pi}(s) &amp;\doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]
\\
&amp;=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}
\mid S_{t}=s\right]\\
&amp;=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma G_{t+1} \mid S_{t}=s\right]
\\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}} \sum_{r}
p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
\mathbb{E}_{\pi}\left[G_{t+1} \mid S_{t+1}=s^{\prime}\right]\right] \\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r
\mid s, a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right]
\quad \text { for all } s \in \mathcal{S}
\end{aligned}
\]</span></p>
</div>
<p>注意到如果将 <span class="math inline">\(v_{\pi}(s)\)</span>
看成未知数，上式即形成 <span class="math inline">\(\mid \mathcal{S}
\mid\)</span> 个未知变量的方程组，可以在数值上解得各个 <span class="math inline">\(v_{\pi}(s)\)</span>。</p>
书中用Backup Diagram来表示递推关系，下图是<span class="math inline">\(v_{\pi}(s)\)</span>的backup diagram。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_v_pi.png">
<figcaption>
</figcaption>
</figure>
<p>尽管v值可以来衡量策略，但由于<span class="math inline">\(v_{\pi}(s)\)</span> 是Agent在策略<span class="math inline">\(\pi(a|s)\)</span>的Expected
Return，将不同的action拆出来单独计算Expected
Return，这样的做法有时更为直接，这就是著名的Q Learning中的q
值，记成<span class="math inline">\(q_{\pi}(s, a)\)</span> 。</p>
<p><span class="math display">\[
q_{\pi}(s, a) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s,
A_{t}=a\right]
\]</span></p>
<p>下面是 $q_{}(s, a) $ 的递推 backup diagram。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_q_pi.png">
<figcaption>
</figcaption>
</figure>
<h2 id="bellman-最佳原则">Bellman 最佳原则</h2>
<p>对于所有状态集合<span class="math inline">\(\mathcal{S}\)</span>，策略<span class="math inline">\({\pi}\)</span>的评价指标 <span class="math inline">\(v_{\pi}(s)\)</span>
是一个向量，本质上是无法相互比较的。但由于存在Bellman
最佳原则（Bellman's principle of
optimality）：在有限状态情况下，一定存在一个或者多个最好的策略 <span class="math inline">\({\pi}_{*}\)</span>，它在所有状态下的v值都是最好的，即
<span class="math inline">\(v_{\pi_{*}}(s) \ge v_{\pi^{\prime}}(s) \text
{ for all } s \in \mathcal{S}\)</span>。</p>
<p>因此，最佳v值定义为最佳策略 <span class="math inline">\({\pi}_{*}\)</span> 对应的 v 值</p>
<p><span class="math display">\[
v_{*}(s) \doteq \max_{\pi} v_{\pi}(s)
\]</span></p>
<p>同理，也存在最佳q值，记为 <span class="math display">\[
\begin{aligned}
q_{*}(s, a) &amp;\doteq \max_{\pi} q_{\pi}(s,a)
\end{aligned}
\]</span></p>
<p>将 <span class="math inline">\(v_{*}(s)\)</span> 改写成递推形式，称为
Bellman Optimality Equation，推导如下</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{*}(s) &amp;=\max _{a \in \mathcal{A}(s)} q_{\pi_{*}}(s, a) \\
&amp;=\max _{a} \mathbb{E}_{\pi_{*}}\left[G_{t} \mid S_{t}=s,
A_{t}=a\right] \\
&amp;=\max _{a} \mathbb{E}_{\pi_{*}}\left[R_{t+1}+\gamma G_{t+1} \mid
S_{t}=s, A_{t}=a\right] \\
&amp;=\max _{a} \mathbb{E}\left[R_{t+1}+\gamma v_{*}\left(S_{t+1}\right)
\mid S_{t}=s, A_{t}=a\right] \\
&amp;=\max _{a} \sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma v_{*}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>直觉上可以理解为状态 s
对应的最佳v值是只采取此状态下的最佳动作后的Expected Return。</p>
<p>最佳q值递归形式的意义为最佳策略下状态s时采取行动 a 的Expected
Return，等于所有可能后续状态 s' 下采取最优行动的Expected
Return的均值。推导如下：</p>
<div>
<p><span class="math display">\[
\begin{aligned}
q_{*}(s, a) &amp;=\mathbb{E}\left[R_{t+1}+\gamma \max _{a^{\prime}}
q_{*}\left(S_{t+1}, a^{\prime}\right) \mid S_{t}=s, A_{t}=a\right] \\
&amp;=\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma \max _{a^{\prime}} q_{*}\left(s^{\prime},
a^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<span class="math inline">\(v_{*}(s), q_{*}(s, a)\)</span> 的backup
diagram 如下图
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_optimal.png">
<figcaption>
</figcaption>
</figure>
<h2 id="grid-world-最佳策略和v值">Grid World 最佳策略和V值</h2>
<p>Grid World 的最佳策略如下：尽可能快的走出去</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/optimal_policy.png">
<figcaption>
Grid World最佳策略
</figcaption>
</figure>
<p>上面的2D图中不同颜色表示不同V值，终点格子的红色表示0，隔着一步的黄色为-1，隔两步的绿色为-2，最远的紫色为-3。下面是立体图示。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/value_3d.png">
<figcaption>
Grid World最佳策略V值
</figcaption>
</figure>
<h2 id="grid-world-openai-gym-环境">Grid World OpenAI Gym 环境</h2>
<p>下面是OpenAI Gym框架下Grid
World环境的代码实现。本质是在GridWorldEnv构造函数中构建MDP，类型定义如下</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MDP = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Prob, State, Reward, <span class="hljs-built_in">bool</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># P[state][action] = [</span></span><br><span class="line"><span class="hljs-comment">#    (prob1, next_state1, reward1, is_done),</span></span><br><span class="line"><span class="hljs-comment">#    (prob2, next_state2, reward2, is_done), ...]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span>(<span class="hljs-params">Enum</span>):</span></span><br><span class="line">    UP = <span class="hljs-number">0</span></span><br><span class="line">    DOWN = <span class="hljs-number">1</span></span><br><span class="line">    LEFT = <span class="hljs-number">2</span></span><br><span class="line">    RIGHT = <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">State = <span class="hljs-built_in">int</span></span><br><span class="line">Reward = <span class="hljs-built_in">float</span></span><br><span class="line">Prob = <span class="hljs-built_in">float</span></span><br><span class="line">Policy = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, Prob]]</span><br><span class="line">Value = <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]</span><br><span class="line">StateSet = <span class="hljs-type">Set</span>[<span class="hljs-built_in">int</span>]</span><br><span class="line">NonTerminalStateSet = <span class="hljs-type">Set</span>[<span class="hljs-built_in">int</span>]</span><br><span class="line">MDP = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Prob, State, Reward, <span class="hljs-built_in">bool</span>]]]]</span><br><span class="line"><span class="hljs-comment"># P[s][a] = [(prob, next_state, reward, is_done), ...]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GridWorldEnv</span>(<span class="hljs-params">discrete.DiscreteEnv</span>):</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Grid World environment described in Sutton and Barto Reinforcement Learning 2nd, chapter 4.</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, shape=[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]</span>):</span></span><br><span class="line">        self.shape = shape</span><br><span class="line">        nS = np.prod(shape)</span><br><span class="line">        nA = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(Action))</span><br><span class="line">        MAX_R = shape[<span class="hljs-number">0</span>]</span><br><span class="line">        MAX_C = shape[<span class="hljs-number">1</span>]</span><br><span class="line">        self.grid = np.arange(nS).reshape(shape)</span><br><span class="line">        isd = np.ones(nS) / nS</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># P[s][a] = [(prob, next_state, reward, is_done), ...]</span></span><br><span class="line">        P: MDP = {}</span><br><span class="line">        action_delta = {Action.UP: (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.DOWN: (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.LEFT: (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), Action.RIGHT: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)}</span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, MAX_R * MAX_C):</span><br><span class="line">            P[s] = {a.value : [] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action)}</span><br><span class="line">            is_terminal = self.is_terminal(s)</span><br><span class="line">            <span class="hljs-keyword">if</span> is_terminal:</span><br><span class="line">                <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action):</span><br><span class="line">                    P[s][a.value] = [(<span class="hljs-number">1.0</span>, s, <span class="hljs-number">0</span>, <span class="hljs-literal">True</span>)]</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                r = s // MAX_R</span><br><span class="line">                c = s % MAX_R</span><br><span class="line">                <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action):</span><br><span class="line">                    neighbor_r = <span class="hljs-built_in">min</span>(MAX_R-<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r + action_delta[a][<span class="hljs-number">0</span>]))</span><br><span class="line">                    neighbor_c = <span class="hljs-built_in">min</span>(MAX_C-<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, c + action_delta[a][<span class="hljs-number">1</span>]))</span><br><span class="line">                    s_ = neighbor_r * MAX_R + neighbor_c</span><br><span class="line">                    P[s][a.value] = [(<span class="hljs-number">1.0</span>, s_, -<span class="hljs-number">1</span>, <span class="hljs-literal">False</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">super</span>(GridWorldEnv, self).__init__(nS, nA, P, isd)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="策略评估policy-evaluation">策略评估（Policy Evaluation）</h2>
<p>策略评估需要解决在给定环境dynamics和Agent策略 <span class="math inline">\(\pi\)</span>下，计算策略的v值 <span class="math inline">\(v_{\pi}\)</span>。由于所有数量关系都已知，可以通过解方程组的方式求得，但通常会通过数值迭代的方式来计算，即通过一系列
<span class="math inline">\(v_{0}, v_{1}, ..., v_{k}\)</span> 收敛至
<span class="math inline">\(v_{\pi}\)</span>。如下迭代方式已经得到证明，当
<span class="math inline">\(k \rightarrow \infty\)</span> 一定收敛至
<span class="math inline">\(v_{\pi}\)</span>。</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{k+1}(s) &amp; \doteq \mathbb{E}_{\pi}\left[R_{t+1}+\gamma
v_{k}\left(S_{t+1}\right) \mid S_{t}=s\right] \\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r
\mid s, a\right)\left[r+\gamma v_{k}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>书中具体伪代码如下</p>
<div>
<p><span class="math display">\[
\begin{align*}
&amp;\textbf{Iterative Policy Evaluation, for estimating } V\approx
v_{\pi} \\
&amp; \text{Input } {\pi}, \text{the policy to be evaluated} \\
&amp; \text{Algorithm parameter: a small threshold } \theta &gt; 0
\text{ determining accuracy of estimation} \\
&amp; \text{Initialize } V(s), \text{for all } s \in \mathcal{S}^{+}
\text{, arbitrarily except that } V (terminal) = 0\\
&amp; \\
&amp;1: \text{Loop:}\\
&amp;2: \quad \quad \Delta \leftarrow 0\\
&amp;3: \quad \quad \text{Loop for each } s \in \mathcal{S}:\\
&amp;4: \quad \quad \quad \quad v \leftarrow V(s) \\
&amp;5: \quad \quad \quad \quad V(s) \leftarrow \sum_{a} \pi(a \mid s)
\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
V\left(s^{\prime}\right)\right] \\
&amp;6: \quad \quad \quad \quad \Delta \leftarrow \max(\Delta, |v-V(s)|)
\\
&amp;7: \text{until } \Delta &lt; \theta
\end{align*}
\]</span></p>
</div>
<p>下面是python
代码实现，注意这里单run迭代时，新的v值直接覆盖数组里的旧v值，这种做法在书中被证明不仅有效，甚至更为高效。这种做法称为原地（in
place）更新。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">policy_evaluate</span>(<span class="hljs-params">policy: Policy, env: GridWorldEnv, gamma=<span class="hljs-number">1.0</span>, theta=<span class="hljs-number">0.0001</span></span>):</span></span><br><span class="line">    V = np.zeros(env.nS)</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        delta = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">            v = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-keyword">for</span> a, action_prob <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(policy[s]):</span><br><span class="line">                <span class="hljs-keyword">for</span> prob, next_state, reward, done <span class="hljs-keyword">in</span> env.P[s][a]:</span><br><span class="line">                    v += action_prob * prob * (reward + gamma * V[next_state])</span><br><span class="line">            delta = <span class="hljs-built_in">max</span>(delta, np.<span class="hljs-built_in">abs</span>(v - V[s]))</span><br><span class="line">            V[s] = v</span><br><span class="line">        <span class="hljs-keyword">if</span> delta &lt; theta:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">    <span class="hljs-keyword">return</span> np.array(V)</span><br></pre></td></tr></tbody></table></figure>
<p>输入策略为随机选择方向，运行上面的policy_evaluate最终多轮收敛后的V值输出为</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[  <span class="hljs-number">0.</span>         -<span class="hljs-number">13.99931242</span> -<span class="hljs-number">19.99901152</span> -<span class="hljs-number">21.99891199</span>]</span><br><span class="line"> [-<span class="hljs-number">13.99931242</span> -<span class="hljs-number">17.99915625</span> -<span class="hljs-number">19.99908389</span> -<span class="hljs-number">19.99909436</span>]</span><br><span class="line"> [-<span class="hljs-number">19.99901152</span> -<span class="hljs-number">19.99908389</span> -<span class="hljs-number">17.99922697</span> -<span class="hljs-number">13.99942284</span>]</span><br><span class="line"> [-<span class="hljs-number">21.99891199</span> -<span class="hljs-number">19.99909436</span> -<span class="hljs-number">13.99942284</span>   <span class="hljs-number">0.</span>        ]]</span><br></pre></td></tr></tbody></table></figure>
在3D V值图中可以发现，由于是随机选择方向的策略，
Agent在每个格子的V值绝对数值要比最佳V值大，意味着随机策略下Agent在Grid
World会得到更多的负reward。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/random_policy_v.png">
<figcaption>
Grid World随机策略V值
</figcaption>
</figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/tsp-1-dp-alg/" itemprop="url">TSP问题从DP算法到深度学习1： 递归DP方法 AC AIZU TSP问题</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-08-29T18:45:01.000Z" itemprop="datePublished">8月 30 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 读完 (约 2013 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">旅行商问题（TSP）</a>是计算机算法中经典的NP
hard 问题。 在本系列文章中，我们将首先使用动态规划 AC
aizu中的TSP问题，然后再利用深度学习求大规模下的近似解。深度学习应用解决问题时先以PyTorch实现监督学习算法
Pointer Network，进而结合强化学习来无监督学习，提高数据使用效率。
本系列完整列表如下：</p>
<ul>
<li><p><strong><a href="/zh/2020/tsp-1-dp-alg/!--swig￼6--">第一篇: 递归DP方法 AC AIZU
TSP问题</a></strong></p></li>
<li><p>第二篇: 二维空间TSP数据集及其DP解法</p></li>
<li><p>第三篇: 深度学习 Pointer Networks 的 Pytorch实现</p></li>
<li><p>第四篇: 搜寻最有可能路径：Viterbi算法和其他</p></li>
<li><p>第五篇: 深度强化学习无监督算法的 Pytorch实现</p></li>
</ul>
<h2 id="tsp-问题回顾">TSP 问题回顾</h2>
<p>TSP可以用图模型来表达，无论有向图或无向图，无论全连通图或者部分连通的图都可以作为TSP问题。
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Wikipedia
TSP</a>
中举了一个无向全连通的TSP例子。如下图所示，四个顶点A，B，C，D构成无向全连通图。TSP问题要求在所有遍历所有点后返回初始点的回路中找到最短的回路。例如，<span class="math inline">\(A \rightarrow B \rightarrow C \rightarrow D
\rightarrow A\)</span> 和 <span class="math inline">\(A \rightarrow C
\rightarrow B \rightarrow D \rightarrow A\)</span>
都是有效的回路，但是TSP需要返回这些回路中的最短回路（注意，最短回路可能会有多条）。</p>
<figure>
<img src="/zh/2020/tsp-1-dp-alg/wiki_k4.png">
<figcaption>
Wikipedia 4个顶点组成的图
</figcaption>
</figure>
<p>无论是哪种类型的图，我们都能用邻接矩阵表示出一个图。上面的Wikipedia中的图可以用下面的矩阵来描述。</p>
<p><span class="math display">\[
\begin{matrix}
&amp; \begin{matrix}A&amp;B&amp;C&amp;D\end{matrix} \\\\
\begin{matrix}A\\\\B\\\\C\\\\D\end{matrix} &amp;
  \begin{bmatrix}-&amp;20&amp;42&amp;35\\\\20&amp;-&amp;30&amp;34\\\\42&amp;30&amp;-&amp;12\\\\35&amp;34&amp;12&amp;-\end{bmatrix}\\\\
\end{matrix}
\]</span></p>
<p>当然，大多数情况下，TSP问题会被限定在欧氏空间，即二维地图中的全连通无向图。因为，如果将顶点表示一个地理位置，一般来说它可以和其他所有顶点连通，回来的距离相同，由此构成无向图。</p>
<p><img src="/zh/2020/tsp-1-dp-alg/5-simplex_graph.svg" title="全连通无向图例子"></p>
<h2 id="aizu-tsp-问题">AIZU TSP 问题</h2>
<p><a target="_blank" rel="noopener" href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A">AIZU在线题库</a>
有一道有向不完全连通图的TSP问题。给定V个顶点和E条边，输出最小回路值。例如，题目里的例子如下所示，由4个顶点和6条单向边构成。</p>
<p><img src="/zh/2020/tsp-1-dp-alg/vertex4-problem.svg" title="AIZU TSP 题目例子"></p>
<p>这个示例的答案是16，对应的回路是 <span class="math inline">\(0\rightarrow1\rightarrow3\rightarrow2\rightarrow0\)</span>，由下图的红色边构成。注意，这个题目可能不存在合法解，原因是无回路存在，此时返回-1，可以合理地理解成无穷大。</p>
<p><img src="/zh/2020/tsp-1-dp-alg/vertex4-sol.svg" title="AIZU TSP 题目答案对应回路"></p>
<h3 id="暴力解法">暴力解法</h3>
<p>一种暴力方法是枚举所有可能的从某一顶点的回路，取其中的最小值即可。下面的
Python 示例如何枚举4个顶点构成的图中从顶点0出发的所有回路。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations</span><br><span class="line">v = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span><br><span class="line">p = permutations(v)</span><br><span class="line"><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(p):</span><br><span class="line">  <span class="hljs-built_in">print</span>([<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(t) + [<span class="hljs-number">0</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>所有从顶点0出发的回路如下：</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>很显然，这种方式的时间复杂度是 O(<span class="math inline">\(n!\)</span>)，无法通过AIZU。</p>
<p><img src="/zh/2020/tsp-1-dp-alg/factorial_paths.svg" title="阶乘级的时间复杂度"></p>
<h3 id="动态规划求解">动态规划求解</h3>
<p>我们可以使用位状态压缩的动态规划来AC这道题。
首先，需要将回路过程中的状态编码成二进制的表示。例如，在四顶点的例子中，如果顶点2和1都被访问过，并且此时停留在顶点1。将已经访问的顶点对应的位置1，那么编码成<strong>0110</strong>，此外，还需要保存当前顶点的位置，因此我们将代表状态的数组扩展成二维，第一维是位状态，第二维是顶点所在位置，即
<span class="math inline">\(dp[bitstate][v]\)</span>。这个例子的状态表示就是
<span class="math inline">\(dp["0110"][1]\)</span>。</p>
<p>状态转移方程如下： <span class="math display">\[
dp[bitstate][v] = \min ( dp[bitstate \cup \{u\}][u] + dist(v,u) \mid u
\notin bitstate )
\]</span> 这种方法对应的时间复杂度是 O(<span class="math inline">\(n^2*2^n\)</span> )，因为总共有 <span class="math inline">\(2^n * n\)</span>
个状态，而每个状态又需要一次遍历。虽然都是指数级复杂度，但是它们的巨大区别由下面可以看出区别。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\(n!\)</span></th>
<th><span class="math inline">\(n^2*2^n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n=8</td>
<td>40320</td>
<td>16384</td>
</tr>
<tr class="even">
<td>n=10</td>
<td>3628800</td>
<td>102400</td>
</tr>
<tr class="odd">
<td>n=12</td>
<td>479001600</td>
<td>589824</td>
</tr>
<tr class="even">
<td>n=14</td>
<td>87178291200</td>
<td>3211264</td>
</tr>
</tbody>
</table>
<p>暂停思考一下为什么状态压缩DP能工作。注意到之前暴力解法中其实是有很多重复计算，下面红圈表示重复的计算节点。</p>
<p><img src="/zh/2020/tsp-1-dp-alg/dp_paths.svg" title="重复的计算节点"></p>
<p>在本篇中，我们将会用Python 3和Java 8 实现自顶向下的DP
缓存版本。这种方式比较符合直觉，因为我们不需要预先考虑计算节点的依赖关系。在Java中我们使用了一个小技巧，dp数组初始化成Integer.MAX_VALUE，如此只需要一条语句就能完成更新dp值。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = Math.min(res, s + g.edges[v][u]);</span><br></pre></td></tr></tbody></table></figure>
<p>当然，为了AC 这道题，我们需要区分出真正无法到达的情况并返回-1。
在Python实现中，也可以使用同样的技巧，但是这次示例一般的实现方法：将dp数组初始化成-1并通过
if-else 来区分不同情况。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INT_INF = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> s != INT_INF <span class="hljs-keyword">and</span> edges[v][u] != INT_INF:</span><br><span class="line">    <span class="hljs-keyword">if</span> ret == INT_INF:</span><br><span class="line">        ret = s + edges[v][u]</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        ret = <span class="hljs-built_in">min</span>(ret, s + edges[v][u])</span><br></pre></td></tr></tbody></table></figure>
<p>下面附完整的Python 3和Java 8的AC代码，同步在 <a target="_blank" rel="noopener" href="https://github.com/MyEncyclopedia/blog/tree/master/tsp/alg_aizu">github</a>。</p>
<h3 id="aizu-java-8-递归dp版本">AIZU Java 8 递归DP版本</h3>
<figure class="highlight java hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// passed http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A</span></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> V_NUM;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] edges;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V_NUM)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">this</span>.V_NUM = V_NUM;</span><br><span class="line">            <span class="hljs-keyword">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V_NUM][V_NUM];</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V_NUM; i++) {</span><br><span class="line">                Arrays.fill(<span class="hljs-keyword">this</span>.edges[i], Integer.MAX_VALUE);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dest, <span class="hljs-keyword">int</span> dist)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">this</span>.edges[src][dest] = dist;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSP</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Graph g;</span><br><span class="line">        <span class="hljs-keyword">long</span>[][] dp;</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TSP</span><span class="hljs-params">(Graph g)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">this</span>.g = g;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">int</span> N = g.V_NUM;</span><br><span class="line">            dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span> &lt;&lt; N][N];</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++) {</span><br><span class="line">                Arrays.fill(dp[i], -<span class="hljs-number">1</span>);</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="hljs-keyword">long</span> ret = recurse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> ret == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ret;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">recurse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state, <span class="hljs-keyword">int</span> v)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">int</span> ALL = (<span class="hljs-number">1</span> &lt;&lt; g.V_NUM) - <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[state][v] &gt;= <span class="hljs-number">0</span>) {</span><br><span class="line">                <span class="hljs-keyword">return</span> dp[state][v];</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (state == ALL &amp;&amp; v == <span class="hljs-number">0</span>) {</span><br><span class="line">                dp[state][v] = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">long</span> res = Integer.MAX_VALUE;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; g.V_NUM; u++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> ((state &amp; (<span class="hljs-number">1</span> &lt;&lt; u)) == <span class="hljs-number">0</span>) {</span><br><span class="line">                    <span class="hljs-keyword">long</span> s = recurse(state | <span class="hljs-number">1</span> &lt;&lt; u, u);</span><br><span class="line">                    res = Math.min(res, s + g.edges[v][u]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dp[state][v] = res;</span><br><span class="line">            <span class="hljs-keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</span><br><span class="line">    </span><br><span class="line">        Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="hljs-keyword">int</span> V = in.nextInt();</span><br><span class="line">        <span class="hljs-keyword">int</span> E = in.nextInt();</span><br><span class="line">        Graph g = <span class="hljs-keyword">new</span> Graph(V);</span><br><span class="line">        <span class="hljs-keyword">while</span> (E &gt; <span class="hljs-number">0</span>) {</span><br><span class="line">            <span class="hljs-keyword">int</span> src = in.nextInt();</span><br><span class="line">            <span class="hljs-keyword">int</span> dest = in.nextInt();</span><br><span class="line">            <span class="hljs-keyword">int</span> dist = in.nextInt();</span><br><span class="line">            g.setDist(src, dest, dist);</span><br><span class="line">            E--;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="hljs-keyword">new</span> TSP(g).solve());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="aizu-python-3-递归dp版本">AIZU Python 3 递归DP版本</h3>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line">INT_INF = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span>:</span></span><br><span class="line">    v_num: <span class="hljs-built_in">int</span></span><br><span class="line">    edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, v_num: <span class="hljs-built_in">int</span></span>):</span></span><br><span class="line">        self.v_num = v_num</span><br><span class="line">        self.edges = [[INT_INF <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(v_num)] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(v_num)]</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setDist</span>(<span class="hljs-params">self, src: <span class="hljs-built_in">int</span>, dest: <span class="hljs-built_in">int</span>, dist: <span class="hljs-built_in">int</span></span>):</span></span><br><span class="line">        self.edges[src][dest] = dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSPSolver</span>:</span></span><br><span class="line">    g: Graph</span><br><span class="line">    dp: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, g: Graph</span>):</span></span><br><span class="line">        self.g = g</span><br><span class="line">        self.dp = [[<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g.v_num)] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; g.v_num)]</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._recurse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_recurse</span>(<span class="hljs-params">self, v: <span class="hljs-built_in">int</span>, state: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    </span></span><br><span class="line"><span class="hljs-string">        :param v:</span></span><br><span class="line"><span class="hljs-string">        :param state:</span></span><br><span class="line"><span class="hljs-string">        :return: -1 means INF</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        dp = self.dp</span><br><span class="line">        edges = self.g.edges</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-keyword">if</span> dp[state][v] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> dp[state][v]</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-keyword">if</span> (state == (<span class="hljs-number">1</span> &lt;&lt; self.g.v_num) - <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (v == <span class="hljs-number">0</span>):</span><br><span class="line">            dp[state][v] = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-keyword">return</span> dp[state][v]</span><br><span class="line">    </span><br><span class="line">        ret: <span class="hljs-built_in">int</span> = INT_INF</span><br><span class="line">        <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.g.v_num):</span><br><span class="line">            <span class="hljs-keyword">if</span> (state &amp; (<span class="hljs-number">1</span> &lt;&lt; u)) == <span class="hljs-number">0</span>:</span><br><span class="line">                s: <span class="hljs-built_in">int</span> = self._recurse(u, state | <span class="hljs-number">1</span> &lt;&lt; u)</span><br><span class="line">                <span class="hljs-keyword">if</span> s != INT_INF <span class="hljs-keyword">and</span> edges[v][u] != INT_INF:</span><br><span class="line">                    <span class="hljs-keyword">if</span> ret == INT_INF:</span><br><span class="line">                        ret = s + edges[v][u]</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        ret = <span class="hljs-built_in">min</span>(ret, s + edges[v][u])</span><br><span class="line">        dp[state][v] = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span></span><br><span class="line">    V, E = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())</span><br><span class="line">    g: Graph = Graph(V)</span><br><span class="line">    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(E):</span><br><span class="line">        src, dest, dist = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())</span><br><span class="line">        g.setDist(src, dest, dist)</span><br><span class="line"></span><br><span class="line">    tsp: TSPSolver = TSPSolver(g)</span><br><span class="line">    <span class="hljs-built_in">print</span>(tsp.solve())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/leetcode-1227-airplane-seat-assignment-probability/" itemprop="url">从蒙特卡罗模拟，数学递推到直觉模式来思考 Leetcode 1227 飞机座位分配概率</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-08-28T18:45:01.000Z" itemprop="datePublished">8月 29 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 读完 (约 1580 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/airplane-seat-assignment-probability/">Leetcode
1227</a>
是一道有意思的概率题，本篇将从多个角度来讨论这道题。题目如下</p>
<blockquote>
<p>有 n 位乘客即将登机，飞机正好有 n
个座位。第一位乘客的票丢了，他随便选了一个座位坐下。 剩下的乘客将会：
如果他们自己的座位还空着，就坐到自己的座位上，
当他们自己的座位被占用时，随机选择其他座位，第 n
位乘客坐在自己的座位上的概率是多少？</p>
</blockquote>
<blockquote>
<p>示例 1： 输入：n = 1 输出：1.00000
解释：第一个人只会坐在自己的位置上。</p>
</blockquote>
<blockquote>
<p>示例 2： 输入: n = 2 输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是
0.5。</p>
</blockquote>
<blockquote>
<p>提示： 1 &lt;= n &lt;= 10^5</p>
</blockquote>
<p>假设规模为n时答案为f(n)，一般来说，这种递推问题在数学形式上可能有关于n的简单数学表达式（closed
form），或者肯定有f(n)关于f(n-k)的递推表达式。工程上，我们可以通过通过多次模拟即蒙特卡罗模拟来算得近似的数值解。</p>
<h2 id="monte-carlo-模拟发现规律">Monte Carlo 模拟发现规律</h2>
<p>首先，我们先来看看如何高效的用代码来模拟。根据题意的描述过程，直接可以写出下面代码。seats为n大小的bool
数组，每个位置表示此位置是否已经被占据。然后依次给第i个人按题意分配座位。注意，每次参数随机数范围在[0,n-1]，因此，会出现已经被占据的情况，此时需要再次随机，直至分配到空位。</p>
<h3 id="暴力直接模拟">暴力直接模拟</h3>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate_bruteforce</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Simulates one round. Unbounded time complexity.</span></span><br><span class="line"><span class="hljs-string">    :param n: total number of seats</span></span><br><span class="line"><span class="hljs-string">    :return: True if last one has last seat, otherwise False</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    seats = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):</span><br><span class="line">        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># first one, always random</span></span><br><span class="line">            seats[random.randint(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>)] = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seats[i]:  <span class="hljs-comment"># i-th has his seat</span></span><br><span class="line">                seats[i] = <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">                    rnd = random.randint(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) <span class="hljs-comment"># random until no conflicts</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seats[rnd]:</span><br><span class="line">                        seats[rnd] = <span class="hljs-literal">True</span></span><br><span class="line">                        <span class="hljs-keyword">break</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> seats[n-<span class="hljs-number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码来模拟 n 从 2 到10
的情况，每种情况跑500次模拟，输出如下 </p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 =&gt; 1.0</span><br><span class="line">2 =&gt; 0.55</span><br><span class="line">3 =&gt; 0.54</span><br><span class="line">4 =&gt; 0.486</span><br><span class="line">5 =&gt; 0.488</span><br><span class="line">6 =&gt; 0.498</span><br><span class="line">7 =&gt; 0.526</span><br><span class="line">8 =&gt; 0.504</span><br><span class="line">9 =&gt; 0.482</span><br><span class="line">10 =&gt; 0.494</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>发现当 n&gt;=2 时，似乎概率都是0.5。</p>
<h3 id="标准答案">标准答案</h3>
<p>其实，这道题的标准答案就是 n=1 为1，n&gt;=2 为0.5。下面是 python 3
标准答案。本篇后面会从多个角度来探讨为什么是0.5 。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthPersonGetsNthSeat</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.5</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="on-改进算法">O(n) 改进算法</h3>
<p>上面的暴力直接模拟版本有个最大的问题是当n很大时，随机分配座位会产生大量冲突，因此，最坏复杂度是没有任何上限的。解决方法是每次发生随机分配时保证不冲突，能直接选到空位。下面是一种最坏复杂度O(n)的模拟过程，seats数组初始话成
0，1，...，n-1，表示座位号。当第i个人登机时，seats[i:n]
的值为他可以选择的座位集合，而seats[0:i]为已经被占据的座位集合。由于[i:
n]是连续空间，产生随机数就能保证不冲突。当第i个人选完座位时，将他选中的seats[k]和seats[i]
交换，保证第i+i个人面临的seats[i+1:n]依然为可选座位集合。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate_online</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Simulates one round of complexity O(N).</span></span><br><span class="line"><span class="hljs-string">    :param n: total number of seats</span></span><br><span class="line"><span class="hljs-string">    :return: True if last one has last seat, otherwise False</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    seats = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span>(<span class="hljs-params">i, j</span>):</span></span><br><span class="line">        tmp = seats[i]</span><br><span class="line">        seats[i] = seats[j]</span><br><span class="line">        seats[j] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># for each person, the seats array idx available are [i, n-1]</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):</span><br><span class="line">        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># first one, always random</span></span><br><span class="line">            rnd = random.randint(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>)</span><br><span class="line">            swap(rnd, <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> seats[i] == i:  <span class="hljs-comment"># i-th still has his seat</span></span><br><span class="line">                <span class="hljs-keyword">pass</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                rnd = random.randint(i, n - <span class="hljs-number">1</span>)  <span class="hljs-comment"># selects idx from [i, n-1]</span></span><br><span class="line">                swap(rnd, i)</span><br><span class="line">    <span class="hljs-keyword">return</span> seats[n-<span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="递推思维">递推思维</h2>
<p>这一节我们用数学递推思维来解释0.5的解。令f(n) 为第 n
位乘客坐在自己的座位上的概率，考察第一个人的情况（first step
analysis），有三种可能</p>
<ol type="1">
<li>第一个人选了第一个即自己的座位，那么最后一个人一定能保证坐在自己的座位。</li>
<li>第一个人选了最后一个人的座位，无论中间什么过程，最后一个人无法坐到自己座位</li>
<li>第一个人选了第i个座位，(1&lt;i&lt;n)，那么第i个人前面的除了第一个外的人都会坐在自己位置上，第i个人由于没有自己座位，随机在剩余的座位1，座位
[i+1,n] 中随机选择，此时，问题转变为f(n-i+1)，如下图所示。</li>
</ol>
<figure>
<img src="/zh/2020/leetcode-1227-airplane-seat-assignment-probability/f(n).png">
<figcaption>
第一个人选了位置i
</figcaption>
</figure>
<figure>
<img src="/zh/2020/leetcode-1227-airplane-seat-assignment-probability/f(n-i+1).png">
<figcaption>
第i个人将问题转换成f(n-i+1)
</figcaption>
</figure>
<p>通过上面分析，得到概率递推关系如下</p>
<p><span class="math display">\[
f(n) =  
\begin{align*}
  \left\lbrace
  \begin{array}{r@{}l}
    1 &amp; &amp; p=\frac{1}{n} \quad \text{选了第一个位置} \\\\\\
    f(n-i+1) &amp; &amp; p=\frac{1}{n} \quad
\text{选了第i个位置，1&lt;i&lt;n} \\\\\\
    0 &amp; &amp; p=\frac{1}{n} \quad \text{选了第n个位置}
  \end{array}
  \right.
\end{align*}
\]</span></p>
<p>即f(n)的递推式为： <span class="math display">\[
f(n) = \frac{1}{n} + \frac{1}{n} \times [ f(n-1) + f(n-2) + ...+ f(2)],
\quad n&gt;=2
\]</span> 同理，f(n+1)递推式如下 <span class="math display">\[
f(n+1) = \frac{1}{n+1} + \frac{1}{n+1} \times [ f(n) + f(n-1) + ...+
f(2)]
\]</span> <span class="math inline">\((n+1)f(n+1) - nf(n)\)</span> 抵消
<span class="math inline">\(f(n-1) + ...f(2)\)</span> 项，可得 <span class="math display">\[
(n+1)f(n+1) - nf(n) = f(n)
\]</span> 即 <span class="math display">\[
f(n+1) = f(n) = \frac{1}{2} \quad n&gt;=2
\]</span></p>
<p>用数学归纳法也可以证明 n&gt;=2 时 f(n)=0.5。</p>
<h2 id="简化的思考方式">简化的思考方式</h2>
<p>我们再仔细思考一下上面的第三种情况，就是第一个人坐了第i个座位，1&lt;i&lt;n，此时，程序继续，不产生结果，直至产生结局1或者2，也就是case
1和2是真正的结局节点，它们产生的概率相同，因此答案是1/2。</p>
<p>从调用图可以看出这种关系，由于中间节点 f(4)，f(3)，f(2)生成Case
1和2的概率一样，因此无论它们之间是什么关系，最后结果都是1/2.</p>
<figure>
<img src="/zh/2020/leetcode-1227-airplane-seat-assignment-probability/call_graph.png">
<figcaption>
</figcaption>
</figure>
<p>知乎上有个很形象的类比理解方式</p>
<blockquote>
<p>考虑一枚硬币，正面向上的概率为 1/n，反面也是，立起来的概率为 (n-2)/n
。我们规定硬币立起来重新抛，但重新抛时，n会至少减小1。求结果为反面的概率。这样很显然结果为
1/2 。</p>
</blockquote>
<p>这里，正面向上对应Case 2，反面对应Case 1。</p>
<p>这种思想可以写出如下代码，seats为 n 大小的bool
数组，当第i个人（0&lt;i&lt;n）发现自己座位被占的话，此时必然seats[0]没有被占，同时seats[i+1:]都是空的。假设seats[0]被占的话，要么是第一个人占的，要么是第p个人（p&lt;i）坐了，两种情况下乱序都已经恢复了，此时第i个座位一定是空的。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Simulates one round of complexity O(N).</span></span><br><span class="line"><span class="hljs-string">    :param n: total number of seats</span></span><br><span class="line"><span class="hljs-string">    :return: True if last one has last seat, otherwise False</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    seats = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):</span><br><span class="line">        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># first one, always random</span></span><br><span class="line">            rnd = random.randint(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>)</span><br><span class="line">            seats[rnd] = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seats[i]:  <span class="hljs-comment"># i-th still has his seat</span></span><br><span class="line">                seats[i] = <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 0 must not be available, now we have 0 and [i+1, n-1],</span></span><br><span class="line">                rnd = random.randint(i, n - <span class="hljs-number">1</span>)</span><br><span class="line">                <span class="hljs-keyword">if</span> rnd == i:</span><br><span class="line">                    seats[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    seats[rnd] = <span class="hljs-literal">True</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> seats[n-<span class="hljs-number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/" itemprop="url">组合游戏系列3: 井字棋、五子棋的OpenAI Gym GUI环境</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-07-23T18:45:01.000Z" itemprop="datePublished">7月 24 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 读完 (约 2749 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>继上一篇完成了井字棋（N子棋）的minimax
最佳策略后，我们基于Pygame来创造一个图形游戏环境，可供人机和机器对弈，为后续模拟AlphaGo的自我强化学习算法做环境准备。OpenAI
Gym 在强化学习领域是事实标准，我们最终封装成OpenAI
Gym的接口。本篇所有代码都在<a target="_blank" rel="noopener" href="https://github.com/MyEncyclopedia/ConnectNGym">github.com/MyEncyclopedia/ConnectNGym</a>。</p>
<ul>
<li><p><a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></p></li>
<li><p><strong><a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></strong></p></li>
<li><p><a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-3-openai-gym-pygame/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></p></li>
</ul>
<h2 id="井字棋五子棋-pygame-实现">井字棋、五子棋 Pygame 实现</h2>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/pygame.gif">
<figcaption>
Pygame 井字棋玩家对弈效果
</figcaption>
</figure>
<p>Python
上有Tkinter，PyQt等跨平台GUI类库，主要用于桌面程序编程，但此类库容量较大，编程也相对麻烦。Pygame具有代码少，开发快的优势，比较适合快速开发五子棋这类桌面小游戏。
### Pygame 极简入门</p>
<p>与所有的GUI开发相同，Pygame也是基于事件的单线程编程模型。下面的例子包含了显示一个最简单GUI窗口，操作系统产生事件并发送到Pygame窗口，while
True
控制了python主线程永远轮询事件。我们在这里仅仅判断了当前是否是关闭应用程序事件，如果是则退出进程。此外，clock
用于控制FPS。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"><span class="hljs-keyword">import</span> pygame</span><br><span class="line">pygame.init()</span><br><span class="line">display = pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>))</span><br><span class="line">clock = pygame.time.Clock()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">	<span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():</span><br><span class="line">		<span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:</span><br><span class="line">			sys.exit(<span class="hljs-number">0</span>)</span><br><span class="line">		<span class="hljs-keyword">else</span>:</span><br><span class="line">			pygame.display.update()</span><br><span class="line">			clock.tick(<span class="hljs-number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pygameboard-主体代码">PyGameBoard 主体代码</h3>
PyGameBoard类封装了Pygame实现游戏交互和显示的逻辑。上一篇中，我们完成了ConnectNGame逻辑，这里PyGameBoard需要在初始化时，指定传入ConnectNGame
实例（见下图），支持通过API
方式改变其状态，也支持GUI交互方式等待人类玩家的输入。next_user_input(self)实现了等待人类玩家输入的逻辑，本质上是循环检查GUI事件直到有合法的落子产生。
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/diagram-pygameboard.svg">
<figcaption>
PyGameBoard Class Diagram
</figcaption>
</figure>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyGameBoard</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, connectNGame: ConnectNGame</span>):</span></span><br><span class="line">		self.connectNGame = connectNGame</span><br><span class="line">		pygame.init()</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next_user_input</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]:</span></span><br><span class="line">		self.action = <span class="hljs-literal">None</span></span><br><span class="line">		<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.action:</span><br><span class="line">			self.check_event()</span><br><span class="line">			self._render()</span><br><span class="line">			self.clock.tick(<span class="hljs-number">60</span>)</span><br><span class="line">		<span class="hljs-keyword">return</span> self.action</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">		<span class="hljs-keyword">return</span> self.connectNGame.move(r, c)</span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">	connectNGame = ConnectNGame()</span><br><span class="line">	pygameBoard = PyGameBoard(connectNGame)</span><br><span class="line">	<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> pygameBoard.isGameOver():</span><br><span class="line">		pos = pygameBoard.next_user_input()</span><br><span class="line">		pygameBoard.move(*pos)</span><br><span class="line"></span><br><span class="line">	pygame.quit()</span><br></pre></td></tr></tbody></table></figure>
<p>check_event
较之极简版本增加了处理用户输入事件，这里我们仅支持人类玩家鼠标输入。方法_handle_user_input
将鼠标点击事件转换成棋盘行列值，并判断点击位置是否合法，合法则返回落子位置，类型为Tuple[int,
int]，例如(0, 0)表示棋盘最左上角位置。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_event</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">	<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> pygame.event.get():</span><br><span class="line">		<span class="hljs-keyword">if</span> e.<span class="hljs-built_in">type</span> == pygame.QUIT:</span><br><span class="line">			pygame.quit()</span><br><span class="line">			sys.exit(<span class="hljs-number">0</span>)</span><br><span class="line">		<span class="hljs-keyword">elif</span> e.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">			self._handle_user_input(e)</span><br><span class="line">    </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_user_input</span>(<span class="hljs-params">self, e: Event</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]:</span></span><br><span class="line">	origin_x = self.start_x - self.edge_size</span><br><span class="line">	origin_y = self.start_y - self.edge_size</span><br><span class="line">	size = (self.board_size - <span class="hljs-number">1</span>) * self.grid_size + self.edge_size * <span class="hljs-number">2</span></span><br><span class="line">	pos = e.pos</span><br><span class="line">	<span class="hljs-keyword">if</span> origin_x &lt;= pos[<span class="hljs-number">0</span>] &lt;= origin_x + size <span class="hljs-keyword">and</span> origin_y &lt;= pos[<span class="hljs-number">1</span>] &lt;= origin_y + size:</span><br><span class="line">		<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.connectNGame.gameOver:</span><br><span class="line">			x = pos[<span class="hljs-number">0</span>] - origin_x</span><br><span class="line">			y = pos[<span class="hljs-number">1</span>] - origin_y</span><br><span class="line">			r = <span class="hljs-built_in">int</span>(y // self.grid_size)</span><br><span class="line">			c = <span class="hljs-built_in">int</span>(x // self.grid_size)</span><br><span class="line">			valid = self.connectNGame.checkAction(r, c)</span><br><span class="line">			<span class="hljs-keyword">if</span> valid:</span><br><span class="line">				self.action = (r, c)</span><br><span class="line">				<span class="hljs-keyword">return</span> self.action</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="openai-gym-接口规范">OpenAI Gym 接口规范</h2>
<p>OpenAI
Gym规范了Agent和环境（Env）之间的互动，核心抽象接口类是gym.Env，自定义的游戏环境需要继承Env，并实现
reset、step和render方法。下面我们看一下如何具体实现ConnectNGym的这几个方法：</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectNGym</span>(<span class="hljs-params">gym.Env</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>) -&gt; ConnectNGame:</span></span><br><span class="line">		<span class="hljs-string">"""Resets the state of the environment and returns an initial observation.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Returns:</span></span><br><span class="line"><span class="hljs-string">			observation (object): the initial observation.</span></span><br><span class="line"><span class="hljs-string">		"""</span></span><br><span class="line">		<span class="hljs-keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, action: <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Tuple</span>[ConnectNGame, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>, <span class="hljs-literal">None</span>]:</span></span><br><span class="line">		<span class="hljs-string">"""Run one timestep of the environment's dynamics. When end of</span></span><br><span class="line"><span class="hljs-string">		episode is reached, you are responsible for calling `reset()`</span></span><br><span class="line"><span class="hljs-string">		to reset this environment's state.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Accepts an action and returns a tuple (observation, reward, done, info).</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Args:</span></span><br><span class="line"><span class="hljs-string">			action (object): an action provided by the agent</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Returns:</span></span><br><span class="line"><span class="hljs-string">			observation (object): agent's observation of the current environment</span></span><br><span class="line"><span class="hljs-string">			reward (float) : amount of reward returned after previous action</span></span><br><span class="line"><span class="hljs-string">			done (bool): whether the episode has ended, in which case further step() calls will return undefined results</span></span><br><span class="line"><span class="hljs-string">			info (dict): contains auxiliary diagnostic information (helpful for debugging, and sometimes learning)</span></span><br><span class="line"><span class="hljs-string">		"""</span></span><br><span class="line">		<span class="hljs-keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, mode=<span class="hljs-string">'human'</span></span>):</span></span><br><span class="line">		<span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">		Renders the environment.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		The set of supported modes varies per environment. (And some</span></span><br><span class="line"><span class="hljs-string">		environments do not support rendering at all.) By convention,</span></span><br><span class="line"><span class="hljs-string">		if mode is:</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		- human: render to the current display or terminal and</span></span><br><span class="line"><span class="hljs-string">			return nothing. Usually for human consumption.</span></span><br><span class="line"><span class="hljs-string">		- rgb_array: Return an numpy.ndarray with shape (x, y, 3),</span></span><br><span class="line"><span class="hljs-string">			representing RGB values for an x-by-y pixel image, suitable</span></span><br><span class="line"><span class="hljs-string">			for turning into a video.</span></span><br><span class="line"><span class="hljs-string">		- ansi: Return a string (str) or StringIO.StringIO containing a</span></span><br><span class="line"><span class="hljs-string">			terminal-style text representation. The text can include newlines</span></span><br><span class="line"><span class="hljs-string">			and ANSI escape sequences (e.g. for colors).</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Note:</span></span><br><span class="line"><span class="hljs-string">		Make sure that your class's metadata 'render.modes' key includes</span></span><br><span class="line"><span class="hljs-string">		the list of supported modes. It's recommended to call super()</span></span><br><span class="line"><span class="hljs-string">		in implementations to use the functionality of this method.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">		Args:</span></span><br><span class="line"><span class="hljs-string">			mode (str): the mode to render with</span></span><br><span class="line"><span class="hljs-string">		"""</span></span><br><span class="line">		<span class="hljs-keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="reset-方法">reset 方法</h3>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>) -&gt; ConnectNGame</span></span><br></pre></td></tr></tbody></table></figure>
<p>重置环境状态，并返回给Agent重置后环境下观察到的状态。ConnectNGym内部维护了ConnectNGame实例作为自身状态，每个agent落子后会更新这个实例。由于棋类游戏对于玩家来说是完全信息的，我们直接返回ConnectNGame的deepcopy。</p>
<h3 id="step-方法">step 方法</h3>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, action: <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Tuple</span>[ConnectNGame, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>, <span class="hljs-literal">None</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>Agent 选择了某一action后，由环境来执行这个action并返回4个值：1.
执行后的环境Agent观察到的状态；2.
环境执行了这个action回馈给agent的reward；3. 环境是否结束；4.
其余信息。</p>
<p>step方法是最核心的接口，因此举例来说明ConnectNGym中的输入和输出：</p>
初始状态
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/s0.png">
<figcaption>
状态 ((0, 0, 0), (0, 0, 0), (0, 0, 0))
</figcaption>
</figure>
<p>Agent A 选择action = (0, 0)，执行ConnectNGym.step 后返回值：status =
((1, 0, 0), (0, 0, 0), (0, 0, 0))，reward = 0，game_end = False</p>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/s1.png">
<figcaption>
状态 ((1, 0, 0), (0, 0, 0), (0, 0, 0))
</figcaption>
</figure>
<p>Agent B 选择action = (1, 1)，执行ConnectNGym.step 后返回值：status =
((1, 0, 0), (0, -1, 0), (0, 0, 0))，reward = 0，game_end = False</p>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/s2.png">
<figcaption>
状态 ((1, 0, 0), (0, -1, 0), (0, 0, 0))
</figcaption>
</figure>
重复此过程直至游戏结束，下面是5步后游戏可能达到的最终状态
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/s5.png">
<figcaption>
终结状态 ((1, 1, 1), (-1, -1, 0), (0, 0, 0))
</figcaption>
</figure>
<p>此时step的返回值为：status = ((1, 1, 1), (-1, -1, 0), (0, 0,
0))，reward = 1，game_end = True</p>
<h3 id="render-方法">render 方法</h3>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, mode=<span class="hljs-string">'human'</span></span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>展现环境，通过mode区分是否是人类玩家。</p>
<h3 id="connectngym-代码">ConnectNGym 代码</h3>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectNGym</span>(<span class="hljs-params">gym.Env</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, pygameBoard: PyGameBoard, isGUI=<span class="hljs-literal">True</span>, displaySec=<span class="hljs-number">2</span></span>):</span></span><br><span class="line">		self.pygameBoard = pygameBoard</span><br><span class="line">		self.isGUI = isGUI</span><br><span class="line">		self.displaySec = displaySec</span><br><span class="line">		self.action_space = spaces.Discrete(pygameBoard.board_size * pygameBoard.board_size)</span><br><span class="line">		self.observation_space = spaces.Discrete(pygameBoard.board_size * pygameBoard.board_size)</span><br><span class="line">		self.seed()</span><br><span class="line">		self.reset()</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>) -&gt; ConnectNGame:</span></span><br><span class="line">		self.pygameBoard.connectNGame.reset()</span><br><span class="line">		<span class="hljs-keyword">return</span> copy.deepcopy(self.pygameBoard.connectNGame)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, action: <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Tuple</span>[ConnectNGame, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>, <span class="hljs-literal">None</span>]:</span></span><br><span class="line">		<span class="hljs-comment"># assert self.action_space.contains(action)</span></span><br><span class="line"></span><br><span class="line">		r, c = action</span><br><span class="line">		reward = REWARD_NONE</span><br><span class="line">		result = self.pygameBoard.move(r, c)</span><br><span class="line">		<span class="hljs-keyword">if</span> self.pygameBoard.isGameOver():</span><br><span class="line">			reward = result</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">return</span> copy.deepcopy(self.pygameBoard.connectNGame), reward, <span class="hljs-keyword">not</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, mode=<span class="hljs-string">'human'</span></span>):</span></span><br><span class="line">		<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.isGUI:</span><br><span class="line">			self.pygameBoard.connectNGame.drawText()</span><br><span class="line">			time.sleep(self.displaySec)</span><br><span class="line">		<span class="hljs-keyword">else</span>:</span><br><span class="line">			self.pygameBoard.display(sec=self.displaySec)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_available_actions</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">		<span class="hljs-keyword">return</span> self.pygameBoard.getAvailablePositions()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="井字棋n子棋minimax策略玩家">井字棋（N子棋）Minimax策略玩家</h2>
<p>图中当k=3,m=n=3即井字棋游戏中，两个minimax策略玩家的对弈效果，游戏结局符合已知的结论：井字棋的解是先手被对方逼平。</p>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/self_play.gif">
<figcaption>
Minimax策略AI对弈
</figcaption>
</figure>
<h3 id="镜像游戏状态的dp处理">镜像游戏状态的DP处理</h3>
<p>上一篇中，我们确认了井字棋的总状态数是5478。当k=3,
m=n=4时是6035992，k=4,
m=n=4时是9722011，总的来说游戏状态数是以指数级增长的。上一版minimax
DP策略还有改善的空间，第一种是旋转格局的处理。对于任意一种棋盘格局可以得到90度旋转后的另外三种格局，它们的最佳结局是一致的。因此，我们在递归过程中解得某一棋盘格局后，将其另外三种旋转后格局的解也一起缓存起来。例如：</p>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/pos.png">
<figcaption>
游戏状态1
</figcaption>
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/pos_others.png">
<figcaption>
旋转后的三种游戏状态
</figcaption>
</figure>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">similarStatus</span>(<span class="hljs-params">self, status: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]]:</span></span><br><span class="line">	ret = []</span><br><span class="line">	rotatedS = status</span><br><span class="line">	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):</span><br><span class="line">		rotatedS = self.rotate(rotatedS)</span><br><span class="line">		ret.append(rotatedS)</span><br><span class="line">	<span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate</span>(<span class="hljs-params">self, status: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]:</span></span><br><span class="line">	N = <span class="hljs-built_in">len</span>(status)</span><br><span class="line">	board = [[ConnectNGame.AVAILABLE] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):</span><br><span class="line">		<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):</span><br><span class="line">			board[c][N - <span class="hljs-number">1</span> - r] = status[r][c]</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>([<span class="hljs-built_in">tuple</span>(board[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)])</span><br></pre></td></tr></tbody></table></figure>
<h3 id="minimax-策略预计算">Minimax 策略预计算</h3>
<p>之前我们对每个棋局去计算最佳的下一步，并在此过程中做了剪枝，即当已经找到当前玩家必胜落子时直接返回。这对于单一局面的计算是较优的，但是AI
Agent
需要在每一步都重复这个过程，当棋盘大小&gt;3时运算非常耗时，因此我们来做第二种优化。初始空棋盘时使用Minimax来保证遍历所有状态，缓存所有棋局的最佳结果。对于AI
Agent面临的每个棋局只需查找此棋局下所有的可能落子位置，并返回最佳决定，这样大大减少了每次棋局下重复的minimax递归计算。相关代码如下。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlannedMinimaxStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, game: ConnectNGame</span>):</span></span><br><span class="line">		<span class="hljs-built_in">super</span>().__init__()</span><br><span class="line">		self.game = copy.deepcopy(game)</span><br><span class="line">		self.dpMap = {}  <span class="hljs-comment"># game_status =&gt; result, move</span></span><br><span class="line">		self.result = self.minimax(game.getStatus())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">		game = copy.deepcopy(game)</span><br><span class="line"></span><br><span class="line">		player = game.currentPlayer</span><br><span class="line">		bestResult = player * -<span class="hljs-number">1</span>  <span class="hljs-comment"># assume opponent win as worst result</span></span><br><span class="line">		bestMove = <span class="hljs-literal">None</span></span><br><span class="line">		<span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">			game.move(*move)</span><br><span class="line">			status = game.getStatus()</span><br><span class="line">			game.undo()</span><br><span class="line"></span><br><span class="line">			result = self.dpMap[status]</span><br><span class="line"></span><br><span class="line">			<span class="hljs-keyword">if</span> player == ConnectNGame.PLAYER_A:</span><br><span class="line">				bestResult = <span class="hljs-built_in">max</span>(bestResult, result)</span><br><span class="line">			<span class="hljs-keyword">else</span>:</span><br><span class="line">				bestResult = <span class="hljs-built_in">min</span>(bestResult, result)</span><br><span class="line">			<span class="hljs-comment"># update bestMove if any improvement</span></span><br><span class="line">			bestMove = move <span class="hljs-keyword">if</span> bestResult == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">			<span class="hljs-built_in">print</span>(<span class="hljs-string">f'move <span class="hljs-subst">{move}</span> =&gt; <span class="hljs-subst">{result}</span>'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">return</span> bestResult, bestMove</span><br></pre></td></tr></tbody></table></figure>
<h2 id="agent-类和对弈逻辑">Agent 类和对弈逻辑</h2>
<p>Agent 类的抽象并不是 OpenAI
Gym的规范，出于代码扩展性，我们也封装了Agent基类及其子类，包括AI玩家和人类玩家。BaseAgent需要子类实现
act方法，默认实现为随机决定。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseAgent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">		<span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">act</span>(<span class="hljs-params">self, game: PyGameBoard, available_actions</span>):</span></span><br><span class="line">		<span class="hljs-keyword">return</span> random.choice(available_actions)</span><br></pre></td></tr></tbody></table></figure>
<p>AIAgent 实现act并代理给 strategy 的action方法。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIAgent</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, strategy: Strategy</span>):</span></span><br><span class="line">		self.strategy = strategy</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">act</span>(<span class="hljs-params">self, game: PyGameBoard, available_actions</span>):</span></span><br><span class="line">		result, move = self.strategy.action(game.connectNGame)</span><br><span class="line">		<span class="hljs-keyword">assert</span> move <span class="hljs-keyword">in</span> available_actions</span><br><span class="line">		<span class="hljs-keyword">return</span> move</span><br></pre></td></tr></tbody></table></figure>
<p>HumanAgent 实现act并代理给 PyGameBoard 的next_user_input方法。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HumanAgent</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">		<span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">act</span>(<span class="hljs-params">self, game: PyGameBoard, available_actions</span>):</span></span><br><span class="line">		<span class="hljs-keyword">return</span> game.next_user_input()</span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/diagram-agent.svg">
<figcaption>
Agent Class Diagram
</figcaption>
</figure>
<p>下面代码展示如何将Agent，ConnectNGym，PyGameBoard
等所有上述类串联起来，完成人人对弈，人机对弈。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_ai_vs_ai</span>(<span class="hljs-params">env: ConnectNGym</span>):</span></span><br><span class="line">	plannedMinimaxAgent = AIAgent(PlannedMinimaxStrategy(env.pygameBoard.connectNGame))</span><br><span class="line">	play(env, plannedMinimaxAgent, plannedMinimaxAgent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span>(<span class="hljs-params">env: ConnectNGym, agent1: BaseAgent, agent2: BaseAgent</span>):</span></span><br><span class="line">	agents = [agent1, agent2]</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">		env.reset()</span><br><span class="line">		done = <span class="hljs-literal">False</span></span><br><span class="line">		agent_id = -<span class="hljs-number">1</span></span><br><span class="line">		<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> done:</span><br><span class="line">			agent_id = (agent_id + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span></span><br><span class="line">			available_actions = env.get_available_actions()</span><br><span class="line">			agent = agents[agent_id]</span><br><span class="line">			action = agent.act(pygameBoard, available_actions)</span><br><span class="line">			_, reward, done, info = env.step(action)</span><br><span class="line">			env.render(<span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line">			<span class="hljs-keyword">if</span> done:</span><br><span class="line">				<span class="hljs-built_in">print</span>(<span class="hljs-string">f'result=<span class="hljs-subst">{reward}</span>'</span>)</span><br><span class="line">				time.sleep(<span class="hljs-number">3</span>)</span><br><span class="line">				<span class="hljs-keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">	pygameBoard = PyGameBoard(connectNGame=ConnectNGame(board_size=<span class="hljs-number">3</span>, N=<span class="hljs-number">3</span>))</span><br><span class="line">	env = ConnectNGym(pygameBoard)</span><br><span class="line">	env.render(<span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line">	play_ai_vs_ai(env)</span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="/zh/2020/combinatorial-game-3-openai-gym-pygame/diagram-overview.svg">
<figcaption>
Class Diagram 总览
</figcaption>
</figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-2-tictactoe/" itemprop="url">组合游戏系列2: 井字棋Leetcode系列题解和Minimax最佳策略实现</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-07-11T18:45:01.000Z" itemprop="datePublished">7月 12 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 读完 (约 4735 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>继上一篇介绍了Minimax 和Alpha Beta
剪枝算法之后，本篇选择了Leetcode中的井字棋游戏题目，积累相关代码后实现井字棋游戏并扩展到五子棋和N子棋（战略井字棋），随后用Minimax和Alpha
Beta剪枝算法解得小规模下N子棋的游戏结局，并分析其状态数量和每一步的最佳策略。后续篇章中，我们基于本篇代码完成一个N子棋的OpenAI
Gym
图形环境，可用于人机对战或机器对战，并最终实现棋盘规模稍大的五子棋或者N子棋中的蒙特卡洛树搜索（MCTS）算法。</p>
<ul>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></p></li>
<li><p><strong><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></strong></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></p></li>
</ul>
<h2 id="leetcode-上的井字棋系列">Leetcode 上的井字棋系列</h2>
<h3 id="leetcode-1275.-找出井字棋的获胜者-简单"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/">Leetcode
1275. 找出井字棋的获胜者 (简单)</a></h3>
<blockquote>
<p>A 和&nbsp;B&nbsp;在一个&nbsp;3&nbsp;x&nbsp;3&nbsp;的网格上玩井字棋。<br>
井字棋游戏的规则如下：<br> 玩家轮流将棋子放在空方格 (" ") 上。<br>
第一个玩家 A 总是用&nbsp;"X" 作为棋子，而第二个玩家 B 总是用 "O"
作为棋子。<br> "X" 和 "O"
只能放在空方格中，而不能放在已经被占用的方格上。<br> 只要有 3
个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。<br>
如果所有方块都放满棋子（不为空），游戏也会结束。<br>
游戏结束后，棋子无法再进行任何移动。<br> 给你一个数组
moves，其中每个元素是大小为 2
的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A
后 B）记录了两人各自的棋子位置。<br> 如果游戏存在获胜者（A 或
B），就返回该游戏的获胜者；如果游戏以平局结束，则返回
"Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。<br>
你可以假设&nbsp;moves&nbsp;都 有效（遵循井字棋规则），网格最初是空的，A
将先行动。</p>
</blockquote>
<blockquote>
<p>示例 1：<br> 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]<br>
输出："A"<br> 解释："A" 获胜，他总是先走。<br> "X " "X " "X " "X " "X
"<br> " " -&gt; " " -&gt; " X " -&gt; " X " -&gt; " X "<br> " " "O "
"O " "OO " "OOX"<br></p>
</blockquote>
<blockquote>
<p>示例 2： 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]<br>
输出："B"<br> 解释："B" 获胜。<br> "X " "X " "XX " "XXO" "XXO"
"XXO"<br> " " -&gt; " O " -&gt; " O " -&gt; " O " -&gt; "XO " -&gt; "XO
" <br> " " " " " " " " " " "O "<br></p>
</blockquote>
<p>第一种解法，检查A或者B赢的所有可能情况：某玩家占据8种连线的任意一种情况则胜利，我们使用八个变量来保存所有情况。下面的代码使用了一个小技巧，将moves转换成3x3的棋盘状态数组，元素的值为1，-1和0。1，-1代表两个玩家，0代表空的棋盘格子，其优势在于后续我们只需累加棋盘的值到八个变量中关联的若干个，再检查这八个变量是否满足取胜条件。例如，row[0]表示第一行的状态，当遍历一次所有棋盘格局后，row[0]为第一行的3个格子的总和，只有当row[0]
== 3 才表明玩家A占据了第一行，-3表明玩家B占据了第一行。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tictactoe</span>(<span class="hljs-params">self, moves: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">str</span>:</span></span><br><span class="line">        board = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]</span><br><span class="line">        <span class="hljs-keyword">for</span> idx, xy <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moves):</span><br><span class="line">            player = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span></span><br><span class="line">            board[xy[<span class="hljs-number">0</span>]][xy[<span class="hljs-number">1</span>]] = player</span><br><span class="line"></span><br><span class="line">        turn = <span class="hljs-number">0</span></span><br><span class="line">        row, col = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line">        diag1, diag2 = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">                turn += board[r][c]</span><br><span class="line">                row[r] += board[r][c]</span><br><span class="line">                col[c] += board[r][c]</span><br><span class="line">                <span class="hljs-keyword">if</span> r == c:</span><br><span class="line">                    diag1 += board[r][c]</span><br><span class="line">                <span class="hljs-keyword">if</span> r + c == <span class="hljs-number">2</span>:</span><br><span class="line">                    diag2 += board[r][c]</span><br><span class="line"></span><br><span class="line">        oWin = <span class="hljs-built_in">any</span>(row[r] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == <span class="hljs-number">3</span></span><br><span class="line">        xWin = <span class="hljs-built_in">any</span>(row[r] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == -<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == -<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span> <span class="hljs-keyword">if</span> oWin <span class="hljs-keyword">else</span> <span class="hljs-string">"B"</span> <span class="hljs-keyword">if</span> xWin <span class="hljs-keyword">else</span> <span class="hljs-string">"Draw"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) == <span class="hljs-number">9</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Pending"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>下面我们给出另一种解法，这种解法虽然代码较多，但可以不必遍历棋盘每个格子，比上一种严格遍历一次棋盘的解法略为高效。原理如下，题目保证了moves过程中不会产生输赢结果，因此我们直接检查最后一个棋子向外的八个方向，若任意方向有三连子，则此玩家获胜。这种解法主要是为后续井字棋扩展到五子棋时判断每个落子是否产生输赢做代码准备。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkWin</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        north = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line">        south = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">        east = self.getConnectedNum(r, c, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        west = self.getConnectedNum(r, c, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        south_east = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        north_west = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        north_east = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        south_west = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (north + south + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (east + west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> \</span><br><span class="line">                (south_east + north_west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (north_east + south_west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getConnectedNum</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span>, dr: <span class="hljs-built_in">int</span>, dc: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        player = self.board[r][c]</span><br><span class="line">        result = <span class="hljs-number">0</span></span><br><span class="line">        i = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            new_r = r + dr * i</span><br><span class="line">            new_c = c + dc * i</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= new_r &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= new_c &lt; <span class="hljs-number">3</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> self.board[new_r][new_c] == player:</span><br><span class="line">                    result += <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tictactoe</span>(<span class="hljs-params">self, moves: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">str</span>:</span></span><br><span class="line">        self.board = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]</span><br><span class="line">        <span class="hljs-keyword">for</span> idx, xy <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moves):</span><br><span class="line">            player = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span></span><br><span class="line">            self.board[xy[<span class="hljs-number">0</span>]][xy[<span class="hljs-number">1</span>]] = player</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># only check last move</span></span><br><span class="line">        r, c = moves[-<span class="hljs-number">1</span>]</span><br><span class="line">        win = self.checkWin(r, c)</span><br><span class="line">        <span class="hljs-keyword">if</span> win:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"B"</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Draw"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) == <span class="hljs-number">9</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Pending"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="leetcode-794.-有效的井字游戏-中等"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/">Leetcode
794. 有效的井字游戏 (中等)</a></h3>
<blockquote>
<p>用字符串数组作为井字游戏的游戏板
board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回
true。<br> 该游戏板是一个 3 x 3 数组，由字符 " "，"X" 和 "O" 组成。字符
" " 代表一个空位。<br> 以下是井字游戏的规则：<br>
玩家轮流将字符放入空位（" "）中。<br> 第一个玩家总是放字符
“X”，且第二个玩家总是放字符 “O”。<br> “X” 和 “O”
只允许放置在空位中，不允许对已放有字符的位置进行填充。<br> 当有 3
个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。<br>
当所有位置非空时，也算为游戏结束。<br>
如果游戏结束，玩家不允许再放置字符。<br></p>
</blockquote>
<blockquote>
<p>示例 1:<br> 输入: board = ["O ", " ", " "]<br> 输出: false<br>
解释: 第一个玩家总是放置“X”。<br></p>
</blockquote>
<blockquote>
<p>示例 2:<br> 输入: board = ["XOX", " X ", " "]<br> 输出: false<br>
解释: 玩家应该是轮流放置的。<br></p>
</blockquote>
<blockquote>
<p>示例 3:<br> 输入: board = ["XXX", " ", "OOO"]<br> 输出:
false<br></p>
</blockquote>
<blockquote>
<p>示例 4:<br> 输入: board = ["XOX", "O O", "XOX"]<br> 输出: true<br>
说明:<br></p>
</blockquote>
<blockquote>
<p>游戏板 board 是长度为 3 的字符串数组，其中每个字符串 board[i]
的长度为 3。 board[i][j] 是集合 {" ", "X", "O"} 中的一个字符。</p>
</blockquote>
<p>这道题第一反应是需要DFS来判断给定状态是否可达，但其实可以用上面1275的思路，即通过检验最终棋盘的一些特点来判断给定状态是否合法。比如，X和O的数量只有可能相同，或X比O多一个。其关键在于需要找到判断状态合法的充要条件，就可以在<span class="math inline">\(O(1)\)</span> 时间复杂度完成判断。
此外，这道题给了我们井字棋所有可能状态数量的启示。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convertCell</span>(<span class="hljs-params">self, c:<span class="hljs-built_in">str</span></span>):</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">'X'</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">'O'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validTicTacToe</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        turn = <span class="hljs-number">0</span></span><br><span class="line">        row, col = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line">        diag1, diag2 = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">                turn += self.convertCell(board[r][c])</span><br><span class="line">                row[r] += self.convertCell(board[r][c])</span><br><span class="line">                col[c] += self.convertCell(board[r][c])</span><br><span class="line">                <span class="hljs-keyword">if</span> r == c:</span><br><span class="line">                    diag1 += self.convertCell(board[r][c])</span><br><span class="line">                <span class="hljs-keyword">if</span> r + c == <span class="hljs-number">2</span>:</span><br><span class="line">                    diag2 += self.convertCell(board[r][c])</span><br><span class="line"></span><br><span class="line">        xWin = <span class="hljs-built_in">any</span>(row[r] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == <span class="hljs-number">3</span></span><br><span class="line">        oWin = <span class="hljs-built_in">any</span>(row[r] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == -<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == -<span class="hljs-number">3</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (xWin <span class="hljs-keyword">and</span> turn == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (oWin <span class="hljs-keyword">and</span> turn == <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (turn == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> turn == <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> xWin <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> oWin)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="leetcode-348.-判定井字棋胜负-中等加锁"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-tic-tac-toe/">Leetcode 348.
判定井字棋胜负 (中等，加锁)</a></h3>
<blockquote>
<p>请在 n × n
的棋盘上，实现一个判定井字棋（Tic-Tac-Toe）胜负的神器，判断每一次玩家落子后，是否有胜出的玩家。<br>
在这个井字棋游戏中，会有 2
名玩家，他们将轮流在棋盘上放置自己的棋子。<br>
在实现这个判定器的过程中，你可以假设以下这些规则一定成立：<br>
每一步棋都是在棋盘内的，并且只能被放置在一个空的格子里；<br>
一旦游戏中有一名玩家胜出的话，游戏将不能再继续；<br>
一个玩家如果在同一行、同一列或者同一斜对角线上都放置了自己的棋子，那么他便获得胜利。</p>
</blockquote>
<blockquote>
<p>示例： 给定棋盘边长 n = 3, 玩家 1 的棋子符号是 "X"，玩家 2
的棋子符号是 "O"。<br> TicTacToe toe = new TicTacToe(3);<br>
toe.move(0, 0, 1); -&gt; 函数返回 0
(此时，暂时没有玩家赢得这场对决)<br> |X| | |<br> | | | | // 玩家 1 在
(0, 0) 落子。<br> | | | |<br> <br> toe.move(0, 2, 2); -&gt; 函数返回
0 (暂时没有玩家赢得本场比赛)<br> |X| |O|<br> | | | | // 玩家 2 在 (0,
2) 落子。<br> | | | |<br> <br> toe.move(2, 2, 1); -&gt; 函数返回 0
(暂时没有玩家赢得比赛)<br> |X| |O|<br> | | | | // 玩家 1 在 (2, 2)
落子。<br> | | |X|<br> <br> toe.move(1, 1, 2); -&gt; 函数返回 0
(暂没有玩家赢得比赛)<br> |X| |O|<br> | |O| | // 玩家 2 在 (1, 1)
落子。<br> | | |X|<br> <br> toe.move(2, 0, 1); -&gt; 函数返回 0
(暂无玩家赢得比赛)<br> |X| |O|<br> | |O| | // 玩家 1 在 (2, 0)
落子。<br> |X| |X|<br> <br> toe.move(1, 0, 2); -&gt; 函数返回 0
(没有玩家赢得比赛)<br> |X| |O|<br> |O|O| | // 玩家 2 在 (1, 0)
落子.<br> |X| |X|<br> <br> toe.move(2, 1, 1); -&gt; 函数返回 1
(此时，玩家 1 赢得了该场比赛)<br> |X| |O|<br> |O|O| | // 玩家 1 在 (2,
1) 落子。<br> |X|X|X|<br></p>
</blockquote>
<p>348 是道加锁题，对于每次玩家的move，可以用1275第二种解法中的checkWin
函数。下面代码给出了另一种基于1275解法一的方法：保存八个关键变量，每次落子后更新这个子所关联的某几个变量。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicTacToe</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n:<span class="hljs-built_in">int</span></span>):</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Initialize your data structure here.</span></span><br><span class="line"><span class="hljs-string">        :type n: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        self.row, self.col, self.diag1, self.diag2, self.n = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self, row:<span class="hljs-built_in">int</span>, col:<span class="hljs-built_in">int</span>, player:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Player {player} makes a move at ({row}, {col}).</span></span><br><span class="line"><span class="hljs-string">        @param row The row of the board.</span></span><br><span class="line"><span class="hljs-string">        @param col The column of the board.</span></span><br><span class="line"><span class="hljs-string">        @param player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="hljs-string">        @return The current winning condition, can be either:</span></span><br><span class="line"><span class="hljs-string">                0: No one wins.</span></span><br><span class="line"><span class="hljs-string">                1: Player 1 wins.</span></span><br><span class="line"><span class="hljs-string">                2: Player 2 wins.</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> player == <span class="hljs-number">2</span>:</span><br><span class="line">            player = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="hljs-keyword">if</span> row == col:</span><br><span class="line">            self.diag1 += player</span><br><span class="line">        <span class="hljs-keyword">if</span> row + col == self.n - <span class="hljs-number">1</span>:</span><br><span class="line">            self.diag2 += player</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> self.n <span class="hljs-keyword">in</span> [self.row[row], self.col[col], self.diag1, self.diag2]:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> -self.n <span class="hljs-keyword">in</span> [self.row[row], self.col[col], self.diag1, self.diag2]:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="井字棋最佳策略">井字棋最佳策略</h2>
<p>井字棋的规模可以很自然的扩展成四子棋或五子棋等，区别在于棋盘大小和胜利时的连子数量。这类游戏最一般的形式为
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M,n,k-game">M,n,k-game</a>，中文可能翻译为战略井字游戏，表示棋盘大小为M
x N，当k连子时获胜。
下面的ConnectNGame类实现了战略井字游戏（M=N）中，两个玩家轮流下子、更新棋盘状态和判断每次落子输赢等逻辑封装。其中undo方法用于撤销最后一个落子，方便在后续寻找最佳策略时回溯。</p>
<h3 id="connectngame">ConnectNGame</h3>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectNGame</span>:</span></span><br><span class="line"></span><br><span class="line">    PLAYER_A = <span class="hljs-number">1</span></span><br><span class="line">    PLAYER_B = -<span class="hljs-number">1</span></span><br><span class="line">    AVAILABLE = <span class="hljs-number">0</span></span><br><span class="line">    RESULT_TIE = <span class="hljs-number">0</span></span><br><span class="line">    RESULT_A_WIN = <span class="hljs-number">1</span></span><br><span class="line">    RESULT_B_WIN = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N:<span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, board_size:<span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> N &lt;= board_size</span><br><span class="line">        self.N = N</span><br><span class="line">        self.board_size = board_size</span><br><span class="line">        self.board = [[ConnectNGame.AVAILABLE] * board_size <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(board_size)]</span><br><span class="line">        self.gameOver = <span class="hljs-literal">False</span></span><br><span class="line">        self.gameResult = <span class="hljs-literal">None</span></span><br><span class="line">        self.currentPlayer = ConnectNGame.PLAYER_A</span><br><span class="line">        self.remainingPosNum = board_size * board_size</span><br><span class="line">        self.actionStack = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param r:</span></span><br><span class="line"><span class="hljs-string">        :param c:</span></span><br><span class="line"><span class="hljs-string">        :return: None: game ongoing</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> self.board[r][c] == ConnectNGame.AVAILABLE</span><br><span class="line">        self.board[r][c] = self.currentPlayer</span><br><span class="line">        self.actionStack.append((r, c))</span><br><span class="line">        self.remainingPosNum -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.checkWin(r, c):</span><br><span class="line">            self.gameOver = <span class="hljs-literal">True</span></span><br><span class="line">            self.gameResult = self.currentPlayer</span><br><span class="line">            <span class="hljs-keyword">return</span> self.currentPlayer</span><br><span class="line">        <span class="hljs-keyword">if</span> self.remainingPosNum == <span class="hljs-number">0</span>:</span><br><span class="line">            self.gameOver = <span class="hljs-literal">True</span></span><br><span class="line">            self.gameResult = ConnectNGame.RESULT_TIE</span><br><span class="line">            <span class="hljs-keyword">return</span> ConnectNGame.RESULT_TIE</span><br><span class="line">        self.currentPlayer *= -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">undo</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.actionStack) &gt; <span class="hljs-number">0</span>:</span><br><span class="line">            lastAction = self.actionStack.pop()</span><br><span class="line">            r, c = lastAction</span><br><span class="line">            self.board[r][c] = ConnectNGame.AVAILABLE</span><br><span class="line">            self.currentPlayer = ConnectNGame.PLAYER_A <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.actionStack) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> ConnectNGame.PLAYER_B</span><br><span class="line">            self.remainingPosNum += <span class="hljs-number">1</span></span><br><span class="line">            self.gameOver = <span class="hljs-literal">False</span></span><br><span class="line">            self.gameResult = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'No lastAction'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getAvailablePositions</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> [(i,j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size) <span class="hljs-keyword">if</span> self.board[i][j] == ConnectNGame.AVAILABLE]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getStatus</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>([<span class="hljs-built_in">tuple</span>(self.board[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size)])</span><br></pre></td></tr></tbody></table></figure>
<p>其中checkWin和1275解法二中的逻辑一致。</p>
<h3 id="minimax-算法">Minimax 算法</h3>
<p>此战略井字游戏的逻辑代码，结合之前的minimax算法，可以实现游戏最佳策略。</p>
<p>先定义一个通用的策略基类和抽象方法
action。action表示给定一个棋盘状态，返回一个动作决定。返回Tuple的第一个int值表示估计走这一步的结局，第二个值类型是Tuple[int,
int]，表示这次落子的位置，例如（1，1）。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>(<span class="hljs-params">ABC</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @abstractmethod</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
MinimaxStrategy
的逻辑和之前的minimax模版算法大致相同，多了保存最佳move对应的动作，用于最后返回。
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinimaxStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = copy.deepcopy(game)</span><br><span class="line">        result, move = self.minimax()</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax()</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax()</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br></pre></td></tr></tbody></table></figure>
通过上面的代码可以画出初始两步的井字棋最终结局。对于先手O来说可以落9个位置，排除对称位置后只有三种，分别为角落，边上和正中。但无论哪一个位置作为先手，最好的结局都是被对方逼平，不存在必赢的开局。所以井字棋的结局是：如果两个玩家都采用最优策略（无失误），游戏结果为双方逼平。
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_1.gv.svg">
<figcaption>
井字棋第一步结局
</figcaption>
</figure>
下面分别画出三种开局后进一步的游戏结局。
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_1.gv.svg">
<figcaption>
井字棋角落开局
</figcaption>
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_2.gv.svg">
<figcaption>
井字棋边上开局
</figcaption>
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_3.gv.svg">
<figcaption>
井字棋中间开局
</figcaption>
</figure>
<h3 id="井字棋游戏状态数和解">井字棋游戏状态数和解</h3>
<p>有趣的是井字棋游戏的状态数量，简单的上限估算是<span class="math inline">\(3^9=19683\)</span>。这显然是个较宽泛的上限，因为很多状态在游戏结束后无法达到。
这篇文章 <a target="_blank" rel="noopener" href="http://www.mathrec.org/old/2002jan/solutions.html">Tic-Tac-Toe
(Naughts and Crosses, Cheese and Crackers, etc</a>
中列出了每一步的状态数，合计5478个。</p>
<table>
<thead>
<tr class="header">
<th>Moves</th>
<th>Positions</th>
<th>Terminal Positions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>9</td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td>72</td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td>252</td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>756</td>
<td></td>
</tr>
<tr class="even">
<td>5</td>
<td>1260</td>
<td>120</td>
</tr>
<tr class="odd">
<td>6</td>
<td>1520</td>
<td>148</td>
</tr>
<tr class="even">
<td>7</td>
<td>1140</td>
<td>444</td>
</tr>
<tr class="odd">
<td>8</td>
<td>390</td>
<td>168</td>
</tr>
<tr class="even">
<td>9</td>
<td>78</td>
<td>78</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>5478</td>
<td>958</td>
</tr>
</tbody>
</table>
<p>我们已经实现了井字棋的minimax策略，算法本质上遍历了所有情况，稍加改造后增加dp数组，就可以确认上面的总状态数。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingMinimaxStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = copy.deepcopy(game)</span><br><span class="line">        self.dpMap = {}</span><br><span class="line">        result, move = self.minimax(game.getStatus())</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-comment"># print(f'Current {len(strategy.dpMap)}')</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> gameStatus <span class="hljs-keyword">in</span> self.dpMap:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.dpMap[gameStatus]</span><br><span class="line"></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax(game.getStatus())</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, oppMove</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, move</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">            self.dpMap[gameStatus] = ret, bestMove</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax(game.getStatus())</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, oppMove</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, move</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">            self.dpMap[gameStatus] = ret, bestMove</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    tic_tac_toe = ConnectNGame(N=<span class="hljs-number">3</span>, board_size=<span class="hljs-number">3</span>)</span><br><span class="line">    strategy = CountingMinimaxStrategy()</span><br><span class="line">    strategy.action(tic_tac_toe)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Game States Number <span class="hljs-subst">{<span class="hljs-built_in">len</span>(strategy.dpMap)}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>运行程序证实了井字棋状态数为5478，下面是一些极小规模时代码运行结果：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>3x3</th>
<th>4x4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k=3</td>
<td>5478 （Draw)</td>
<td>6035992 （Win）</td>
</tr>
<tr class="even">
<td>k=4</td>
<td></td>
<td>9722011 （Draw）</td>
</tr>
<tr class="odd">
<td>k=5</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M,n,k-game">Wikipedia
M,n,k-game</a>, 列出了一些小规模下的游戏解：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>3x3</th>
<th>4x4</th>
<th>5x5</th>
<th>6x6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k=3</td>
<td>Draw</td>
<td>Win</td>
<td>Win</td>
<td>Win</td>
</tr>
<tr class="even">
<td>k=4</td>
<td></td>
<td>Draw</td>
<td>Draw</td>
<td>Win</td>
</tr>
<tr class="odd">
<td>k=5</td>
<td></td>
<td></td>
<td>Draw</td>
<td>Draw</td>
</tr>
</tbody>
</table>
<p>值得一提的是，五子棋（棋盘15x15或以上）被 L. Victor
Allis证明是先手赢。</p>
<h3 id="alpha-beta剪枝策略">Alpha-Beta剪枝策略</h3>
<p>Alpha Beta 剪枝策略的代码如下（和之前代码比较类似，不再赘述）：
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlphaBetaStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = game</span><br><span class="line">        result, move = self.alpha_beta(self.game.getStatus(), -math.inf, math.inf)</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]], alpha:<span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span>, beta:<span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.alpha_beta(game.getStatus(), alpha, beta)</span><br><span class="line">                game.undo()</span><br><span class="line">                alpha = <span class="hljs-built_in">max</span>(alpha, result)</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.alpha_beta(game.getStatus(), alpha, beta)</span><br><span class="line">                game.undo()</span><br><span class="line">                beta = <span class="hljs-built_in">min</span>(beta, result)</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Alpha Beta
的DP版本中，由于lru_cache无法指定cache的有效参数，递归函数并没有传入alpha,
beta。因此我们将alpha，beta参数隐式放入自己维护的栈中，并保证栈的状态和alpha_beta_dp函数调用状态一致。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlphaBetaDPStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = game</span><br><span class="line">        self.alphaBetaStack = [(-math.inf, math.inf)]</span><br><span class="line">        result, move = self.alpha_beta_dp(self.game.getStatus())</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta_dp</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        alpha, beta = self.alphaBetaStack[-<span class="hljs-number">1</span>]</span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    self.alphaBetaStack.append((alpha, beta))</span><br><span class="line">                    result, oppMove = self.alpha_beta_dp(game.getStatus())</span><br><span class="line">                    self.alphaBetaStack.pop()</span><br><span class="line">                game.undo()</span><br><span class="line">                alpha = <span class="hljs-built_in">max</span>(alpha, result)</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    self.alphaBetaStack.append((alpha, beta))</span><br><span class="line">                    result, oppMove = self.alpha_beta_dp(game.getStatus())</span><br><span class="line">                    self.alphaBetaStack.pop()</span><br><span class="line">                game.undo()</span><br><span class="line">                beta = <span class="hljs-built_in">min</span>(beta, result)</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br></pre></td></tr></tbody></table></figure><p></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-1-minimax/" itemprop="url">组合游戏系列1: Leetcode中的Minimax 和 Alpha Beta剪枝</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-06-26T18:45:01.000Z" itemprop="datePublished">6月 27 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            31 分钟 读完 (约 4610 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>本系列，我们来看看在一种常见的组合游戏——回合制棋盘类游戏中，如何用算法来解决问题。首先，我们会介绍并解决搜索空间较小的问题，引入经典的博弈算法和相关理论，最终实现在大搜索空间中的Deep
RL近似算法。在此基础上可以理解AlphaGo的原理和工作方式。
本系列的第一篇，我们介绍3个Leetcode中的零和回合制游戏，从最初的暴力解法，到动态规划最终演变成博弈论里的经典算法：
minimax 以及 alpha beta 剪枝。</p>
<ul>
<li><p><strong><a href="/zh/2020/combinatorial-game-1-minimax/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></strong></p></li>
<li><p><a href="/zh/2020/combinatorial-game-1-minimax/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-1-minimax/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-1-minimax/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-1-minimax/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></p></li>
</ul>
<h2 id="leetcode-292-nim-game-简单">Leetcode 292 Nim Game (简单)</h2>
<p>简单题 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/nim-game/">Leetcode 292
Nim Game</a>。</p>
<blockquote>
<p>你和你的朋友，两个人一起玩
Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。你作为先手。<br>
你们是聪明人，每一步都是最优解。
编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
</blockquote>
<blockquote>
<p>示例:<br> 输入: 4<br> 输出: false <br> 解释: 如果堆中有 4
块石头，那么你永远不会赢得比赛；因为无论你拿走 1 块、2 块 还是 3
块石头，最后一块石头总是会被你的朋友拿走。</p>
</blockquote>
<p>定义 <span class="math inline">\(f(n)\)</span> 为有<span class="math inline">\(n\)</span>个石头并采取最优策略的游戏结果， <span class="math inline">\(f(n)\)</span>的值只有可能是赢或者输。考察前几个结果：<span class="math inline">\(f(1) = f(2) = f(3) = Win\)</span>，然后来计算<span class="math inline">\(f(4)\)</span>。因为玩家采取最优策略（只要有一种走法让对方必输，玩家获胜），对于4来说，玩家能走的可能是拿掉1块、2块或3块，但是无论剩余何种局面，对方都是必赢，因此，4就是必输。总的说来，递归关系如下：
<span class="math display">\[
f(n) = \neg (f(n-1) \land f(n-2) \land f(n-3))
\]</span></p>
这个递归式可以直接翻译成Python 3代码 <figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># TLE</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(exponential)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution_BruteForce</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.canWinNim(n - i):</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></tbody></table></figure>
以上的递归公式和代码很像fibonacci数的递归定义和暴力解法，因此对应的时间复杂度也是指数级的，提交代码以后会TLE。下图画出了当n=7时的递归调用，注意
5 被扩展向下重复执行了两次，4重复了4次。
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/nim_7_brute.gv.svg">
<figcaption>
292 Nim Game 暴力解法调用图 n=7
</figcaption>
</figure>
我们采用和fibonacci一样的方式来优化算法：缓存较小n的结果以此来计算较大n的结果。
Python 中，我们可以只加一行<strong>lru_cache</strong>
decorator，来取得这种动态规划效果，下面的代码将复杂度降到了 <span class="math inline">\(O(N)\)</span>。 <figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># RecursionError: maximum recursion depth exceeded in comparison n=1348820612</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(N)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution_DP</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.canWinNim(n - i):</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></tbody></table></figure>
再来画出调用图：这次5和4就不再被展开重复计算，图中绿色的节点表示缓存命中。
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/nim_7_dp.gv.svg">
<figcaption>
292 Nim Game 动归解法调用图 n=7
</figcaption>
</figure>
<p>但还是没有AC，因为当n=1348820612时，这种方式会导致栈溢出。再改成下面的循环版本，可惜还是TLE。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># TLE for 1348820612</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(N)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        last3, last2, last1 = <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>, n+<span class="hljs-number">1</span>):</span><br><span class="line">            this = <span class="hljs-keyword">not</span> (last3 <span class="hljs-keyword">and</span> last2 <span class="hljs-keyword">and</span> last1)</span><br><span class="line">            last3, last2, last1 = last2, last1, this</span><br><span class="line">        <span class="hljs-keyword">return</span> last1</span><br></pre></td></tr></tbody></table></figure>
<p>由此看来，AC 版本需要低于<span class="math inline">\(O(n)\)</span>的算法复杂度。上面的写法似乎暗示输赢有周期性的规律。事实上，如果将输赢按照顺序画出来，就马上得出规律了：只要<span class="math inline">\(n \mod 4 = 0\)</span>
就是输，否则赢。原因如下：当面临不能被4整除的数量时 <span class="math inline">\(4k+i (i=1,2,3)\)</span> ，一方总是可以拿走 <span class="math inline">\(i\)</span> 个，将<span class="math inline">\(4k\)</span>
留给对手，而对方下轮又将返回不能被4整除的数，如此循环往复，直到这一方有1,
2, 3 个，最终获胜。</p>
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/nim_plot.png">
<figcaption>
输赢分布
</figcaption>
</figure>
<p>最终AC版本，只有一句语句。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canWinNim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> (n % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="leetcode-486-predict-the-winner-中等">Leetcode 486 Predict the
Winner (中等)</h2>
<p>中等难度题目： <a target="_blank" rel="noopener" href="https://leetcode.com/problems/predict-the-winner/">Leetcode 486
Predict the Winner</a>.</p>
<blockquote>
<p>给定一个表示分数的非负整数数组。
玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>
给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<blockquote>
<p>示例 1:<br> 输入: [1, 5, 2]<br> 输出: False<br> 解释:
一开始，玩家1可以从1和2中进行选择。<br>
如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>
所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>
因此，玩家1永远不会成为赢家，返回 False。<br></p>
</blockquote>
<blockquote>
<p>示例 2:<br> 输入: [1, 5, 233, 7]<br> 输出: True<br> 解释:
玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。<br>
最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回
True，表示玩家1可以成为赢家。<br></p>
</blockquote>
<p>对于当前玩家，他有两种选择：左边或者右边的数。定义 maxDiff(l, r)
为剩余子数组<span class="math inline">\([l,r]\)</span>时，当前玩家能取得的最大分差，那么</p>
<p><span class="math display">\[
\begin{equation*}
  \operatorname{maxDiff}(l, r) = \max
    \begin{cases}
      nums[l] - \operatorname{maxDiff}(l + 1, r)\\\\
      nums[r] - \operatorname{maxDiff}(l, r - 1)
    \end{cases}       
\end{equation*}
\]</span></p>
<p>对应的时间复杂度可以写出递归式，显然是指数级的： <span class="math display">\[
f(n) = 2f(n-1) = O(2^n)
\]</span></p>
<p>采用暴力解法可以AC，但运算时间很长，接近TLE边缘 (6300ms)。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(2^N)</span></span><br><span class="line"><span class="hljs-comment"># Slow: 6300ms</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDiff</span>(<span class="hljs-params">self, l: <span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> l == r:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.nums[l]</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.nums[l] - self.maxDiff(l + <span class="hljs-number">1</span>, r), self.nums[r] - self.maxDiff(l, r - <span class="hljs-number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PredictTheWinner</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        <span class="hljs-keyword">return</span> self.maxDiff(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure><p></p>
从调用图也很容易看出是指数级的复杂度
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/486_predict_winner_brute.gv.svg">
<figcaption>
486 Predict the Winner 暴力解法调用图 n=4
</figcaption>
</figure>
<p>上图中我们有重复计算的节点，例如[1-2]节点被计算了两次。使用 lru_cache
大法，在maxDiff 上仅加了一句，就能以复杂度 <span class="math inline">\(O(n^2)\)</span>和运行时间 43ms AC。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O(N^2)</span></span><br><span class="line"><span class="hljs-comment"># Fast: 43ms</span></span><br><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDiff</span>(<span class="hljs-params">self, l: <span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> l == r:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.nums[l]</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.nums[l] - self.maxDiff(l + <span class="hljs-number">1</span>, r), self.nums[r] - self.maxDiff(l, r - <span class="hljs-number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PredictTheWinner</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        <span class="hljs-keyword">return</span> self.maxDiff(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure>
动态规划解法调用图可以看出节点 [1-2] 这次没有被计算两次。
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/486_predict_winner_dp.gv.svg">
<figcaption>
486 Predict the Winner 动归解法调用图 n=4
</figcaption>
</figure>
<h2 id="leetcode-464-can-i-win-中等">Leetcode 464 Can I Win (中等)</h2>
<p>类似但稍有难度的题目 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/can-i-win/">Leetcode 464 Can I
Win</a>。难点在于使用了位的状态压缩。</p>
<blockquote>
<p>在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10
的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。<br>
如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？<br>
例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15
的整数（不放回），直到累计整数和 &gt;= 100。<br> 给定一个整数
maxChoosableInteger （整数池中可选择的最大数）和另一个整数
desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？<br>
你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于
300。</p>
</blockquote>
<blockquote>
<p>示例：<br> 输入：<br> maxChoosableInteger = 10<br> desiredTotal =
11<br> 输出：<br> false<br> 解释：<br>
无论第一个玩家选择哪个整数，他都会失败。<br> 第一个玩家可以选择从 1 到
10 的整数。<br> 如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10
的整数。<br> 第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;=
desiredTotal），从而取得胜利.<br>
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></p>
</blockquote>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-comment"># Time Complexity: O:(2^m*m), m: maxChoosableInteger</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">self, status: <span class="hljs-built_in">int</span>, currentTotal: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.maxChoosableInteger + <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (status &gt;&gt; i &amp; <span class="hljs-number">1</span>):</span><br><span class="line">                new_status = <span class="hljs-number">1</span> &lt;&lt; i | status</span><br><span class="line">                <span class="hljs-keyword">if</span> currentTotal + i &gt;= self.desiredTotal:</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.recurse(new_status, currentTotal + i):</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canIWin</span>(<span class="hljs-params">self, maxChoosableInteger: <span class="hljs-built_in">int</span>, desiredTotal: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        self.maxChoosableInteger = maxChoosableInteger</span><br><span class="line">        self.desiredTotal = desiredTotal</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">sum</span> = maxChoosableInteger * (maxChoosableInteger + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &lt; desiredTotal:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.recurse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码算法复杂度为<span class="math inline">\(O(m
2^m)\)</span>，m是maxChoosableInteger。由于所有状态的数量是<span class="math inline">\(2^m\)</span>，对于每个状态，最多会尝试 <span class="math inline">\(m\)</span> 走法。</p>
<h2 id="minimax-算法">Minimax 算法</h2>
<p>至此，我们AC了leetcode中的几道零和回合制博弈游戏。事实上，在这个领域有通用的算法：回合制博弈下的minimax。算法背景如下，两个玩家轮流玩，第一个玩家max的目的是将游戏的效用最大化，第二个玩家min则是最小化效用。比如，下面的节点表示玩家选取节点后游戏的效用，当两个玩家都能采取最优策略，Minimax
算法从底层节点来计算，游戏的结果是最终max 玩家会得到-7。</p>
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/Minimax.svg">
<figcaption>
Wikipedia Minimax 例子
</figcaption>
</figure>
<p>Minimax Python 3伪代码如下。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">node: Node, depth: <span class="hljs-built_in">int</span>, maximizingPlayer: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> depth == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> is_terminal(node):</span><br><span class="line">        <span class="hljs-keyword">return</span> evaluate_terminal(node)</span><br><span class="line">    <span class="hljs-keyword">if</span> maximizingPlayer:</span><br><span class="line">        value:<span class="hljs-built_in">int</span> = −∞</span><br><span class="line">        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node:</span><br><span class="line">            value = <span class="hljs-built_in">max</span>(value, minimax(child, depth − <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>))</span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br><span class="line">    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># minimizing player</span></span><br><span class="line">        value := +∞</span><br><span class="line">        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node:</span><br><span class="line">            value = <span class="hljs-built_in">min</span>(value, minimax(child, depth − <span class="hljs-number">1</span>, <span class="hljs-literal">True</span>))</span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>
<h3 id="minimax-486-predict-the-winner">Minimax: 486 Predict the
Winner</h3>
<p>我们知道486 Predict the Winner
是有minimax解法的，但如何具体实现，其难点在于如何定义合适的游戏价值或者效用。之前的解法中，我们定义maxDiff(l,
r) 来表示当前玩家面临子区间 <span class="math inline">\([l, r]\)</span>
时能取得的最大分差。对于minimax算法，max
玩家要最大化游戏价值，min玩家要最小化游戏价值。先考虑最简单情况即只有一个数x时，若定义max玩家在此局面下得到这个数时游戏价值为
+x，则min玩家为-x，即max玩家得到的所有数为正（<span class="math inline">\(+a_1 + a_2 + ... =
A\)</span>），min玩家得到的所有数为负（<span class="math inline">\(-b_1
- b_2 - ... = -B\)</span>）。至此，max玩家的目标就是 <span class="math inline">\(max(A-B)\)</span> ，min玩家是 <span class="math inline">\(min(A-B)\)</span>。有了精确的定义和优化目标，代码只需要套一下上面的模版。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># max_player: max(A - B)</span></span><br><span class="line">    <span class="hljs-comment"># min_player: min(A - B)</span></span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span>, isMaxPlayer: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> l == r:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.nums[l] * (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> isMaxPlayer <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> isMaxPlayer:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(</span><br><span class="line">                self.nums[l] + self.minimax(l + <span class="hljs-number">1</span>, r, <span class="hljs-keyword">not</span> isMaxPlayer),</span><br><span class="line">                self.nums[r] + self.minimax(l, r - <span class="hljs-number">1</span>, <span class="hljs-keyword">not</span> isMaxPlayer))</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(</span><br><span class="line">                -self.nums[l] + self.minimax(l + <span class="hljs-number">1</span>, r, <span class="hljs-keyword">not</span> isMaxPlayer),</span><br><span class="line">                -self.nums[r] + self.minimax(l, r - <span class="hljs-number">1</span>, <span class="hljs-keyword">not</span> isMaxPlayer))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PredictTheWinner</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        v = self.minimax(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>, <span class="hljs-literal">True</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> v &gt;= <span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/486_minimax.gv.svg">
<figcaption>
Minimax 486 调用图 nums=[1, 5, 2, 4]
</figcaption>
</figure>
<h3 id="minimax-464-can-i-win">Minimax: 464 Can I Win</h3>
<p>该题目是很典型的此类游戏，即结果为赢输平，但是中间的状态没有直接对应的游戏价值。对于这样的问题，一般定义为，max玩家胜，价值
+1，min玩家胜，价值-1，平则0。下面的AC代码实现了 Minimax
算法。算法中针对两个玩家都有剪枝（没有剪枝无法AC）。具体来说，max玩家一旦在某一节点取得胜利(value=1)，就停止继续向下搜索，因为这是他能取得的最好分数。同理，min玩家一旦取得-1也直接返回上层节点。这个剪枝可以泛化成
alpha beta剪枝算法。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-comment"># currentTotal &lt; desiredTotal</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self, status: <span class="hljs-built_in">int</span>, currentTotal: <span class="hljs-built_in">int</span>, isMaxPlayer: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">import</span> math</span><br><span class="line">        <span class="hljs-keyword">if</span> status == self.allUsed:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># draw: no winner</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> isMaxPlayer:</span><br><span class="line">            value = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.maxChoosableInteger + <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (status &gt;&gt; i &amp; <span class="hljs-number">1</span>):</span><br><span class="line">                    new_status = <span class="hljs-number">1</span> &lt;&lt; i | status</span><br><span class="line">                    <span class="hljs-keyword">if</span> currentTotal + i &gt;= self.desiredTotal:</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># shortcut</span></span><br><span class="line">                    value = <span class="hljs-built_in">max</span>(value, self.minimax(new_status, currentTotal + i, <span class="hljs-keyword">not</span> isMaxPlayer))</span><br><span class="line">                    <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>:</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">return</span> value</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            value = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.maxChoosableInteger + <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (status &gt;&gt; i &amp; <span class="hljs-number">1</span>):</span><br><span class="line">                    new_status = <span class="hljs-number">1</span> &lt;&lt; i | status</span><br><span class="line">                    <span class="hljs-keyword">if</span> currentTotal + i &gt;= self.desiredTotal:</span><br><span class="line">                        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># shortcut</span></span><br><span class="line">                    value = <span class="hljs-built_in">min</span>(value, self.minimax(new_status, currentTotal + i, <span class="hljs-keyword">not</span> isMaxPlayer))</span><br><span class="line">                    <span class="hljs-keyword">if</span> value == -<span class="hljs-number">1</span>:</span><br><span class="line">                        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="alpha-beta-剪枝">Alpha-Beta 剪枝</h2>
<p>在464 Can I Win minimax
算法代码实现中，我们发现有剪枝优化空间。对于每个节点，定义两个值alpha 和
beta，表示从根节点到目前局面时，max玩家保证能取得的最小值以及min玩家能保证取得的最大值。初始时，根节点alpha
= −∞ ， beta = +∞，表示游戏最终的价值在区间 [−∞,
+∞]中。在向下遍历的过程中，子节点先继承父节点的 alpha beta
值进而继承区间 [alpha, beta]。当子节点在向下遍历的时候同步更新alpha 或者
beta，一旦区间[alpha,
beta]非法就立即向上返回。举个Wikimedia的例子来进一步说明：</p>
<ol type="1">
<li><p>根节点初始时： alpha = −∞, beta = +∞</p></li>
<li><p>根节点，最左边子节点返回4后： alpha = 4, beta = +∞</p></li>
<li><p>根节点，中间子节点返回5后： alpha = 5, beta = +∞</p></li>
<li><p>最右Min节点（标1节点），初始时： alpha = 5, beta = +∞</p></li>
<li><p>最右Min节点（标1节点），第一个子节点返回1后： alpha = 5, beta =
1</p></li>
</ol>
<p>此时，最右Min节点的alpha, beta形成了无效区间[5,
1]，满足了剪枝条件，因此可以不用计算它的第二个和第三个子节点。如果剩余子节点返回值
&gt;
1，比如2，由于这是个min节点，将会被已经到手的1替换。若其他子节点返回值
&lt; 1，但由于min的父节点有效区间是[5,
+∞]，已经保证了&gt;=5，小于5的值也会被忽略。</p>
<figure>
<img src="/zh/2020/combinatorial-game-1-minimax/Poda_alfa-beta.svg">
<figcaption>
Wikimedia Alpha Beta 剪枝例子
</figcaption>
</figure>
<p>Alpha Beta 剪枝 Python 3伪代码如下</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta</span>(<span class="hljs-params">node: Node, depth: <span class="hljs-built_in">int</span>, α: <span class="hljs-built_in">int</span>, β: <span class="hljs-built_in">int</span>, maximizingPlayer: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> depth == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> is_terminal(node):</span><br><span class="line">        <span class="hljs-keyword">return</span> evaluate_terminal(node)</span><br><span class="line">    <span class="hljs-keyword">if</span> maximizingPlayer:</span><br><span class="line">        value: <span class="hljs-built_in">int</span> = −∞</span><br><span class="line">        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node:</span><br><span class="line">            value = <span class="hljs-built_in">max</span>(value, alphabeta(child, depth − <span class="hljs-number">1</span>, α, β, <span class="hljs-literal">False</span>))</span><br><span class="line">            α = <span class="hljs-built_in">max</span>(α, value)</span><br><span class="line">            <span class="hljs-keyword">if</span> α &gt;= β:</span><br><span class="line">                <span class="hljs-keyword">break</span> <span class="hljs-comment"># β cut-off</span></span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        value: <span class="hljs-built_in">int</span> = +∞</span><br><span class="line">        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node:</span><br><span class="line">            value = <span class="hljs-built_in">min</span>(value, alphabeta(child, depth − <span class="hljs-number">1</span>, α, β, <span class="hljs-literal">True</span>))</span><br><span class="line">            β = <span class="hljs-built_in">min</span>(β, value)</span><br><span class="line">            <span class="hljs-keyword">if</span> β &lt;= α:</span><br><span class="line">                <span class="hljs-keyword">break</span> <span class="hljs-comment"># α cut-off</span></span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>
<h3 id="alpha-beta-pruning-486-predict-the-winner">Alpha-Beta Pruning:
486 Predict the Winner</h3>
<p>用 Alpha-Beta 剪枝 再次AC 486。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta</span>(<span class="hljs-params">self, l: <span class="hljs-built_in">int</span>, r: <span class="hljs-built_in">int</span>, curr: <span class="hljs-built_in">int</span>, isMaxPlayer: <span class="hljs-built_in">bool</span>, alpha: <span class="hljs-built_in">int</span>, beta: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> l == r:</span><br><span class="line">            <span class="hljs-keyword">return</span> curr + self.nums[l] * (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> isMaxPlayer <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> isMaxPlayer:</span><br><span class="line">            ret = self.alpha_beta(l + <span class="hljs-number">1</span>, r, curr + self.nums[l], <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta)</span><br><span class="line">            alpha = <span class="hljs-built_in">max</span>(alpha, ret)</span><br><span class="line">            <span class="hljs-keyword">if</span> alpha &gt;= beta:</span><br><span class="line">                <span class="hljs-keyword">return</span> alpha</span><br><span class="line">            ret = <span class="hljs-built_in">max</span>(ret, self.alpha_beta(l, r - <span class="hljs-number">1</span>, curr + self.nums[r], <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta))</span><br><span class="line">            <span class="hljs-keyword">return</span> ret</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = self.alpha_beta(l + <span class="hljs-number">1</span>, r, curr - self.nums[l], <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta)</span><br><span class="line">            beta = <span class="hljs-built_in">min</span>(beta, ret)</span><br><span class="line">            <span class="hljs-keyword">if</span> alpha &gt;= beta:</span><br><span class="line">                <span class="hljs-keyword">return</span> beta</span><br><span class="line">            ret = <span class="hljs-built_in">min</span>(ret, self.alpha_beta(l, r - <span class="hljs-number">1</span>, curr - self.nums[r], <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta))</span><br><span class="line">            <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PredictTheWinner</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        v = self.alpha_beta(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">True</span>, -math.inf, math.inf)</span><br><span class="line">        <span class="hljs-keyword">return</span> v &gt;= <span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="alpha-beta-pruning-464-can-i-win">Alpha-Beta Pruning: 464 Can I
Win</h3>
<p>464 Alpha-Beta 剪枝版本。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache</span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-comment"># currentTotal &lt; desiredTotal</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta</span>(<span class="hljs-params">self, status: <span class="hljs-built_in">int</span>, currentTotal: <span class="hljs-built_in">int</span>, isMaxPlayer: <span class="hljs-built_in">bool</span>, alpha: <span class="hljs-built_in">int</span>, beta: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-keyword">import</span> math</span><br><span class="line">        <span class="hljs-keyword">if</span> status == self.allUsed:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># draw: no winner</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> isMaxPlayer:</span><br><span class="line">            value = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.maxChoosableInteger + <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (status &gt;&gt; i &amp; <span class="hljs-number">1</span>):</span><br><span class="line">                    new_status = <span class="hljs-number">1</span> &lt;&lt; i | status</span><br><span class="line">                    <span class="hljs-keyword">if</span> currentTotal + i &gt;= self.desiredTotal:</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># shortcut</span></span><br><span class="line">                    value = <span class="hljs-built_in">max</span>(value, self.alpha_beta(new_status, currentTotal + i, <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta))</span><br><span class="line">                    alpha = <span class="hljs-built_in">max</span>(alpha, value)</span><br><span class="line">                    <span class="hljs-keyword">if</span> alpha &gt;= beta:</span><br><span class="line">                        <span class="hljs-keyword">return</span> value</span><br><span class="line">            <span class="hljs-keyword">return</span> value</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            value = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.maxChoosableInteger + <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (status &gt;&gt; i &amp; <span class="hljs-number">1</span>):</span><br><span class="line">                    new_status = <span class="hljs-number">1</span> &lt;&lt; i | status</span><br><span class="line">                    <span class="hljs-keyword">if</span> currentTotal + i &gt;= self.desiredTotal:</span><br><span class="line">                        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># shortcut</span></span><br><span class="line">                    value = <span class="hljs-built_in">min</span>(value, self.alpha_beta(new_status, currentTotal + i, <span class="hljs-keyword">not</span> isMaxPlayer, alpha, beta))</span><br><span class="line">                    beta = <span class="hljs-built_in">min</span>(beta, value)</span><br><span class="line">                    <span class="hljs-keyword">if</span> alpha &gt;= beta:</span><br><span class="line">                        <span class="hljs-keyword">return</span> value</span><br><span class="line">            <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>
<h2 id="c-java-javascript-ac-486-predict-the-winner">C++, Java,
Javascript AC 486 Predict the Winner</h2>
<p>最后介绍一种不同的DP实现：用C++, Java, Javascript
实现自底向上的DP解法来AC leetcode
486，当然其他语言没有Python的lru_cache大法。以下实现中，注意DP解的构建顺序，先解决小规模的问题，并在此基础上计算稍大的问题。值得一提的是，以下的循环写法严格保证了
<span class="math inline">\(n^2\)</span>
次循环，但是自顶向下的计划递归可能会少于 <span class="math inline">\(n^2\)</span>次循环。</p>
<h3 id="java-ac-code">Java AC Code</h3>
<figure class="highlight java hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = n - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) {</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = l + <span class="hljs-number">1</span>; r &lt; n; r++) {</span><br><span class="line">                dp[l][r] = Math.max(</span><br><span class="line">                        nums[l] - dp[l + <span class="hljs-number">1</span>][r],</span><br><span class="line">                        nums[r] - dp[l][r - <span class="hljs-number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="c-ac-code">C++ AC Code</h3>
<figure class="highlight c++ hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {</span><br><span class="line">          dp[i][i] = nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = n - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) {</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = l + <span class="hljs-number">1</span>; r &lt; n; r++) {</span><br><span class="line">                dp[l][r] = <span class="hljs-built_in">max</span>(nums[l] - dp[l + <span class="hljs-number">1</span>][r], nums[r] - dp[l][r - <span class="hljs-number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="javascript-ac-code">Javascript AC Code</h3>
<figure class="highlight javascript hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">{number[]}</span> <span class="hljs-variable">nums</span></span></span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">{boolean}</span></span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">var</span> PredictTheWinner = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill().map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {</span><br><span class="line">      dp[i][i] = nums[i];</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = n - <span class="hljs-number">1</span>; l &gt;=<span class="hljs-number">0</span>; l--) {</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = i + <span class="hljs-number">1</span>; r &lt; n; r++) {</span><br><span class="line">            dp[l][r] = <span class="hljs-built_in">Math</span>.max(nums[l] - dp[l + <span class="hljs-number">1</span>][r],nums[r] - dp[l][r - <span class="hljs-number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>] &gt;=<span class="hljs-number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/tags/Python/page/2/">上一页</a>
    </div>
    <div class="pagination-next is-invisible is-hidden-mobile">
        <a href="/tags/Python/page/4/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/tags/Python/">1</a></li>
        
        <li><a class="pagination-link" href="/tags/Python/page/2/">2</a></li>
        
        <li><a class="pagination-link is-current" href="/tags/Python/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2023 MyEncyclopedia&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true" aria-controls="dropdown-menu7">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>简体中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu">
            <div class="dropdown-content">
            
                <a href="/tags/Python/page/3/" class="dropdown-item">
                    简体中文
                </a>
            
                <a href="/en/tags/Python/page/3/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<style>
 .katex-display {
    overflow-x: auto;
    overflow-y: hidden;
    height: 100%;
  }
</style>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        // ...options...
    });
});
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>