<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>标签: Reinforcement Learning - MyEncyclopedia</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">


<link href="/en/tags/Reinforcement-Learning/page/2/" rel="alternate" hreflang="en" />
    


<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="MyEncyclopedia">
<meta property="og:url" content="https://myencyclopedia.github.io/tags/Reinforcement-Learning/page/2/">
<meta property="og:site_name" content="MyEncyclopedia">
<meta property="og:locale">
<meta property="article:author" content="MyEncyclopedia">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://myencyclopedia.github.io">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#Reinforcement Learning</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/rl-sutton-blackjack-1/" itemprop="url">通过代码学Sutton强化学习3：21点游戏的策略蒙特卡洛值预测</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-09-25T18:45:01.000Z" itemprop="datePublished">9月 26 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2814 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>从这期开始我们进入Sutton强化学习第二版，第五章蒙特卡洛方法。蒙特卡洛方法是一种在工程各领域都存在的基本方法，在强化领域中，其特点是无需知道环境的dynamics，只需不断模拟记录并分析数据即可逼近理论真实值。蒙特卡洛方法本篇将会用21点游戏作为示例来具体讲解其原理和代码实现。</p>
<h2 id="点游戏问题">21点游戏问题</h2>
<p>21点游戏是一个经典的赌博游戏。大致规则是玩家和庄家各发两张牌，一张明牌，一张暗牌。玩家和庄家可以决定加牌或停止加牌，新加的牌均为暗牌，最后比较两个玩家的牌面和，更接近21点的获胜。游戏的变化因素是牌Ace，既可以作为11也可以作为1来计算，算作11的时候称作usable。</p>
<p>Sutton教材中的21点游戏规则简化了几个方面用于控制问题状态数：</p>
<ul>
<li>已发的牌的无状态性：和一副牌的21点游戏不同的是，游戏环境简化为牌是可以无穷尽被补充的，一副牌的某一张被派发后，同样的牌会被补充进来，或者可以认为每次发放的牌都是从一副新牌中抽出的。统计学中的术语称为重复采样（sample
with replacement）。这种规则下极端情况下，玩家可以拥有
5个A或者5个2。另外，这会导致玩家无法通过开局看到的3张牌的信息推断后续发牌的概率，如此就大规模减小了游戏状态数。</li>
<li>庄家和玩家独立游戏，无需按轮次要牌。开局给定4张牌后，玩家先行动，加牌直至超21点或者停止要牌，如果超21点，玩家输，否则，等待庄家行动，庄家加牌直至超21点或者停止要牌，如果超21点，庄家输，否则比较两者的总点数。这种方式可以认为当玩家和庄家看到初始的三张牌后独立做一系列决策，最后比较结果，避免了交互模式下因为能观察到每一轮后对方牌数变化产生额外的信息而导致的游戏状态数爆炸。</li>
</ul>
<p>有以上两个规则的简化，21点游戏问题的总状态数有下面三个维度</p>
<ul>
<li><p>自己手中的点数和（12到21）</p></li>
<li><p>庄家明牌的点数（A到10)</p></li>
<li><p>庄家明牌是否有 A（True, False）。</p></li>
</ul>
<p>状态总计总数为三个维度的乘积 10 * 10 * 2 = 200。</p>
<p>关于游戏状态有几个比较subtle的假设或者要素。首先，玩家初始时能看到三张牌，这三张牌确定了状态的三个维度的值，当然也就确定了Agent的初始状态，随后按照独立游戏的规则进行，玩家根据初始状态依照某种策略决策要牌还是结束要牌，新拿的牌更新了游戏状态，玩家转移到新状态下继续做决策。举个例子，假设初始时玩家明牌为8，暗牌为6，庄家明牌为7，则游戏状态为Tuple
(14, 7,
False)。若玩家的策略为教材中的固定规则策略：没到20或者21继续要牌。下一步玩家拿到牌3，则此时新状态为
(17, 7, False)，按照策略继续要牌。</p>
<p>第二个方面是游戏的状态完全等价于玩家观察到的信息。比如尽管初始时有4张牌，真正的状态是这四张牌的值，但是出于简化目的，不考虑partially
observable
的情况，即不将暗牌纳入游戏状态中。另外，庄家做决策的时候也无法得知玩家的手中的总牌数。</p>
<p>第三个方面是关于玩家点数。考虑玩家初始时的两张牌为2，3，总点数是5，那么为何不将5加入到游戏状态中呢？原则上是可以将初始总和为2到11都加入到游戏状态，但是意义不大，原因在于我们已经假设了已发牌的无状态性，拿到的这两张牌并不会改变后续补充的牌的出现概率。当玩家初始总和为2到11时一定会追加牌，因为无论第三张牌是什么，都不会超过21点，只会增加获胜概率。若后续第三张牌为8，总和变成13，就进入了有效的游戏状态，因为此时如果继续要牌，获得10，则游戏输掉。因此，我们关心的游戏状态并不完全等价于所有可能的游戏状态。</p>
<h2 id="点游戏-openai-gym环境">21点游戏 OpenAI Gym环境</h2>
<p>OpenAI Gym
已经实现了Sutton版本的21点游戏环境，并按上述规则来进行。在安装完OpenAI
Gym包之后 import BlackjackEnv即可使用。</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> gym.envs.toy_text <span class="hljs-keyword">import</span> BlackjackEnv</span><br></pre></td></tr></tbody></table></figure>
<p>根据这个游戏环境，我们先来定义一些类型，可以令代码更具可读性和抽象化。State
上文说过是由三个分量组成的Tuple。Action 为bool类型
表示是否继续要牌。Reward 为+1或者-1，玩家叫牌过程中为0。StateValue
为书中的 <span class="math inline">\(V_{\pi}\)</span>，实现上是一个Dict。DeterministicPolicy
为一个函数，输入是某一状态，输出是唯一的决策动作。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">State = <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>]</span><br><span class="line">Action = <span class="hljs-built_in">bool</span></span><br><span class="line">Reward = <span class="hljs-built_in">float</span></span><br><span class="line">StateValue = <span class="hljs-type">Dict</span>[State, <span class="hljs-built_in">float</span>]</span><br><span class="line">DeterministicPolicy = <span class="hljs-type">Callable</span>[[State], Action]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以下代码是 BlackjackEnv 核心代码，step
方法的输入为玩家的决策动作（叫牌还是结束），并输出State, Reward,
is_done。简单解释一下代码逻辑，当玩家继续加牌时，需要判断是否超21点，如果没有超过的话，返回下一状态，同时reward
为0，等待下一step方法。若玩家停止叫牌，则按照庄家策略：小于17时叫牌。游戏终局时产生+1表示玩家获胜，-1表示庄家获胜。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlackjackEnv</span>(<span class="hljs-params">gym.Env</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, action</span>):</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> self.action_space.contains(action)</span><br><span class="line">        <span class="hljs-keyword">if</span> action:  <span class="hljs-comment"># hit: add a card to players hand and return</span></span><br><span class="line">            self.player.append(draw_card(self.np_random))</span><br><span class="line">            <span class="hljs-keyword">if</span> is_bust(self.player):</span><br><span class="line">                done = <span class="hljs-literal">True</span></span><br><span class="line">                reward = -<span class="hljs-number">1.</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                done = <span class="hljs-literal">False</span></span><br><span class="line">                reward = <span class="hljs-number">0.</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># stick: play out the dealers hand, and score</span></span><br><span class="line">            done = <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">while</span> sum_hand(self.dealer) &lt; <span class="hljs-number">17</span>:</span><br><span class="line">                self.dealer.append(draw_card(self.np_random))</span><br><span class="line">            reward = cmp(score(self.player), score(self.dealer))</span><br><span class="line">            <span class="hljs-keyword">if</span> self.natural <span class="hljs-keyword">and</span> is_natural(self.player) <span class="hljs-keyword">and</span> reward == <span class="hljs-number">1.</span>:</span><br><span class="line">                reward = <span class="hljs-number">1.5</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._get_obs(), reward, done, {}</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_obs</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (sum_hand(self.player), self.dealer[<span class="hljs-number">0</span>], usable_ace(self.player))</span><br></pre></td></tr></tbody></table></figure>
<p>下面示例如何调用step方法生成一个episode的数据集。数据集的类型为
List[Tuple[State, Action, Reward]]。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_episode_data</span>(<span class="hljs-params">policy: DeterministicPolicy, env: BlackjackEnv</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[State, Action, Reward]]:</span></span><br><span class="line">    episode_history = []</span><br><span class="line">    state = env.reset()</span><br><span class="line">    done = <span class="hljs-literal">False</span></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> done:</span><br><span class="line">        action = policy(state)</span><br><span class="line">        next_state, reward, done, _ = env.step(action)</span><br><span class="line">        episode_history.append((state, action, reward))</span><br><span class="line">        state = next_state</span><br><span class="line">    <span class="hljs-keyword">return</span> episode_history</span><br></pre></td></tr></tbody></table></figure>
<h2 id="策略的蒙特卡洛值预测">策略的蒙特卡洛值预测</h2>
<p>Monte Carlo Prediction解决如下问题：当给定Agent 策略<span class="math inline">\(\pi\)</span>时，反复试验来预估策略的 <span class="math inline">\(V_{\pi}\)</span>
值。具体来说，产生一系列的episode数据之后，对于出现了的所有状态分别计算其Return，再通过
average 某一状态 s 的Return来估计 <span class="math inline">\(V_{\pi}(s)\)</span>，理论上，依据大数定理（Law of
large numbers），在可以无限模拟的情况下，Monte Carlo prediction
一定会收敛到真实的 <span class="math inline">\(V_{\pi}\)</span>。算法实现上有两个略微不同的版本，一个版本称为
First-visit，另一个版本称为 Every-visit，区别在于如何计算出现的状态 s 的
Return值。</p>
<p>对于 First-visit 来说，当状态 s 第一次出现时计算一次
Returns，若继续出现状态 s 不再重复计算。对于Every-visit来说，每次出现 s
计算一次 Returns(s)。举个例子，某episode 数据如下： <span class="math display">\[
S_1, R_1, S_2, R_2, S_1, R_3, S_3, R_4
\]</span> First-visit 对于状态S1的Returns计算为</p>
<p><span class="math display">\[
Returns(S_1) = R_1 + R_2 + R_3 + R_4
\]</span></p>
<p>Every-visit 对于状态S1的Returns计算了两次，因为S1出现了两次。 <span class="math display">\[
\begin{align*}
Returns(S_1) = \frac{Return_1(S_1) + Return_2(S_1)}2 \\
= \frac{(R_1 + R_2 + R_3 + R_4) + (R_3 + R_4)} 2
\end{align*}
\]</span></p>
<p>下面用Monte
Carlo来模拟解得书中示例玩家固定策略的V值，策略具体为：加牌直到手中点数&gt;=20，代码为</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fixed_policy</span>(<span class="hljs-params">observation</span>):</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    sticks if the player score is &gt;= 20 and hits otherwise.</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    score, dealer_score, usable_ace = observation</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">20</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="first-visit-mc-predicition">First-visit MC Predicition</h3>
伪代码如下，注意考虑到实现上的高效性，在遍历episode序列数据时是从后向前扫的，这样可以边扫边更新G。
<div>
<p><span class="math display">\[
\begin{align*}
&amp;\textbf{First-visit MC prediction, for estimating } V \approx
v_{\pi} \\
&amp; \text{Input: a policy } \pi \text{ to be evaluated} \\
&amp; \text{Initialize} \\
&amp; \quad V(s) \in \mathbb R \text{, arbitrarily, for all }s \in
\mathcal{S} \\
&amp; \quad Returns(s) \leftarrow \text{ an empty list, arbitrarily, for
all }s \in \mathcal{S} \\
&amp; \\
&amp; \text{Loop forever (for episode):}\\
&amp; \quad \text{Generate an episode following } \pi: S_0, A_0, R_1,
S_1, A_1, R_2, ..., S_{T-1}, A_{T-1}, R_T\\
&amp; \quad G \leftarrow 0\\
&amp; \quad \text{Loop for each step of episode, } t = T-1, T-2, ...,
0:\\
&amp; \quad \quad \quad G \leftarrow \gamma G + R_{t+1}\\
&amp; \quad \quad \quad \text{Unless } S_t \text{ appears in } S_0, S_1,
..., S_{t-1}\\
&amp; \quad \quad \quad \quad \text{Append } G \text { to }Returns(S_t)
\\
&amp; \quad \quad \quad \quad V(S_t) \leftarrow
\operatorname{average}(Returns(S_t))\\
\end{align*}
\]</span></p>
</div>
<p>对应的 python 实现</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mc_prediction_first_visit</span>(<span class="hljs-params">policy: DeterministicPolicy, env: BlackjackEnv,</span></span></span><br><span class="line"><span class="hljs-params"><span class="hljs-function">                              num_episodes, discount_factor=<span class="hljs-number">1.0</span></span>) -&gt; StateValue:</span></span><br><span class="line">    returns_sum = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line">    returns_count = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> episode_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_episodes + <span class="hljs-number">1</span>):</span><br><span class="line">        episode_history = gen_episode_data(policy, env)</span><br><span class="line"></span><br><span class="line">        G = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(episode_history) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):</span><br><span class="line">            s, a, r = episode_history[t]</span><br><span class="line">            G = discount_factor * G + r</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(s_a_r[<span class="hljs-number">0</span>] == s <span class="hljs-keyword">for</span> s_a_r <span class="hljs-keyword">in</span> episode_history[<span class="hljs-number">0</span>: t]):</span><br><span class="line">                returns_sum[s] += G</span><br><span class="line">                returns_count[s] += <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">    V = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line">    V.update({s: returns_sum[s] / returns_count[s] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> returns_sum.keys()})</span><br><span class="line">    <span class="hljs-keyword">return</span> V</span><br></pre></td></tr></tbody></table></figure>
<h3 id="every-visit-mc-prediciton">Every-visit MC Prediciton</h3>
<p>Every-visit 代码实现相对更简单一些，t
从后往前遍历时更新对应s的状态变量。如下所示</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mc_prediction_every_visit</span>(<span class="hljs-params">policy: DeterministicPolicy, env: BlackjackEnv,</span></span></span><br><span class="line"><span class="hljs-params"><span class="hljs-function">                              num_episodes, discount_factor=<span class="hljs-number">1.0</span></span>) -&gt; StateValue:</span></span><br><span class="line">    returns_sum = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line">    returns_count = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> episode_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_episodes + <span class="hljs-number">1</span>):</span><br><span class="line">        episode_history = gen_episode_data(policy, env)</span><br><span class="line"></span><br><span class="line">        G = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(episode_history) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):</span><br><span class="line">            s, a, r = episode_history[t]</span><br><span class="line">            G = discount_factor * G + r</span><br><span class="line">            returns_sum[s] += G</span><br><span class="line">            returns_count[s] += <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">    V = defaultdict(<span class="hljs-built_in">float</span>)</span><br><span class="line">    V.update({s: returns_sum[s] / returns_count[s] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> returns_sum.keys()})</span><br><span class="line">    <span class="hljs-keyword">return</span> V</span><br></pre></td></tr></tbody></table></figure>
<h2 id="策略-v值-3d-可视化">策略 V值 3D 可视化</h2>
<p>运行first-visit
算法，模拟10000次episode，fixed_policy的V值的3D图为下面两张图，分别是不含usable
Ace和包含usable
Ace。总的说来，一旦玩家能到达20点或21点获胜概率极大，到达13-17获胜概率较小，在11-13时有一定获胜概率，比较符合经验直觉。</p>
<figure>
<img src="/zh/2020/rl-sutton-blackjack-1/mc_v_first_visit_10000_no_usable.png">
<figcaption>
first-visit MC 10000次没有usable A的V值
</figcaption>
</figure>
<figure>
<img src="/zh/2020/rl-sutton-blackjack-1/mc_v_first_visit_10000_usable.png">
<figcaption>
first-visit MC 10000次含有usable A的V值
</figcaption>
</figure>
<p>同样运行every-visit
算法，模拟10000次的V值图。对比两种方法结果比较接近。</p>
<figure>
<img src="/zh/2020/rl-sutton-blackjack-1/mc_v_every_visit_10000_no_usable.png">
<figcaption>
every-visit MC 10000次没有usable A的V值
</figcaption>
</figure>
<figure>
<img src="/zh/2020/rl-sutton-blackjack-1/mc_v_every_visit_10000_usable.png">
<figcaption>
every-visit MC 10000次含有usable A的V值
</figcaption>
</figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/rl-sutton-gridworld-2/" itemprop="url">通过代码学Sutton强化学习2：Grid World 策略迭代和值迭代</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-09-11T18:45:01.000Z" itemprop="datePublished">9月 12 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            15 分钟 读完 (约 2285 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>上一期 <a href="/zh/2020/rl-sutton-gridworld-2/!--swig￼6--">通过代码学Sutton强化学习1：Grid World
OpenAI环境和策略评价算法</a>，我们引入了 Grid World
问题，实现了对应的OpenAI Gym
环境，也分析了其最佳策略和对应的V值。这一期中，继续通过这个例子详细讲解策略提升（Policy
Improvment）、策略迭代（Policy Iteration）、值迭代（Value
Iteration）和异步迭代方法。</p>
<h2 id="回顾-grid-world-问题">回顾 Grid World 问题</h2>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/grid_world.png">
<figcaption>
Grid World 问题
</figcaption>
</figure>
在Grid World 中，Agent初始可以出现在编号1-14的网格中，Agent
每往四周走一步得到 -1
reward，因此需要尽快走到两个出口。当然最佳策略是以最小步数往出口逃离，如下所示。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/optimal_policy.png">
<figcaption>
Grid World 最佳策略
</figcaption>
</figure>
<p>最佳策略对应的状态V值和3D heatmap如下 </p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="hljs-number">0.</span> -<span class="hljs-number">1.</span> -<span class="hljs-number">2.</span> -<span class="hljs-number">3.</span>]</span><br><span class="line"> [-<span class="hljs-number">1.</span> -<span class="hljs-number">2.</span> -<span class="hljs-number">3.</span> -<span class="hljs-number">2.</span>]</span><br><span class="line"> [-<span class="hljs-number">2.</span> -<span class="hljs-number">3.</span> -<span class="hljs-number">2.</span> -<span class="hljs-number">1.</span>]</span><br><span class="line"> [-<span class="hljs-number">3.</span> -<span class="hljs-number">2.</span> -<span class="hljs-number">1.</span>  <span class="hljs-number">0.</span>]]</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/value_3d.png">
<figcaption>
Grid World V值 3D heatmap
</figcaption>
</figure>
<h2 id="策略迭代">策略迭代</h2>
<p>上一篇中，我们知道如何evaluate 给定policy <span class="math inline">\(\pi\)</span> 的 <span class="math inline">\(v_{\pi}\)</span>值，那么是否可能在此基础上改进生成更好的策略
<span class="math inline">\(\pi^{\prime}\)</span>。如果可以，能否最终找到最佳策略<span class="math inline">\({\pi}_{*}\)</span>？答案是肯定的，因为存在策略提升定理（Policy
Improvement Theorem）。</p>
<h3 id="策略提升定理">策略提升定理</h3>
<p>在 4.2 节 Policy Improvement Theorem 可以证明，利用 <span class="math inline">\(v_{\pi}\)</span> 信息对于每个状态采取最 greedy 的
action （又称exploitation）能够保证生成的新 <span class="math inline">\({\pi}^{\prime}\)</span> 是不差于旧的policy <span class="math inline">\({\pi}\)</span>，即</p>
<div>
<p><span class="math display">\[
q_{\pi}(s, {\pi}^{\prime}(s)) \gt v_{\pi}(s)
\]</span></p>
</div>
<div>
<p><span class="math display">\[
v_{\pi^{\prime}}(s) \gt v_{\pi}(s)
\]</span></p>
</div>
因此，可以通过在当前policy求得v值，再选取最greedy
action的方式形成如下迭代，就能够不断逼近最佳策略。
<div>
<p><span class="math display">\[
\pi_{0} \stackrel{\mathrm{E}}{\longrightarrow} v_{\pi_{0}}
\stackrel{\mathrm{I}}{\longrightarrow} \pi_{1}
\stackrel{\mathrm{E}}{\longrightarrow} v_{\pi_{1}}
\stackrel{\mathrm{I}}{\longrightarrow} \pi_{2}
\stackrel{\mathrm{E}}{\longrightarrow} \cdots
\stackrel{\mathrm{I}}{\longrightarrow} \pi_{*}
\stackrel{\mathrm{E}}{\longrightarrow} v_{*}
\]</span></p>
</div>
<h3 id="策略迭代算法">策略迭代算法</h3>
以下为书中4.3的policy iteration伪代码。其中policy
evaluation的算法在上一篇中已经实现。Policy improvement
的精髓在于一次遍历所有状态后，通过policy
的最大Q值找到该状态的最佳action，并更新成最新policy，循环直至没有 action
变更。
<div>
<p><span class="math display">\[
\begin{align*}
&amp;\textbf{Policy Iteration (using iterative policy evaluation) for
estimating } \pi\approx {\pi}_{*} \\
&amp;1. \quad \text{Initialization} \\
&amp; \quad \quad V(s) \in \mathbb R\text{ and } \pi(s) \in \mathcal
A(s) \text{ arbitrarily for all }s \in \mathcal{S} \\
&amp; \\
&amp;2. \quad \text{Policy Evaluation} \\
&amp; \quad \quad \text{Loop:}\\
&amp; \quad \quad \Delta \leftarrow 0\\
&amp; \quad \quad \text{Loop for each } s \in \mathcal{S}:\\
&amp; \quad \quad \quad \quad v \leftarrow V(s) \\
&amp; \quad \quad \quad \quad V(s) \leftarrow \sum_{s^{\prime}, r}
p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
V\left(s^{\prime}\right)\right] \\
&amp; \quad \quad \quad \quad \Delta \leftarrow \max(\Delta, |v-V(s)|)
\\
&amp; \quad \quad \text{until } \Delta &lt; \theta \text{ (a small
positive number determining the accuracy of estimation)}\\
&amp; \\
&amp;3. \quad \text{Policy Improvement} \\
&amp; \quad \quad policy\text{-}stable\leftarrow true \\
&amp; \quad \quad \text{Loop for each } s \in \mathcal{S}:\\
&amp; \quad \quad \quad \quad old\text{-}action\leftarrow \pi(s) \\
&amp; \quad \quad \quad \quad \pi(s) \leftarrow
\operatorname{argmax}_{a} \sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid
s, a\right)\left[r+\gamma V\left(s^{\prime}\right)\right] \\
&amp; \quad \quad \quad \quad \text{If } old\text{-}action \neq
\pi\text{,then }policy\text{-}stable\leftarrow false \\
&amp; \quad \quad \text{If } policy\text{-}stable \text{, then stop and
return }V \approx v_{*} \text{ and } \pi\approx {\pi}_{*}\text{; else go
to 2}
\end{align*}
\]</span></p>
</div>
<p>注意到状态Q值 <span class="math inline">\(q_{\pi}(s, a)\)</span>
会被多处调用，将其封装为单独的函数。</p>
<div>
<p><span class="math display">\[
\begin{aligned}
q_{\pi}(s, a) &amp;=\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>Q值函数实现如下： </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_value</span>(<span class="hljs-params">env: GridWorldEnv, state: State, V: StateValue, gamma=<span class="hljs-number">1.0</span></span>) -&gt; ActionValue:</span></span><br><span class="line">    q = np.zeros(env.nA)</span><br><span class="line">    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nA):</span><br><span class="line">        <span class="hljs-keyword">for</span> prob, next_state, reward, done <span class="hljs-keyword">in</span> env.P[state][a]:</span><br><span class="line">            q[a] += prob * (reward + gamma * V[next_state])</span><br><span class="line">    <span class="hljs-keyword">return</span> q</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>有了 action_value 和上期的 policy_evaluate，policy iteration
实现完全对应上面的伪代码。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">policy_improvement</span>(<span class="hljs-params">env: GridWorldEnv, policy: Policy, V: StateValue, gamma=<span class="hljs-number">1.0</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">    policy_stable = <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">        old_action = np.argmax(policy[s])</span><br><span class="line">        Q_s = action_value(env, s, V)</span><br><span class="line">        best_action = np.argmax(Q_s)</span><br><span class="line">        policy[s] = np.eye(env.nA)[best_action]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> old_action != best_action:</span><br><span class="line">            policy_stable = <span class="hljs-literal">False</span></span><br><span class="line">    <span class="hljs-keyword">return</span> policy_stable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">policy_iteration</span>(<span class="hljs-params">env: GridWorldEnv, policy: Policy, gamma=<span class="hljs-number">1.0</span></span>) -&gt; <span class="hljs-type">Tuple</span>[Policy, StateValue]:</span></span><br><span class="line">    <span class="hljs-built_in">iter</span> = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        V = policy_evaluate(policy, env, gamma)</span><br><span class="line">        policy_stable = policy_improvement(env, policy, V)</span><br><span class="line">        <span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> policy_stable:</span><br><span class="line">            <span class="hljs-keyword">return</span> policy, V</span><br></pre></td></tr></tbody></table></figure><p></p>
Grid World
例子通过两轮迭代就可以收敛，以下是初始时随机策略的V值和第一次迭代后的V值。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/policy_iter_0.png">
<figcaption>
初始随机策略 V 值
</figcaption>
</figure>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/policy_iter_1.png">
<figcaption>
第一次迭代后的 V 值
</figcaption>
</figure>
<h2 id="值迭代">值迭代</h2>
<p>值迭代（ Value Iteration）的本质是，将policy iteration中的policy
evaluation过程从不断循环到收敛直至小于theta，改成只执行一遍，并直接用最佳Q值更新到状态V值，如此可以不用显示地算出<span class="math inline">\({\pi}\)</span>
而直接在V值上迭代。具体迭代公式如下：</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{k+1}(s) &amp; \doteq \max _{a} \mathbb{E}\left[R_{t+1}+\gamma
v_{k}\left(S_{t+1}\right) \mid S_{t}=s, A_{t}=a\right] \\
&amp;=\max_{a}  q_{\pi_k}(s, a) \\
&amp;=\max _{a} \sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma v_{k}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>完整的伪代码为：</p>
<div>
<p><span class="math display">\[
\begin{align*}
&amp;\textbf{Value Iteration, for estimating } \pi\approx \pi_{*} \\
&amp; \text{Algorithm parameter: a small threshold } \theta &gt; 0
\text{ determining accuracy of estimation} \\
&amp; \text{Initialize } V(s), \text{for all } s \in \mathcal{S}^{+}
\text{, arbitrarily except that } V (terminal) = 0\\
&amp; \\
&amp;1: \text{Loop:}\\
&amp;2: \quad \quad \Delta \leftarrow 0\\
&amp;3: \quad \quad \text{Loop for each } s \in \mathcal{S}:\\
&amp;4: \quad \quad \quad \quad v \leftarrow V(s) \\
&amp;5: \quad \quad \quad \quad V(s) \leftarrow \operatorname{max}_{a}
\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
V\left(s^{\prime}\right)\right] \\
&amp;6: \quad \quad \quad \quad \Delta \leftarrow \max(\Delta, |v-V(s)|)
\\
&amp;7: \text{until } \Delta &lt; \theta \\
&amp; \\
&amp; \text{Output a deterministic policy, }\pi\approx \pi_{*} \text{,
such that} \\
&amp; \quad \quad \pi(s) \leftarrow \operatorname{argmax}_{a}
\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
V\left(s^{\prime}\right)\right]
\end{align*}
\]</span></p>
</div>
<p>代码实现也比较直接，可以复用上面已经实现的 action_value 函数。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value_iteration</span>(<span class="hljs-params">env:GridWorldEnv, gamma=<span class="hljs-number">1.0</span>, theta=<span class="hljs-number">0.0001</span></span>) -&gt; <span class="hljs-type">Tuple</span>[Policy, StateValue]:</span></span><br><span class="line">    V = np.zeros(env.nS)</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        delta = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">            action_values = action_value(env, s, V, gamma=gamma)</span><br><span class="line">            best_action_value = np.<span class="hljs-built_in">max</span>(action_values)</span><br><span class="line">            delta = <span class="hljs-built_in">max</span>(delta, np.<span class="hljs-built_in">abs</span>(best_action_value - V[s]))</span><br><span class="line">            V[s] = best_action_value</span><br><span class="line">        <span class="hljs-keyword">if</span> delta &lt; theta:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line"></span><br><span class="line">    policy = np.zeros([env.nS, env.nA])</span><br><span class="line">    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">        action_values = action_value(env, s, V, gamma=gamma)</span><br><span class="line">        best_action = np.argmax(action_values)</span><br><span class="line">        policy[s, best_action] = <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> policy, V</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="异步迭代">异步迭代</h2>
<p>在第4.5节中提到了DP迭代方式的改进版：异步方式迭代（Asychronous
Iteration）。这里的异步是指每一轮无需全部扫一遍所有状态，而是根据上一轮变化的状态决定下一轮需要最多计算的状态数，类似于Dijkstra最短路径算法中用
heap
来维护更新节点集合，减少运算量。下面我们通过异步值迭代来演示异步迭代的工作方式。</p>
<p>下图表示状态的变化方向，若上一轮 <span class="math inline">\(V(s)\)</span> 发生更新，那么下一轮就要考虑状态 s
可能会影响到上游状态的集合（
p1，p2），避免下一轮必须遍历所有状态的V值计算。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-2/async_propa.png">
<figcaption>
Async 反向传播
</figcaption>
</figure>
<p>要做到部分更新就必须知道每个状态可能影响到的上游状态集合，上图对应的映射关系可以表示为</p>
<div>
<p><span class="math display">\[
\begin{align*}
s'_1 &amp;\rightarrow \{s\} \\
s'_2 &amp;\rightarrow \{s\} \\
s &amp;\rightarrow \{p_1, p_2\}
\end{align*}
\]</span></p>
</div>
<p>建立映射关系的代码如下，build_reverse_mapping 返回类型为 Dict[State,
Set[State]]。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_reverse_mapping</span>(<span class="hljs-params">env:GridWorldEnv</span>) -&gt; <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Set</span>[State]]:</span></span><br><span class="line">    MAX_R, MAX_C = env.shape[<span class="hljs-number">0</span>], env.shape[<span class="hljs-number">1</span>]</span><br><span class="line">    mapping = {s: <span class="hljs-built_in">set</span>() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, MAX_R * MAX_C)}</span><br><span class="line">    action_delta = {Action.UP: (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.DOWN: (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.LEFT: (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), Action.RIGHT: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)}</span><br><span class="line">    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, MAX_R * MAX_C):</span><br><span class="line">        r = s // MAX_R</span><br><span class="line">        c = s % MAX_R</span><br><span class="line">        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action):</span><br><span class="line">            neighbor_r = <span class="hljs-built_in">min</span>(MAX_R - <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r + action_delta[a][<span class="hljs-number">0</span>]))</span><br><span class="line">            neighbor_c = <span class="hljs-built_in">min</span>(MAX_C - <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, c + action_delta[a][<span class="hljs-number">1</span>]))</span><br><span class="line">            s_ = neighbor_r * MAX_R + neighbor_c</span><br><span class="line">            mapping[s_].add(s)</span><br><span class="line">    <span class="hljs-keyword">return</span> mapping</span><br></pre></td></tr></tbody></table></figure>
<p>有了描述状态依赖的映射 dict 后，代码也比较简洁，changed_state_set
变量保存了这轮必须计算的状态集合。新的一轮迭代时，将下一轮需要计算的状态保存到
changed_state_set_ 中，本轮结束后，changed_state_set
更新成changed_state_set_，开始下一轮循环直至没有状态需要更新。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value_iteration_async</span>(<span class="hljs-params">env:GridWorldEnv, gamma=<span class="hljs-number">1.0</span>, theta=<span class="hljs-number">0.0001</span></span>) -&gt; <span class="hljs-type">Tuple</span>[Policy, StateValue]:</span></span><br><span class="line">    mapping = build_reverse_mapping(env)</span><br><span class="line"></span><br><span class="line">    V = np.zeros(env.nS)</span><br><span class="line">    changed_state_set = <span class="hljs-built_in">set</span>(s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">iter</span> = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(changed_state_set) &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        changed_state_set_ = <span class="hljs-built_in">set</span>()</span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> changed_state_set:</span><br><span class="line">            action_values = action_value(env, s, V, gamma=gamma)</span><br><span class="line">            best_action_value = np.<span class="hljs-built_in">max</span>(action_values)</span><br><span class="line">            v_diff = np.<span class="hljs-built_in">abs</span>(best_action_value - V[s])</span><br><span class="line">            <span class="hljs-keyword">if</span> v_diff &gt; theta:</span><br><span class="line">                changed_state_set_.update(mapping[s])</span><br><span class="line">                V[s] = best_action_value</span><br><span class="line">        changed_state_set = changed_state_set_</span><br><span class="line">        <span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    policy = np.zeros([env.nS, env.nA])</span><br><span class="line">    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">        action_values = action_value(env, s, V, gamma=gamma)</span><br><span class="line">        best_action = np.argmax(action_values)</span><br><span class="line">        policy[s, best_action] = <span class="hljs-number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> policy, V</span><br></pre></td></tr></tbody></table></figure>
比较值迭代和异步值迭代方法后发现，值迭代用了4次循环，每次涉及所有状态，总计算状态数为
4 x 16 = 64。异步值迭代也用了4次循环，但是总计更新了54个状态。由于Grid
World
的状态数很少，异步值迭代优势并不明显，但是对于状态数众多并且迭代最终集中在少部分状态的环境下，节省的计算量还是很可观的。<p></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/rl-sutton-gridworld-1/" itemprop="url">通过代码学Sutton强化学习1：Grid World OpenAI环境和策略评价算法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-09-03T18:45:01.000Z" itemprop="datePublished">9月 4 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2827 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>经典教材Reinforcement Learning: An Introduction
第二版由强化领域权威Richard S. Sutton 和 Andrew G. Barto
完成编写，内容深入浅出，非常适合初学者。在本篇中，引入Grid
World示例，结合强化学习核心概念，并用python代码实现OpenAI
Gym的模拟环境，进一步实现策略评价算法。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/rl_sutton.png">
<figcaption>
</figcaption>
</figure>
<h2 id="grid-world-问题">Grid World 问题</h2>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/grid_world.png">
<figcaption>
</figcaption>
</figure>
<p>第四章例子4.1提出了一个简单的离散空间状态问题：Grid
World，其大致意思是在4x4的网格世界中有14个格子是非终点状态，在这些非终点状态的格子中可以往上下左右四个方向走，直至走到两个终点状态格子，则游戏结束。每走一步，Agent收获reward
-1，表示Agent希望在Grid World中尽早出去。另外，Agent在Grid
World边缘时，无法继续往外只能呆在原地，reward也是-1。</p>
<h2 id="finite-mdp-模型">Finite MDP 模型</h2>
先来回顾一下强化学习的建模基础：有限马尔可夫决策过程（Finite Markov
Decision Process, Finite
MDP）。如下图，强化学习模型将世界抽象成两个实体，强化学习解决目标的主体Agent和其他外部环境。它们之间的交互过程遵从有限马尔可夫决策过程：若Agent在t时间步骤时处于状态
<span class="math inline">\(S_t\)</span>，采取动作 <span class="math inline">\(A_t\)</span>，然后环境根据自身机制，产生Reward
<span class="math inline">\(R_{t+1}\)</span> 并将Agent状态变为 <span class="math inline">\(S_{t+1}\)</span>。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/env_agent.png">
<figcaption>
</figcaption>
</figure>
<p>环境自身机制又称为dynamics，工程上可以看成一个输入(S, A)，输出(S,
R)的方法。由于MDP包含随机过程，某个输入并不能确定唯一输出，而会根据概率分布输出不同的(S,
R)。Finite MDP简化了时间对于模型的影响，因为(S, R)只和(S,
A)有关，不和时间t有关。另外，有限指的是S，A，R的状态数量是有限的。</p>
<p>数学上dynamics可以如下表示</p>
<div>
<p><span class="math display">\[
p\left(s^{\prime}, r \mid s, a\right) \doteq
\operatorname{Pr}\left\{S_{t}=s^{\prime}, R_{t}=r \mid S_{t-1}=s,
A_{t-1}=a\right\}
\]</span></p>
</div>
<p>即是四元组作为输入的概率函数 <span class="math inline">\(p: S \times
R \times S \times A \rightarrow [0, 1]\)</span>。</p>
<p>满足 <span class="math display">\[
\sum_{s^{\prime} \in \mathcal{S}} \sum_{r \in \mathcal{R}}
p\left(s^{\prime}, r \mid s, a\right)=1, \text { for all } s \in
\mathcal{S}, a \in \mathcal{A}(s)
\]</span></p>
以Grid
World为例，当Agent处于编号1的网格时，可以往四个方向走，往任意方向走都只产生一种
S,
R，因为这个简单的游戏是确定性的，不存在某一动作导致stochastic状态。例如，在1号网格往左就到了终点网格（编号0），得到Reward
-1这个规则可以如下表示 <span class="math display">\[
p\left(s^{\prime}=0, r=-1 \mid s=1, a=\text{L}\right) = 1
\]</span> 因此，状态s=1的所有dynamics概率映射为
<div>
<p><span class="math display">\[
\begin{aligned}
p\left(s^{\prime}=0, r=-1 \mid s=1, a=\text{L}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=2, r=-1 \mid s=1, a=\text{R}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=1, r=-1 \mid s=1, a=\text{U}\right) &amp;=&amp; 1 \\
p\left(s^{\prime}=5, r=-1 \mid s=1, a=\text{D}\right) &amp;=&amp; 1
\end{aligned}
\]</span></p>
</div>
<h2 id="强化学习的目的">强化学习的目的</h2>
<p>在给定了问题以及定义了强化学习的模型之后，强化学习的目的当然是通过学习让Agent能够学到最佳策略<span class="math inline">\(\pi_{*}\)</span>，也就是在某个状态下的行动分布，记成
<span class="math inline">\(\pi(a|s)\)</span>。对应在数值上的优化目标是Agent在一系列过程中采取某种策略的reward总和的期望（Expected
Return）。下面公式定义了t步往后的reward总和，其中 <span class="math inline">\(\gamma\)</span> 为discount
factor，用于权衡短期和长期reward对于当前Agent的效用影响。等式最后一步的意义是t步后的reward总和等价于t步所获的立即reward
<span class="math inline">\(R_{t+1}\)</span>，加上t+1步后的reward总和
<span class="math inline">\(\gamma G_{t+1}\)</span>。</p>
<div>
<p><span class="math display">\[
\begin{aligned}
G_{t} &amp; \doteq R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\gamma^{3}
R_{t+4}+\cdots \\
&amp;=R_{t+1}+\gamma\left(R_{t+2}+\gamma R_{t+3}+\gamma^{2}
R_{t+4}+\cdots\right) \\
&amp;=R_{t+1}+\gamma G_{t+1}
\end{aligned}
\]</span></p>
</div>
<p>有了reward总和的定义，评价Agent策略 <span class="math inline">\(\pi\)</span> 就可以定义成Agent在状态 s
时采用此策略的Expected Return。</p>
<p><span class="math display">\[
v_{\pi}(s) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]
\]</span></p>
<p>下面公式推导了 <span class="math inline">\(v_{\pi}(s)\)</span>
数值上和相关状态 <span class="math inline">\(s{\prime}\)</span>
的关系：</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{\pi}(s) &amp;\doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]
\\
&amp;=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}
\mid S_{t}=s\right]\\
&amp;=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma G_{t+1} \mid S_{t}=s\right]
\\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}} \sum_{r}
p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
\mathbb{E}_{\pi}\left[G_{t+1} \mid S_{t+1}=s^{\prime}\right]\right] \\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r
\mid s, a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right]
\quad \text { for all } s \in \mathcal{S}
\end{aligned}
\]</span></p>
</div>
<p>注意到如果将 <span class="math inline">\(v_{\pi}(s)\)</span>
看成未知数，上式即形成 <span class="math inline">\(\mid \mathcal{S}
\mid\)</span> 个未知变量的方程组，可以在数值上解得各个 <span class="math inline">\(v_{\pi}(s)\)</span>。</p>
书中用Backup Diagram来表示递推关系，下图是<span class="math inline">\(v_{\pi}(s)\)</span>的backup diagram。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_v_pi.png">
<figcaption>
</figcaption>
</figure>
<p>尽管v值可以来衡量策略，但由于<span class="math inline">\(v_{\pi}(s)\)</span> 是Agent在策略<span class="math inline">\(\pi(a|s)\)</span>的Expected
Return，将不同的action拆出来单独计算Expected
Return，这样的做法有时更为直接，这就是著名的Q Learning中的q
值，记成<span class="math inline">\(q_{\pi}(s, a)\)</span> 。</p>
<p><span class="math display">\[
q_{\pi}(s, a) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s,
A_{t}=a\right]
\]</span></p>
<p>下面是 $q_{}(s, a) $ 的递推 backup diagram。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_q_pi.png">
<figcaption>
</figcaption>
</figure>
<h2 id="bellman-最佳原则">Bellman 最佳原则</h2>
<p>对于所有状态集合<span class="math inline">\(\mathcal{S}\)</span>，策略<span class="math inline">\({\pi}\)</span>的评价指标 <span class="math inline">\(v_{\pi}(s)\)</span>
是一个向量，本质上是无法相互比较的。但由于存在Bellman
最佳原则（Bellman's principle of
optimality）：在有限状态情况下，一定存在一个或者多个最好的策略 <span class="math inline">\({\pi}_{*}\)</span>，它在所有状态下的v值都是最好的，即
<span class="math inline">\(v_{\pi_{*}}(s) \ge v_{\pi^{\prime}}(s) \text
{ for all } s \in \mathcal{S}\)</span>。</p>
<p>因此，最佳v值定义为最佳策略 <span class="math inline">\({\pi}_{*}\)</span> 对应的 v 值</p>
<p><span class="math display">\[
v_{*}(s) \doteq \max_{\pi} v_{\pi}(s)
\]</span></p>
<p>同理，也存在最佳q值，记为 <span class="math display">\[
\begin{aligned}
q_{*}(s, a) &amp;\doteq \max_{\pi} q_{\pi}(s,a)
\end{aligned}
\]</span></p>
<p>将 <span class="math inline">\(v_{*}(s)\)</span> 改写成递推形式，称为
Bellman Optimality Equation，推导如下</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{*}(s) &amp;=\max _{a \in \mathcal{A}(s)} q_{\pi_{*}}(s, a) \\
&amp;=\max _{a} \mathbb{E}_{\pi_{*}}\left[G_{t} \mid S_{t}=s,
A_{t}=a\right] \\
&amp;=\max _{a} \mathbb{E}_{\pi_{*}}\left[R_{t+1}+\gamma G_{t+1} \mid
S_{t}=s, A_{t}=a\right] \\
&amp;=\max _{a} \mathbb{E}\left[R_{t+1}+\gamma v_{*}\left(S_{t+1}\right)
\mid S_{t}=s, A_{t}=a\right] \\
&amp;=\max _{a} \sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma v_{*}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>直觉上可以理解为状态 s
对应的最佳v值是只采取此状态下的最佳动作后的Expected Return。</p>
<p>最佳q值递归形式的意义为最佳策略下状态s时采取行动 a 的Expected
Return，等于所有可能后续状态 s' 下采取最优行动的Expected
Return的均值。推导如下：</p>
<div>
<p><span class="math display">\[
\begin{aligned}
q_{*}(s, a) &amp;=\mathbb{E}\left[R_{t+1}+\gamma \max _{a^{\prime}}
q_{*}\left(S_{t+1}, a^{\prime}\right) \mid S_{t}=s, A_{t}=a\right] \\
&amp;=\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s,
a\right)\left[r+\gamma \max _{a^{\prime}} q_{*}\left(s^{\prime},
a^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<span class="math inline">\(v_{*}(s), q_{*}(s, a)\)</span> 的backup
diagram 如下图
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/backup_optimal.png">
<figcaption>
</figcaption>
</figure>
<h2 id="grid-world-最佳策略和v值">Grid World 最佳策略和V值</h2>
<p>Grid World 的最佳策略如下：尽可能快的走出去</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/optimal_policy.png">
<figcaption>
Grid World最佳策略
</figcaption>
</figure>
<p>上面的2D图中不同颜色表示不同V值，终点格子的红色表示0，隔着一步的黄色为-1，隔两步的绿色为-2，最远的紫色为-3。下面是立体图示。</p>
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/value_3d.png">
<figcaption>
Grid World最佳策略V值
</figcaption>
</figure>
<h2 id="grid-world-openai-gym-环境">Grid World OpenAI Gym 环境</h2>
<p>下面是OpenAI Gym框架下Grid
World环境的代码实现。本质是在GridWorldEnv构造函数中构建MDP，类型定义如下</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MDP = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Prob, State, Reward, <span class="hljs-built_in">bool</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># P[state][action] = [</span></span><br><span class="line"><span class="hljs-comment">#    (prob1, next_state1, reward1, is_done),</span></span><br><span class="line"><span class="hljs-comment">#    (prob2, next_state2, reward2, is_done), ...]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span>(<span class="hljs-params">Enum</span>):</span></span><br><span class="line">    UP = <span class="hljs-number">0</span></span><br><span class="line">    DOWN = <span class="hljs-number">1</span></span><br><span class="line">    LEFT = <span class="hljs-number">2</span></span><br><span class="line">    RIGHT = <span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">State = <span class="hljs-built_in">int</span></span><br><span class="line">Reward = <span class="hljs-built_in">float</span></span><br><span class="line">Prob = <span class="hljs-built_in">float</span></span><br><span class="line">Policy = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, Prob]]</span><br><span class="line">Value = <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]</span><br><span class="line">StateSet = <span class="hljs-type">Set</span>[<span class="hljs-built_in">int</span>]</span><br><span class="line">NonTerminalStateSet = <span class="hljs-type">Set</span>[<span class="hljs-built_in">int</span>]</span><br><span class="line">MDP = <span class="hljs-type">Dict</span>[State, <span class="hljs-type">Dict</span>[Action, <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Prob, State, Reward, <span class="hljs-built_in">bool</span>]]]]</span><br><span class="line"><span class="hljs-comment"># P[s][a] = [(prob, next_state, reward, is_done), ...]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GridWorldEnv</span>(<span class="hljs-params">discrete.DiscreteEnv</span>):</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Grid World environment described in Sutton and Barto Reinforcement Learning 2nd, chapter 4.</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, shape=[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]</span>):</span></span><br><span class="line">        self.shape = shape</span><br><span class="line">        nS = np.prod(shape)</span><br><span class="line">        nA = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(Action))</span><br><span class="line">        MAX_R = shape[<span class="hljs-number">0</span>]</span><br><span class="line">        MAX_C = shape[<span class="hljs-number">1</span>]</span><br><span class="line">        self.grid = np.arange(nS).reshape(shape)</span><br><span class="line">        isd = np.ones(nS) / nS</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># P[s][a] = [(prob, next_state, reward, is_done), ...]</span></span><br><span class="line">        P: MDP = {}</span><br><span class="line">        action_delta = {Action.UP: (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.DOWN: (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Action.LEFT: (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), Action.RIGHT: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)}</span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, MAX_R * MAX_C):</span><br><span class="line">            P[s] = {a.value : [] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action)}</span><br><span class="line">            is_terminal = self.is_terminal(s)</span><br><span class="line">            <span class="hljs-keyword">if</span> is_terminal:</span><br><span class="line">                <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action):</span><br><span class="line">                    P[s][a.value] = [(<span class="hljs-number">1.0</span>, s, <span class="hljs-number">0</span>, <span class="hljs-literal">True</span>)]</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                r = s // MAX_R</span><br><span class="line">                c = s % MAX_R</span><br><span class="line">                <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(Action):</span><br><span class="line">                    neighbor_r = <span class="hljs-built_in">min</span>(MAX_R-<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r + action_delta[a][<span class="hljs-number">0</span>]))</span><br><span class="line">                    neighbor_c = <span class="hljs-built_in">min</span>(MAX_C-<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, c + action_delta[a][<span class="hljs-number">1</span>]))</span><br><span class="line">                    s_ = neighbor_r * MAX_R + neighbor_c</span><br><span class="line">                    P[s][a.value] = [(<span class="hljs-number">1.0</span>, s_, -<span class="hljs-number">1</span>, <span class="hljs-literal">False</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">super</span>(GridWorldEnv, self).__init__(nS, nA, P, isd)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="策略评估policy-evaluation">策略评估（Policy Evaluation）</h2>
<p>策略评估需要解决在给定环境dynamics和Agent策略 <span class="math inline">\(\pi\)</span>下，计算策略的v值 <span class="math inline">\(v_{\pi}\)</span>。由于所有数量关系都已知，可以通过解方程组的方式求得，但通常会通过数值迭代的方式来计算，即通过一系列
<span class="math inline">\(v_{0}, v_{1}, ..., v_{k}\)</span> 收敛至
<span class="math inline">\(v_{\pi}\)</span>。如下迭代方式已经得到证明，当
<span class="math inline">\(k \rightarrow \infty\)</span> 一定收敛至
<span class="math inline">\(v_{\pi}\)</span>。</p>
<div>
<p><span class="math display">\[
\begin{aligned}
v_{k+1}(s) &amp; \doteq \mathbb{E}_{\pi}\left[R_{t+1}+\gamma
v_{k}\left(S_{t+1}\right) \mid S_{t}=s\right] \\
&amp;=\sum_{a} \pi(a \mid s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r
\mid s, a\right)\left[r+\gamma v_{k}\left(s^{\prime}\right)\right]
\end{aligned}
\]</span></p>
</div>
<p>书中具体伪代码如下</p>
<div>
<p><span class="math display">\[
\begin{align*}
&amp;\textbf{Iterative Policy Evaluation, for estimating } V\approx
v_{\pi} \\
&amp; \text{Input } {\pi}, \text{the policy to be evaluated} \\
&amp; \text{Algorithm parameter: a small threshold } \theta &gt; 0
\text{ determining accuracy of estimation} \\
&amp; \text{Initialize } V(s), \text{for all } s \in \mathcal{S}^{+}
\text{, arbitrarily except that } V (terminal) = 0\\
&amp; \\
&amp;1: \text{Loop:}\\
&amp;2: \quad \quad \Delta \leftarrow 0\\
&amp;3: \quad \quad \text{Loop for each } s \in \mathcal{S}:\\
&amp;4: \quad \quad \quad \quad v \leftarrow V(s) \\
&amp;5: \quad \quad \quad \quad V(s) \leftarrow \sum_{a} \pi(a \mid s)
\sum_{s^{\prime}, r} p\left(s^{\prime}, r \mid s, a\right)\left[r+\gamma
V\left(s^{\prime}\right)\right] \\
&amp;6: \quad \quad \quad \quad \Delta \leftarrow \max(\Delta, |v-V(s)|)
\\
&amp;7: \text{until } \Delta &lt; \theta
\end{align*}
\]</span></p>
</div>
<p>下面是python
代码实现，注意这里单run迭代时，新的v值直接覆盖数组里的旧v值，这种做法在书中被证明不仅有效，甚至更为高效。这种做法称为原地（in
place）更新。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">policy_evaluate</span>(<span class="hljs-params">policy: Policy, env: GridWorldEnv, gamma=<span class="hljs-number">1.0</span>, theta=<span class="hljs-number">0.0001</span></span>):</span></span><br><span class="line">    V = np.zeros(env.nS)</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        delta = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(env.nS):</span><br><span class="line">            v = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-keyword">for</span> a, action_prob <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(policy[s]):</span><br><span class="line">                <span class="hljs-keyword">for</span> prob, next_state, reward, done <span class="hljs-keyword">in</span> env.P[s][a]:</span><br><span class="line">                    v += action_prob * prob * (reward + gamma * V[next_state])</span><br><span class="line">            delta = <span class="hljs-built_in">max</span>(delta, np.<span class="hljs-built_in">abs</span>(v - V[s]))</span><br><span class="line">            V[s] = v</span><br><span class="line">        <span class="hljs-keyword">if</span> delta &lt; theta:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">    <span class="hljs-keyword">return</span> np.array(V)</span><br></pre></td></tr></tbody></table></figure>
<p>输入策略为随机选择方向，运行上面的policy_evaluate最终多轮收敛后的V值输出为</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[  <span class="hljs-number">0.</span>         -<span class="hljs-number">13.99931242</span> -<span class="hljs-number">19.99901152</span> -<span class="hljs-number">21.99891199</span>]</span><br><span class="line"> [-<span class="hljs-number">13.99931242</span> -<span class="hljs-number">17.99915625</span> -<span class="hljs-number">19.99908389</span> -<span class="hljs-number">19.99909436</span>]</span><br><span class="line"> [-<span class="hljs-number">19.99901152</span> -<span class="hljs-number">19.99908389</span> -<span class="hljs-number">17.99922697</span> -<span class="hljs-number">13.99942284</span>]</span><br><span class="line"> [-<span class="hljs-number">21.99891199</span> -<span class="hljs-number">19.99909436</span> -<span class="hljs-number">13.99942284</span>   <span class="hljs-number">0.</span>        ]]</span><br></pre></td></tr></tbody></table></figure>
在3D V值图中可以发现，由于是随机选择方向的策略，
Agent在每个格子的V值绝对数值要比最佳V值大，意味着随机策略下Agent在Grid
World会得到更多的负reward。
<figure>
<img src="/zh/2020/rl-sutton-gridworld-1/random_policy_v.png">
<figcaption>
Grid World随机策略V值
</figcaption>
</figure>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/" itemprop="url">组合游戏系列5: 井字棋、五子棋AlphaGo Zero 算法实战</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-08-21T18:45:01.000Z" itemprop="datePublished">8月 22 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 读完 (约 3517 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>上一篇我们从原理层面解析了AlphaGo
Zero如何改进MCTS算法，通过不断自我对弈，最终实现从零棋力开始训练直至能够打败任何高手。在本篇中，我们在已有的N子棋OpenAI
Gym 环境中用Pytorch实现一个简化版的AlphaGo Zero算法。本篇所有代码在 <a target="_blank" rel="noopener" href="https://github.com/MyEncyclopedia/ConnectNGym">github
MyEncyclopedia/ConnectNGym</a> 中，其中部分参考了SongXiaoJun 的 <a target="_blank" rel="noopener" href="https://github.com/junxiaosong/AlphaZero_Gomoku">AlphaZero_Gomoku</a>。</p>
<ul>
<li><p><a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></p></li>
<li><p><strong><a href="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></strong></p></li>
</ul>
<h2 id="alphago-zero-mcts-树节点">AlphaGo Zero MCTS 树节点</h2>
<p>上一篇中，我们知道AlphaGo Zero 的MCTS树搜索是基于传统MCTS 的UCT （UCB
for Tree）的改进版PUCT（Polynomial Upper Confidence
Trees）。局面节点的PUCT值由两部分组成，分别是代表Exploitation的action
value Q值，和代表Exploration的U值。 <span class="math display">\[
PUCT(s, a) =Q(s,a) + U(s,a)
\]</span> U值计算由这些参数决定：系数<span class="math inline">\(c_{puct}\)</span>，节点先验概率P(s, a)
，父节点访问次数，本节点的访问次数。具体公式如下 <span class="math display">\[
U(s, a)=c_{p u c t} \cdot P(s, a) \cdot \frac{\sqrt{\Sigma_{b} N(s,
b)}}{1+N(s, a)}
\]</span></p>
<p>因此在实现过程中，对于一个树节点来说，需要保存其Q值、节点访问次数
_visit_num和先验概率 _prior。其中，_prior在节点初始化后不变，Q值和
<em>visit_num随着游戏MCTS模拟进程而改变。此外，节点保存了</em>
parent和_children变量，用于维护父子关系。c_puct为class
variable，作为全局参数。 </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    MCTS Tree Node</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line"></span><br><span class="line">    c_puct: ClassVar[<span class="hljs-built_in">int</span>] = <span class="hljs-number">5</span>  <span class="hljs-comment"># class-wise global param c_puct, exploration weight factor.</span></span><br><span class="line"></span><br><span class="line">    _parent: TreeNode</span><br><span class="line">    _children: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">int</span>, TreeNode]  <span class="hljs-comment"># map from action to TreeNode</span></span><br><span class="line">    _visit_num: <span class="hljs-built_in">int</span></span><br><span class="line">    _Q: <span class="hljs-built_in">float</span>   <span class="hljs-comment"># Q value of the node, which is the mean action value.</span></span><br><span class="line">    _prior: <span class="hljs-built_in">float</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>和上面的计算公式相对应，下列代码根据节点状态计算PUCT(s, a)。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_puct</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">float</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Computes AlphaGo Zero PUCT (polynomial upper confidence trees) of the node.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :return: Node PUCT value.</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        U = (TreeNode.c_puct * self._prior * np.sqrt(self._parent._visit_num) / (<span class="hljs-number">1</span> + self._visit_num))</span><br><span class="line">        <span class="hljs-keyword">return</span> self._Q + U</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>AlphaGo Zero
MCTS在playout时遇到已经被展开的节点，会根据selection规则选择子节点，该规则本质上是在所有子节点中选择最大的PUCT值的节点。</p>
<p><span class="math display">\[
a=\operatorname{argmax}_a(PUCT(s, a))=\operatorname{argmax}_a(Q(s,a) +
U(s,a))
\]</span></p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[Pos, TreeNode]:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Selects an action(Pos) having max UCB value.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :return: Action and corresponding node</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self._children.items(), key=<span class="hljs-keyword">lambda</span> act_node: act_node[<span class="hljs-number">1</span>].get_puct())</span><br></pre></td></tr></tbody></table></figure>
<p>新的叶节点一旦在playout时产生，关联的 v
值会一路向上更新至根节点，具体新节点的v值将在下一节中解释。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">propagate_to_root</span>(<span class="hljs-params">self, leaf_value: <span class="hljs-built_in">float</span></span>):</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Updates current node with observed leaf_value and propagates to root node.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param leaf_value:</span></span><br><span class="line"><span class="hljs-string">        :return:</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self._parent:</span><br><span class="line">            self._parent.propagate_to_root(-leaf_value)</span><br><span class="line">        self._update(leaf_value)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_update</span>(<span class="hljs-params">self, leaf_value: <span class="hljs-built_in">float</span></span>):</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Updates the node by newly observed leaf_value.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param leaf_value:</span></span><br><span class="line"><span class="hljs-string">        :return:</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        self._visit_num += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># new Q is updated towards deviation from existing Q</span></span><br><span class="line">        self._Q += <span class="hljs-number">0.5</span> * (leaf_value - self._Q)</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="alphago-zero-mcts-player-实现">AlphaGo Zero MCTS Player
实现</h2>
<p>AlphaGo Zero MCTS
在训练阶段分为如下几个步骤。游戏初始局面下，整个局面树的建立由子节点的不断被探索而丰富起来。AlphaGo
Zero对弈一次即产生了一次完整的游戏开始到结束的动作系列。在对弈过程中的某一游戏局面，需要采样海量的playout，又称MCTS模拟，以此来决定此局面的下一步动作。一次playout可视为在真实游戏状态树的一种特定采样，playout可能会产生游戏结局，生成真实的v值；也可能explore
到新的叶子节点，此时v值依赖策略价值网络的输出，目的是利用训练的神经网络来产生高质量的游戏对战局面。每次playout会从当前给定局面递归向下，向下的过程中会遇到下面三种节点情况。</p>
<ul>
<li>若局面节点是游戏结局（叶子节点），可以得到游戏的真实价值
z。从底部节点带着z向上更新沿途节点的Q值，直至根节点（初始局面）。</li>
<li>若局面节点从未被扩展过（叶子节点），此时会将局面编码输入到策略价值双头网络，输出结果为网络预估的action分布和v值。Action分布作为节点先验概率P(s,
a)来初始化子节点，预估的v值和上面真实游戏价值z一样，从叶子节点向上沿途更新到根节点。</li>
<li>若局面节点已经被扩展过，则根据PUCT的select规则继续选择下一节点。</li>
</ul>
<p>海量的playout模拟后，建立了游戏状态树的节点信息。但至此，AI玩家只是收集了信息，还仍未给定局面落子，而落子的决定由Play规则产生。下图展示了给定局面（Current节点）下，MCST模拟进行的多次playout探索后生成的局面树，play规则根据这些节点信息，产生Current
节点的动作分布 <span class="math inline">\(\pi\)</span>
，确定下一步落子。</p>
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/mcts_game_tree.png">
<figcaption>
MCTS Playout和Play关系
</figcaption>
</figure>
<h3 id="play-给定局面">Play 给定局面</h3>
<p>对于当前需要做落子决定的某游戏局面<span class="math inline">\(s_0\)</span>，根据如下play公式生成落子分布 $$
，子局面的落子概率正比于其访问次数的某次方。其中，某次方的倒数称为温度参数（Temperature）。</p>
<p><span class="math display">\[
\pi\left(a \mid s_{0}\right)=\frac{N\left(s_{0}, a\right)^{1 /
\tau}}{\sum_{b} N\left(s_{0}, b\right)^{1 / \tau}}
\]</span></p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MCTSAlphaGoZeroPlayer</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_next_step_play_act_probs</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">List</span>[Pos], ActionProbs]:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        For the given game status, run playouts number of times specified by self._playout_num.</span></span><br><span class="line"><span class="hljs-string">        Returns the action distribution according to AlphaGo Zero MCTS play formula.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param game:</span></span><br><span class="line"><span class="hljs-string">        :return: actions and their probability</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._playout_num):</span><br><span class="line">            self._playout(copy.deepcopy(game))</span><br><span class="line"></span><br><span class="line">        act_visits = [(act, node._visit_num) <span class="hljs-keyword">for</span> act, node <span class="hljs-keyword">in</span> self._current_root._children.items()]</span><br><span class="line">        acts, visits = <span class="hljs-built_in">zip</span>(*act_visits)</span><br><span class="line">        act_probs = softmax(<span class="hljs-number">1.0</span> / MCTSAlphaGoZeroPlayer.temperature * np.log(np.array(visits) + <span class="hljs-number">1e-10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> acts, act_probs</span><br></pre></td></tr></tbody></table></figure>
<p>在训练模式时，考虑到偏向exploration的目的，在<span class="math inline">\(\pi\)</span> 落子分布的基础上增加了 Dirichlet
分布。</p>
<p><span class="math display">\[
P(s,a) = (1-\epsilon)*\pi(a \mid s) + \epsilon * \boldsymbol{\eta} \quad
(\boldsymbol{\eta} \sim \operatorname{Dir}(0.3))
\]</span> </p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MCTSAlphaGoZeroPlayer</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_action</span>(<span class="hljs-params">self, board: PyGameBoard</span>) -&gt; Pos:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Method defined in BaseAgent.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param board:</span></span><br><span class="line"><span class="hljs-string">        :return: next move for the given game board.</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._get_action(copy.deepcopy(board.connect_n_game))[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[MoveWithProb]:</span></span><br><span class="line">        epsilon = <span class="hljs-number">0.25</span></span><br><span class="line">        avail_pos = game.get_avail_pos()</span><br><span class="line">        move_probs: ActionProbs = np.zeros(game.board_size * game.board_size)</span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(avail_pos) &gt; <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># the pi defined in AlphaGo Zero paper</span></span><br><span class="line">        acts, act_probs = self._next_step_play_act_probs(game)</span><br><span class="line">        move_probs[<span class="hljs-built_in">list</span>(acts)] = act_probs</span><br><span class="line">        <span class="hljs-keyword">if</span> self._is_training:</span><br><span class="line">            <span class="hljs-comment"># add Dirichlet Noise when training in favour of exploration</span></span><br><span class="line">            p_ = (<span class="hljs-number">1</span>-epsilon) * act_probs + epsilon * np.random.dirichlet(<span class="hljs-number">0.3</span> * np.ones(<span class="hljs-built_in">len</span>(act_probs)))</span><br><span class="line">            move = np.random.choice(acts, p=p_)</span><br><span class="line">            <span class="hljs-keyword">assert</span> move <span class="hljs-keyword">in</span> game.get_avail_pos()</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            move = np.random.choice(acts, p=act_probs)</span><br><span class="line"></span><br><span class="line">        self.reset()</span><br><span class="line">        <span class="hljs-keyword">return</span> move, move_probs</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="一次完整的对弈">一次完整的对弈</h3>
<p>一次完整的AI对弈就是从初始局面迭代play直至游戏结束，对弈生成的数据是一系列的
$(s, , z) $。</p>
<p>如下图 s0 到 s5
是某次井字棋的对弈。最终结局是先手黑棋玩家赢，即对于黑棋玩家 z =
+1。需要注意的是：z = +1 是对于所有黑棋面临的局面，即s0, s2,
s4，而对应的其余白棋玩家来说 z = -1。</p>
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/self_play.png">
<figcaption>
一局完整对弈
</figcaption>
</figure>
<div>
<p><span class="math display">\[
\begin{align*}
&amp;0: (s_0,  \vec{\pi_0}, +1)  \\
&amp;1: (s_1,  \vec{\pi_1}, -1) \\
&amp;2: (s_2,  \vec{\pi_2}, +1) \\
&amp;3: (s_3,  \vec{\pi_3}, -1) \\
&amp;4: (s_4,  \vec{\pi_4}, +1)
\end{align*}
\]</span></p>
</div>
<p>以下代码展示如何在AI对弈时收集数据 $(s, , z) $</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MCTSAlphaGoZeroPlayer</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self_play_one_game</span>(<span class="hljs-params">self, game: ConnectNGame</span>) \</span></span><br><span class="line"><span class="hljs-function">            -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[NetGameState, ActionProbs, NDArray[(<span class="hljs-type">Any</span>), np.<span class="hljs-built_in">float</span>]]]:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param game:</span></span><br><span class="line"><span class="hljs-string">        :return:</span></span><br><span class="line"><span class="hljs-string">            Sequence of (s, pi, z) of a complete game play. The number of list is the game play length.</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line"></span><br><span class="line">        states: <span class="hljs-type">List</span>[NetGameState] = []</span><br><span class="line">        probs: <span class="hljs-type">List</span>[ActionProbs] = []</span><br><span class="line">        current_players: <span class="hljs-type">List</span>[np.<span class="hljs-built_in">float</span>] = []</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> game.game_over:</span><br><span class="line">            move, move_probs = self._get_action(game)</span><br><span class="line">            states.append(convert_game_state(game))</span><br><span class="line">            probs.append(move_probs)</span><br><span class="line">            current_players.append(game.current_player)</span><br><span class="line">            game.move(move)</span><br><span class="line"></span><br><span class="line">        current_player_z = np.zeros(<span class="hljs-built_in">len</span>(current_players))</span><br><span class="line">        current_player_z[np.array(current_players) == game.game_result] = <span class="hljs-number">1.0</span></span><br><span class="line">        current_player_z[np.array(current_players) == -game.game_result] = -<span class="hljs-number">1.0</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(states, probs, current_player_z))</span><br></pre></td></tr></tbody></table></figure>
<h3 id="playout-代码实现">Playout 代码实现</h3>
<p>一次playout会从当前局面根据PUCT
selection规则下沉到叶子节点，如果此叶子节点非游戏终结点，则会扩展当前节点生成下一层新节点，其先验分布由策略价值网络输出的action分布决定。一次playout最终会得到叶子节点的
v 值，并沿着MCTS树向上更新沿途的所有父节点 Q值。
从上一篇文章已知，游戏节点的数量随着参数而指数级增长，举例来说，井字棋（k=3，m=n=3）的状态数量是5478，k=3，m=n=4时是6035992
，k=m=n=4时是9722011
。如果我们将初始局面节点作为根节点，同时保存海量playout探索得到的局面节点，实现时会发现我们无法将所有探索到的局面节点都保存在内存中。这里的一种解决方法是在一次self
play中每轮playout之后，将根节点重置成落子的节点，从而有效控制整颗局面树中的节点数量。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MCTSAlphaGoZeroPlayer</span>(<span class="hljs-params">BaseAgent</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_playout</span>(<span class="hljs-params">self, game: ConnectNGame</span>):</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        From current game status, run a sequence down to a leaf node, either because game ends or unexplored node.</span></span><br><span class="line"><span class="hljs-string">        Get the leaf value of the leaf node, either the actual reward of game or action value returned by policy net.</span></span><br><span class="line"><span class="hljs-string">        And propagate upwards to root node.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param game:</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        player_id = game.current_player</span><br><span class="line"></span><br><span class="line">        node = self._current_root</span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> node.is_leaf():</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">            act, node = node.select()</span><br><span class="line">            game.move(act)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># now game state is a leaf node in the tree, either a terminal node or an unexplored node</span></span><br><span class="line">        act_and_probs: Iterator[MoveWithProb]</span><br><span class="line">        act_and_probs, leaf_value = self._policy_value_net.policy_value_fn(game)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> game.game_over:</span><br><span class="line">            <span class="hljs-comment"># case where encountering an unexplored leaf node, update leaf_value estimated by policy net to root</span></span><br><span class="line">            <span class="hljs-keyword">for</span> act, prob <span class="hljs-keyword">in</span> act_and_probs:</span><br><span class="line">                game.move(act)</span><br><span class="line">                child_node = node.expand(act, prob)</span><br><span class="line">                game.undo()</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># case where game ends, update actual leaf_value to root</span></span><br><span class="line">            <span class="hljs-keyword">if</span> game.game_result == ConnectNGame.RESULT_TIE:</span><br><span class="line">                leaf_value = ConnectNGame.RESULT_TIE</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                leaf_value = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> game.game_result == player_id <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span></span><br><span class="line">            leaf_value = <span class="hljs-built_in">float</span>(leaf_value)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># Update leaf_value and propagate up to root node</span></span><br><span class="line">        node.propagate_to_root(-leaf_value)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="编码游戏局面">编码游戏局面</h2>
<p>为了将信息有效的传递给策略神经网络，必须从当前玩家的角度编码游戏局面。局面不仅要反映棋盘上黑白棋子的位置，也需要考虑最后一个落子的位置以及是否为当前玩家棋局。因此，我们将某局面按照当前玩家来编码，返回类型为4个棋盘大小组成的ndarray，即shape
[4, board_size, board_size]，其中</p>
<ol type="1">
<li>第一个数组编码当前玩家的棋子位置</li>
<li>第二个数组编码对手玩家棋子位置</li>
<li>第三个表示最后落子位置</li>
<li>第四个全1表示此局面为先手（黑棋）局面，全0表示白棋局面</li>
</ol>
<p>例如之前游戏对弈中的前四步：</p>
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/self_play_first_3.jpg">
<figcaption>
</figcaption>
</figure>
<p>s1-&gt;s2 后局面s2的编码：当前玩家为黑棋玩家，编码局面s2
返回如下ndarray，数组[0]
为s2黑子位置，[1]为白子位置，[2]表示最后一个落子(1, 1) ，[3]
全1表示当前是黑棋落子的局面。</p>
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/s2_state.jpg">
<figcaption>
编码黑棋玩家局面 s2
</figcaption>
</figure>
s2-&gt;s3 后局面s3的编码：当前玩家为白棋玩家，编码返回如下，数组[0]
为s3白子位置，[1]为黑子位置，[2]表示最后一个落子(1, 0) ，[3]
全0表示当前是白棋落子的局面。
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/s3_state.jpg">
<figcaption>
编码白棋玩家局面 s3
</figcaption>
</figure>
<p>具体代码实现如下。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NetGameState = NDArray[(<span class="hljs-number">4</span>, <span class="hljs-type">Any</span>, <span class="hljs-type">Any</span>), np.<span class="hljs-built_in">int</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_game_state</span>(<span class="hljs-params">game: ConnectNGame</span>) -&gt; NetGameState:</span></span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Converts game state to type NetGameState as ndarray.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    :param game:</span></span><br><span class="line"><span class="hljs-string">    :return:</span></span><br><span class="line"><span class="hljs-string">        Of shape 4 * board_size * board_size.</span></span><br><span class="line"><span class="hljs-string">        [0] is current player positions.</span></span><br><span class="line"><span class="hljs-string">        [1] is opponent positions.</span></span><br><span class="line"><span class="hljs-string">        [2] is last move location.</span></span><br><span class="line"><span class="hljs-string">        [3] all 1 meaning move by black player, all 0 meaning move by white.</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    state_matrix = np.zeros((<span class="hljs-number">4</span>, game.board_size, game.board_size))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> game.action_stack:</span><br><span class="line">        actions = np.array(game.action_stack)</span><br><span class="line">        move_curr = actions[::<span class="hljs-number">2</span>]</span><br><span class="line">        move_oppo = actions[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]</span><br><span class="line">        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> move_curr:</span><br><span class="line">            state_matrix[<span class="hljs-number">0</span>][move] = <span class="hljs-number">1.0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> move_oppo:</span><br><span class="line">            state_matrix[<span class="hljs-number">1</span>][move] = <span class="hljs-number">1.0</span></span><br><span class="line">        <span class="hljs-comment"># indicate the last move location</span></span><br><span class="line">        state_matrix[<span class="hljs-number">2</span>][actions[-<span class="hljs-number">1</span>]] = <span class="hljs-number">1.0</span></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(game.action_stack) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">        state_matrix[<span class="hljs-number">3</span>][:, :] = <span class="hljs-number">1.0</span>  <span class="hljs-comment"># indicate the colour to play</span></span><br><span class="line">    <span class="hljs-keyword">return</span> state_matrix[:, ::-<span class="hljs-number">1</span>, :]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="策略价值网络训练">策略价值网络训练</h2>
<p>策略价值网络是一个共享参数 <span class="math inline">\(\theta\)</span>
的双头网络，给定上面的游戏局面编码会产生预估的p和v。</p>
<figure>
<img src="/zh/2020/combinatorial-game-5-alphago-zero-connect-n/policy_value_net.png">
</figure>
<p><span class="math display">\[
\vec{p_{\theta}}, v_{\theta}=f_{\theta}(s)
\]</span> 结合真实游戏对弈后产生三元组数据 $(s, , z) $
，按照论文中的loss 来训练神经网络。 <span class="math display">\[
l=\sum_{t}\left(v_{\theta}\left(s_{t}\right)-z_{t}\right)^{2}-\vec{\pi_{t}}
\cdot \log \left(\vec{p_{\theta}}\left(s_{t}\right)\right) + c {\lVert
\theta \rVert}^2
\]</span></p>
<p>下面代码为Pytorch backward部分。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward_step</span>(<span class="hljs-params">self, state_batch: <span class="hljs-type">List</span>[NetGameState], probs_batch: <span class="hljs-type">List</span>[ActionProbs],</span></span></span><br><span class="line"><span class="hljs-params"><span class="hljs-function">               value_batch: <span class="hljs-type">List</span>[NDArray[(<span class="hljs-params"><span class="hljs-type">Any</span></span>), np.<span class="hljs-built_in">float</span>]], lr</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>]:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> self.use_gpu:</span><br><span class="line">        state_batch = Variable(torch.FloatTensor(state_batch).cuda())</span><br><span class="line">        probs_batch = Variable(torch.FloatTensor(probs_batch).cuda())</span><br><span class="line">        value_batch = Variable(torch.FloatTensor(value_batch).cuda())</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        state_batch = Variable(torch.FloatTensor(state_batch))</span><br><span class="line">        probs_batch = Variable(torch.FloatTensor(probs_batch))</span><br><span class="line">        value_batch = Variable(torch.FloatTensor(value_batch))</span><br><span class="line"></span><br><span class="line">    self.optimizer.zero_grad()</span><br><span class="line">    <span class="hljs-keyword">for</span> param_group <span class="hljs-keyword">in</span> self.optimizer.param_groups:</span><br><span class="line">        param_group[<span class="hljs-string">'lr'</span>] = lr</span><br><span class="line"></span><br><span class="line">    log_act_probs, value = self.policy_value_net(state_batch)</span><br><span class="line">    <span class="hljs-comment"># loss = (z - v)^2 - pi*T * log(p) + c||theta||^2</span></span><br><span class="line">    value_loss = F.mse_loss(value.view(-<span class="hljs-number">1</span>), value_batch)</span><br><span class="line">    policy_loss = -torch.mean(torch.<span class="hljs-built_in">sum</span>(probs_batch * log_act_probs, <span class="hljs-number">1</span>))</span><br><span class="line">    loss = value_loss + policy_loss</span><br><span class="line">    loss.backward()</span><br><span class="line">    self.optimizer.step()</span><br><span class="line">    entropy = -torch.mean(torch.<span class="hljs-built_in">sum</span>(torch.exp(log_act_probs) * log_act_probs, <span class="hljs-number">1</span>))</span><br><span class="line">    <span class="hljs-keyword">return</span> loss.item(), entropy.item()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Wujy7OzvdJk&amp;t=358s">Youtube,
Deepmind AlphaZero - Mastering Games Without Human Knowledge, David
Silver</a></p></li>
<li><p>Mastering the game of Go with deep neural networks and tree
search</p></li>
<li><p>Mastering Chess and Shogi by Self-Play with a General
Reinforcement Learning Algorithm</p></li>
<li><p><a target="_blank" rel="noopener" href="http://xtf615.com/2018/02/12/AlphaGo-Zero/">AlphaGo
Zero论文解析</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32089487">AlphaZero实战：从零学下五子棋（附代码）</a></p></li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/" itemprop="url">组合游戏系列4: AlphaGo Zero 强化学习算法原理深度分析</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-08-07T18:45:01.000Z" itemprop="datePublished">8月 8 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            24 分钟 读完 (约 3527 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>AlphaGo Zero是Deepmind
最后一代AI围棋算法，因为已经达到了棋类游戏AI的终极目的：给定任何游戏规则，AI从零出发只通过自我对弈的方式提高，最终可以取得超越任何对手（包括顶级人类棋手和上一代AlphaGo）的能力。换种方式说，当给定足够多的时间和计算资源，可以取得无限逼近游戏真实解的能力。这一篇，我们深入分析AlphaGo
Zero的设计理念和关键组件的细节并解释组件之间的关联。下一篇中，我们将在已有的N子棋OpenAI
Gym 环境中用Pytorch实现一个简化版的AlphaGo Zero算法。</p>
<ul>
<li><p><a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></p></li>
<li><p><strong><a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></strong></p></li>
<li><p><a href="/zh/2020/combinatorial-game-4-alphago-zero-theory/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></p></li>
</ul>
<h2 id="alphago-zero-综述">AlphaGo Zero 综述</h2>
<p>AlphaGo Zero 作为Deepmind在围棋领域的最后一代AI
Agent，已经可以达到棋类游戏的终极目标：在只给定游戏规则的情况下，AI
棋手从最初始的随机状态开始，通过不断的自我对弈的强化学习来实现超越以往任何人类棋手和上一代Alpha的能力，并且同样的算法和模型应用到了其他棋类也得出相同的效果。这一篇，从原理上来解析AlphaGo
Zero的运行方式。</p>
<p>AlphaGo Zero
算法由三种元素构成：强化学习（RL）、深度学习（DL）和蒙特卡洛树搜索（MCTS，Monte
Carlo Tree Search）。核心思想是基于神经网络的Policy
Iteration强化学习，即最终学的是一个深度学习的policy
network，输入是某棋盘局面 s，输出是此局面下可走位的概率分布：<span class="math inline">\(p(a|s)\)</span>。</p>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/policy_net.png">
</figure>
<p>在第一代AlphaGo算法中，这个初始policy
network通过收集专业人类棋手的海量棋局训练得来，再采用传统RL 的Monte
Carlo Tree Search Rollout 技术来强化现有的AI对于局面落子（Policy
Network）的判断。Monte Carlo Tree Search Rollout
简单说来就是海量棋局模拟，AI Agent在通过现有的Policy
Network策略完成一次从某局面节点到最终游戏胜负结束的对弈，这个完整的对弈叫做rollout，又称playout。完成一次rollout之后，通过局面树层层回溯到初始局面节点，并在回溯过程中同步修订所有经过的局面节点的统计指标，修正原先policy
network对于落子导致输赢的判断。通过海量并发的棋局模拟来提升基准policy
network，即在各种局面下提高好的落子的<span class="math inline">\(p(a_{win}|s)\)</span>，降低坏的落子的<span class="math inline">\(p(a_{lose}|s)\)</span></p>
举例如下井字棋局面：
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/pos.png">
<figcaption>
局面s
</figcaption>
</figure>
<p>基准policy network返回 p(s) 如下 <span class="math display">\[
p(a|s) =  
\begin{align*}
  \left\lbrace
  \begin{array}{r@{}l}
    0.1, &amp; &amp; a = (0,2) \\
    0.05, &amp; &amp; a = (1,0) \\
     0.5, &amp; &amp; a = (1,1) \\
     0.05, &amp; &amp; a = (1,2)\\
     0.2, &amp; &amp; a = (2,0) \\
    0.05, &amp; &amp; a = (2,1) \\
    0.05, &amp; &amp; a = (2,2)
  \end{array}
  \right.
\end{align*}
\]</span> 通过海量并发模拟后，修订成如下的action概率分布，然后通过policy
iteration迭代新的网络来逼近 <span class="math inline">\(p'\)</span>
就提高了棋力。 <span class="math display">\[
p'(a|s) =  
\begin{align*}
  \left\lbrace
  \begin{array}{r@{}l}
   0, &amp; &amp; a = (0,2) \\
    0, &amp; &amp; a = (1,0) \\
     0.9, &amp; &amp; a = (1,1) \\
     0, &amp; &amp; a = (1,2)\\
     0, &amp; &amp; a = (2,0) \\
    0, &amp; &amp; a = (2,1) \\
    0.1, &amp; &amp; a = (2,2)
  \end{array}
  \right.
\end{align*}
\]</span></p>
<h2 id="蒙特卡洛树搜索mcts概述">蒙特卡洛树搜索（MCTS）概述</h2>
<p>Monte Carlo Tree Search 是Monte Carlo
在棋类游戏中的变种，棋类游戏的一大特点是可以用动作(move)联系的决策树来表示，树的节点数量取决于分支的数量和树的深度。MCTS的目的是在树节点非常多的情况下，通过实验模拟（rollout,
playout）的方式来收集尽可能多的局面输赢情况，并基于这些统计信息，将搜索资源的重点均衡地放在未被探索的节点和值得探索的节点上，减少在大概率输的节点上的模拟资源投入。传统MCTS有四个过程：Selection,
Expansion, Simulation 和Backpropagation。下图是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Wikipedia</a>
的例子：</p>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/MCTS_selection.png">
</figure>
<ul>
<li>Selection：从根节点出发，根据现有统计的信息和selection规则，选择子节点递归向下做决定，后面我们会详细介绍AlphaGo的UCB规则。图中节点的数字，例如根节点11/21，分别代表赢的次数和总模拟次数。从根节点一路向下分别选择节点
7/10, 1/6直到叶子节点3/3，叶子节点表示它未被探索过。</li>
</ul>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/MCTS_expansion.png">
</figure>
<ul>
<li>Expansion：由于3/3节点未被探索过，初始化其所有子节点为0/0，图中3/3只有一个子节点。后面我们会看到神经网络在初始化子节点的时候起到的指导作用，即所有子节点初始权重并非相同，而是由神经网络给出估计。</li>
</ul>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/MCTS_simulation.png">
</figure>
<ul>
<li>Simulation：重复selection和expansion，根据游戏规则递归向下直至游戏结束。</li>
</ul>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/MCTS_backprop.png">
</figure>
<ul>
<li>Backpropagation：游戏结束在终点节点产生游戏真实的价值，回溯向上调整所有父节点的统计状态。</li>
</ul>
<h3 id="权衡-exploration-和-exploitation">权衡 Exploration 和
Exploitation</h3>
<p>在不断扩张决策树并收集节点统计信息的同时，MCTS根据规则来权衡探索目的（采样不足）或利用目的来做决策，这个权衡规则叫做Upper
Confidence
Bound（UCB）。典型的UCB公式如下：w表示通过节点的赢的次数，n表示通过节点的总次数，N是父节点的访问次数，c是调节Exploration
和 Exploitation权重的超参。</p>
<p><span class="math display">\[
{\frac{w_i}{n_i}} + c \sqrt{\frac{\ln N_i}{n_i}}
\]</span></p>
<p>假设某节点有两个子节点s1, s2，它们的统计指标为 s1: w/n = 3/4，s2: w/n
=
6/8，由于两者输赢比率一样，因此根据公式，访问次数少的节点出于Exploration的目的胜出，MCTS最终决定从s局面走向s1。</p>
<h2 id="从第一性原理来理解alphago-zero">从第一性原理来理解AlphaGo
Zero</h2>
<p>前一代的AlphaGo已经战胜了世界冠军，取得了空前的成就，AlphaGo Zero
的设计目标变得更加General，去除围棋相关的处理和知识，用统一的框架和算法来解决棋类问题。
1. 无人工先验数据</p>
<p>改进之前需要专家棋手对弈数据来冷启动初始棋力</p>
<ol start="2" type="1">
<li><p>无特定游戏特征工程</p>
<p>无需围棋特定技巧，只包含下棋规则，可以适用到所有棋类游戏</p></li>
<li><p>单一神经网络</p>
<p>统一Policy Network和Value
Network，使用一个共享参数的双头神经网络</p></li>
<li><p>简单树搜索</p>
<p>去除传统MCTS的Rollout
方式，用神经网络来指导MCTS更有效产生搜索策略</p></li>
</ol>
<h3 id="搜索空间的两个优化原则">搜索空间的两个优化原则</h3>
尽管理论上围棋是有解的，即先手必赢、被逼平或必输，通过遍历所有可能局面可以求得解。同理，通过海量模拟所有可能游戏局面，也可以无限逼近所有局面下的真实输赢概率，直至收敛于局面落子的确切最佳结果。但由于围棋棋局的数目远远大于宇宙原子数目，3^361
&gt;&gt;
10^80，因此需要将计算资源有效的去模拟值得探索的局面，例如对于显然的被动局面减小模拟次数，所以如何有效地减小搜索空间是AlphaGo
Zero 需要解决的重大问题。David Silver 在<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Wujy7OzvdJk&amp;t=358s">Deepmind
AlphaZero - Mastering Games Without Human Knowledge</a>中提到AlphaGo
Zero 采用两个原则来有效减小搜索空间。
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/exhaustive_search.png">
</figure>
<h4 id="原则1-通过value-network减少搜索的深度">原则1: 通过Value
Network减少搜索的深度</h4>
Value Network
通过预测给定局面的value来直接预测最终结果，思想和上一期Minimax DP
策略中直接缓存当前局面的胜负状态一样，减少每次必须靠模拟到最后才能知道当前局面的输赢概率，或者需要多层树搜索才能知道输赢概率。
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/value_net.png">
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/reduce_depth.png">
</figure>
<h4 id="原则2-通过policy-network减少搜索的宽度">原则2: 通过Policy
Network减少搜索的宽度</h4>
搜索广度的减少是由Policy
Network预估来达成的，将下一步搜索局限在高概率的动作上，大幅度提升原先MCTS新节点生成后冷启动的搜索宽度。
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/reduce_breadth.png">
</figure>
<h3 id="神经网络结构">神经网络结构</h3>
<p>AlphaGo Zero 使用一个单一的深度神经网络来完成policy
和value的预测。具体实现方式是将policy network和value
network合并成一个共享参数 $ $
的双头网络。其中z是真实游戏结局的效用，范围为[-1, 1] 。</p>
<p><span class="math display">\[
(p, v)=f_{\theta}(s)
\]</span> <span class="math display">\[
p_{a}=\operatorname{Pr}(a \mid s)
\]</span> <span class="math display">\[
v =  \mathop{\mathbb{E}}[z|s]
\]</span></p>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/policy_value_net.png">
</figure>
<p>Monte Carlo Tree Search (MCTS)
建立了棋局搜索树，节点的初始状态由神经网络输出的p和v值来估计，由此初始的动作策略和价值预判就会建立在高手的水平之上。模拟一局游戏之后向上回溯，会同步更新路径上节点的统计数值并生成更好的MCTS搜索策略
<span class="math inline">\(\vec{\pi}\)</span>。进一步来看，MCTS和神经网络互相形成了正循环。神经网络指导了未知节点的MCTS初始搜索策略，产生自我对弈游戏结局后，通过减小
<span class="math inline">\(\vec{p}\)</span> 和<span class="math inline">\(\vec{\pi}\)</span>的 Loss
，最终又提高了神经网络对于局面的估计能力。神经网络value
network的提升也是通过不断减小网络预测的结果和最终结果的差异来提升。
因此，具体神经网络的Loss函数由三部分组成，value network的损失，policy
network的损失以及正则项。 <span class="math display">\[
l=\sum_{t}\left(v_{\theta}\left(s_{t}\right)-z_{t}\right)^{2}-\vec{\pi}_{t}
\cdot \log \left(\vec{p}_{\theta}\left(s_{t}\right)\right) + c {\lVert
\theta \rVert}^2
\]</span></p>
<h3 id="alphago-zero-mcts-具体过程">AlphaGo Zero MCTS 具体过程</h3>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/self-play.png">
<figcaption>
AlphaGo Plays Games Against Itself
</figcaption>
</figure>
<p>AlphaGo Zero的MCTS和传统MCTS都有相似的四个过程，但AlphaGo
Zero的MCTS步骤相对更复杂。 首先，除了W/N统计指标之外，AlphaGo
Zero的MCTS保存了决策边 a|s 的Q(s,a)：Action
Value，也就是Q-Learning中的Q值，其初始值由神经网络给出。此外，Q
值也用于串联自底向上更新节点的Value值。具体说来，当某个新节点被Explore后，会将网络给出的Q值向上传递，并逐层更新父节点的Q值。当游戏结局产生时，也会向上更新所有父节点的Q值。
此外对于某一游戏局面s进行多次模拟，每次在局面s出发向下探索，每次探索在已知节点按Selection规则深入一步，直至达到未探索的局面或者游戏结束，产生Q值后向上回溯到最初局面s，回溯过程中更新路径上的局面的统计值或者Q值。在多次模拟结束后根据Play的算法，决定局面s的下一步行动。尽管每次模拟探索可能会深入多层，但最终play阶段的算法规则仅决定给定局面s的下一层落子动作。多次向下探索的优势在于：</p>
<ol type="1">
<li><p>探索和采样更多的叶子节点，在更多信息下做决策。</p></li>
<li><p>通过average
out多次模拟下一层落子决定，尽可能提升MCTS策略的下一步判断能力，提高
<span class="math inline">\(\pi\)</span>
能力，更有效指导神经网络，提高其学习效率。</p></li>
</ol>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/MCTS_alphago.png">
<figcaption>
New Policy Network V' is Trained to Predict Winner
</figcaption>
</figure>
<ol type="1">
<li>Selection:</li>
</ol>
<p>从游戏局面s开始，选择a向下递归，直至未展开的节点（搜索树中的叶子节点）或者游戏结局。具体在局面s下选择a的规则由以下UCB(Upper
Confidence Bound)决定<br>
<span class="math display">\[
a=\operatorname{argmax}_a(Q(s,a) + u(s,a))
\]</span></p>
<p>其中，Q(s,a) 和u(s,a) 项分别代表Exploitation
和Exploration。两项相加来均衡Exploitation和Exploration，保证初始时每个节点被explore，在有足够多的信息时逐渐偏向exploitation。</p>
<p><span class="math display">\[
u(s, a)=c_{p u c t} \cdot P(s, a) \cdot \frac{\sqrt{\Sigma_{b} N(s,
b)}}{1+N(s, a)}
\]</span></p>
<ol start="2" type="1">
<li>Expand</li>
</ol>
<p>当遇到一个未展开的节点（搜索树中的叶子节点）时，对其每个子节点使用现有网络进行预估，即</p>
<p><span class="math display">\[
(p(s), v(s))=f_{\theta}(s)
\]</span></p>
<ol start="3" type="1">
<li>Backup</li>
</ol>
<p>当新的叶子节点展开时或者到达终点局面时，向上更新父节点的Q值，具体公式为
<span class="math display">\[
Q(s, a)=\frac{1}{N(s, a)} \sum_{s^{\prime} \mid s, a \rightarrow
s^{\prime}} V\left(s^{\prime}\right)
\]</span></p>
<ol start="4" type="1">
<li>Play</li>
</ol>
<p>多次模拟结束后，使用得到搜索概率分布 $<em>{a}
$来确定最终的落子动作。正比于访问次数的某次方 $ </em>{a} N(s, a)^{1 /
}<span class="math inline">\(，其中\)</span>$为温度参数（temperature
parameter）。</p>
<figure>
<img src="/zh/2020/combinatorial-game-4-alphago-zero-theory/net_training.png">
<figcaption>
New Policy Network V' is Trained to Predict Winner
</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Wujy7OzvdJk&amp;t=358s">Youtube,
Deepmind AlphaZero - Mastering Games Without Human Knowledge, David
Silver</a></p></li>
<li><p>Mastering the game of Go with deep neural networks and tree
search</p></li>
<li><p>Mastering Chess and Shogi by Self-Play with a General
Reinforcement Learning Algorithm</p></li>
<li><p><a target="_blank" rel="noopener" href="http://xtf615.com/2018/02/12/AlphaGo-Zero/">AlphaGo
Zero论文解析</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32089487">AlphaZero实战：从零学下五子棋（附代码）</a></p></li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <aside id='article-toc' role="navigation" class='fixed'>
        <div id='article-toc-inner'>
            
        </div>
        
        </aside>
                <style>
            #article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before {
                content: "";
                display: table
            }
            
            #article-toc-inner:after,.inner:after {
                clear: both
            }
            @media screen {
                #article-toc-inner,.inner {
                    padding: 0 20px
                }
            }
            #article-toc {
                display: none;
                float: left;
                width: 25%;
                margin-left: -220px;
                opacity: .8
            }
            @media screen and (min-width:769px) {
                #article-toc {
                    display: block
                }
            }
 
           #article-toc.fixed {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 10 px;
                padding-top: 55px;
            }
            .fixed #article-toc-inner {
                position: fixed;
                width: 220px;
                top: 0;
                bottom: 0;
                padding-top: 55px;
            }
            </style>
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/zh/2020/combinatorial-game-2-tictactoe/" itemprop="url">组合游戏系列2: 井字棋Leetcode系列题解和Minimax最佳策略实现</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2020-07-11T18:45:01.000Z" itemprop="datePublished">7月 12 2020</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Tech-Blog/">Tech Blog</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 读完 (约 4735 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>继上一篇介绍了Minimax 和Alpha Beta
剪枝算法之后，本篇选择了Leetcode中的井字棋游戏题目，积累相关代码后实现井字棋游戏并扩展到五子棋和N子棋（战略井字棋），随后用Minimax和Alpha
Beta剪枝算法解得小规模下N子棋的游戏结局，并分析其状态数量和每一步的最佳策略。后续篇章中，我们基于本篇代码完成一个N子棋的OpenAI
Gym
图形环境，可用于人机对战或机器对战，并最终实现棋盘规模稍大的五子棋或者N子棋中的蒙特卡洛树搜索（MCTS）算法。</p>
<ul>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-1-minimax.md">第一篇:
Leetcode中的Minimax 和 Alpha Beta剪枝</a></p></li>
<li><p><strong><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-2-tictactoe.md">第二篇:
井字棋Leetcode系列题解和Minimax最佳策略实现</a></strong></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-3-openai-gym-pygame.md">第三篇:
井字棋、五子棋的OpenAI Gym GUI环境</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-4-alphago-zero-theory/index.md">第四篇:
AlphaGo Zero 强化学习算法原理深度分析</a></p></li>
<li><p><a href="/zh/2020/combinatorial-game-2-tictactoe/zh/combinatorial-game-5-alphago-zero-connect-n/index.md">第五篇:
井字棋、五子棋AlphaGo Zero 算法实战</a></p></li>
</ul>
<h2 id="leetcode-上的井字棋系列">Leetcode 上的井字棋系列</h2>
<h3 id="leetcode-1275.-找出井字棋的获胜者-简单"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/">Leetcode
1275. 找出井字棋的获胜者 (简单)</a></h3>
<blockquote>
<p>A 和&nbsp;B&nbsp;在一个&nbsp;3&nbsp;x&nbsp;3&nbsp;的网格上玩井字棋。<br>
井字棋游戏的规则如下：<br> 玩家轮流将棋子放在空方格 (" ") 上。<br>
第一个玩家 A 总是用&nbsp;"X" 作为棋子，而第二个玩家 B 总是用 "O"
作为棋子。<br> "X" 和 "O"
只能放在空方格中，而不能放在已经被占用的方格上。<br> 只要有 3
个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。<br>
如果所有方块都放满棋子（不为空），游戏也会结束。<br>
游戏结束后，棋子无法再进行任何移动。<br> 给你一个数组
moves，其中每个元素是大小为 2
的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A
后 B）记录了两人各自的棋子位置。<br> 如果游戏存在获胜者（A 或
B），就返回该游戏的获胜者；如果游戏以平局结束，则返回
"Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。<br>
你可以假设&nbsp;moves&nbsp;都 有效（遵循井字棋规则），网格最初是空的，A
将先行动。</p>
</blockquote>
<blockquote>
<p>示例 1：<br> 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]<br>
输出："A"<br> 解释："A" 获胜，他总是先走。<br> "X " "X " "X " "X " "X
"<br> " " -&gt; " " -&gt; " X " -&gt; " X " -&gt; " X "<br> " " "O "
"O " "OO " "OOX"<br></p>
</blockquote>
<blockquote>
<p>示例 2： 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]<br>
输出："B"<br> 解释："B" 获胜。<br> "X " "X " "XX " "XXO" "XXO"
"XXO"<br> " " -&gt; " O " -&gt; " O " -&gt; " O " -&gt; "XO " -&gt; "XO
" <br> " " " " " " " " " " "O "<br></p>
</blockquote>
<p>第一种解法，检查A或者B赢的所有可能情况：某玩家占据8种连线的任意一种情况则胜利，我们使用八个变量来保存所有情况。下面的代码使用了一个小技巧，将moves转换成3x3的棋盘状态数组，元素的值为1，-1和0。1，-1代表两个玩家，0代表空的棋盘格子，其优势在于后续我们只需累加棋盘的值到八个变量中关联的若干个，再检查这八个变量是否满足取胜条件。例如，row[0]表示第一行的状态，当遍历一次所有棋盘格局后，row[0]为第一行的3个格子的总和，只有当row[0]
== 3 才表明玩家A占据了第一行，-3表明玩家B占据了第一行。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tictactoe</span>(<span class="hljs-params">self, moves: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">str</span>:</span></span><br><span class="line">        board = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]</span><br><span class="line">        <span class="hljs-keyword">for</span> idx, xy <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moves):</span><br><span class="line">            player = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span></span><br><span class="line">            board[xy[<span class="hljs-number">0</span>]][xy[<span class="hljs-number">1</span>]] = player</span><br><span class="line"></span><br><span class="line">        turn = <span class="hljs-number">0</span></span><br><span class="line">        row, col = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line">        diag1, diag2 = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">                turn += board[r][c]</span><br><span class="line">                row[r] += board[r][c]</span><br><span class="line">                col[c] += board[r][c]</span><br><span class="line">                <span class="hljs-keyword">if</span> r == c:</span><br><span class="line">                    diag1 += board[r][c]</span><br><span class="line">                <span class="hljs-keyword">if</span> r + c == <span class="hljs-number">2</span>:</span><br><span class="line">                    diag2 += board[r][c]</span><br><span class="line"></span><br><span class="line">        oWin = <span class="hljs-built_in">any</span>(row[r] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == <span class="hljs-number">3</span></span><br><span class="line">        xWin = <span class="hljs-built_in">any</span>(row[r] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == -<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == -<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span> <span class="hljs-keyword">if</span> oWin <span class="hljs-keyword">else</span> <span class="hljs-string">"B"</span> <span class="hljs-keyword">if</span> xWin <span class="hljs-keyword">else</span> <span class="hljs-string">"Draw"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) == <span class="hljs-number">9</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Pending"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>下面我们给出另一种解法，这种解法虽然代码较多，但可以不必遍历棋盘每个格子，比上一种严格遍历一次棋盘的解法略为高效。原理如下，题目保证了moves过程中不会产生输赢结果，因此我们直接检查最后一个棋子向外的八个方向，若任意方向有三连子，则此玩家获胜。这种解法主要是为后续井字棋扩展到五子棋时判断每个落子是否产生输赢做代码准备。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkWin</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        north = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line">        south = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">        east = self.getConnectedNum(r, c, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        west = self.getConnectedNum(r, c, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        south_east = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        north_west = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        north_east = self.getConnectedNum(r, c, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        south_west = self.getConnectedNum(r, c, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (north + south + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (east + west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> \</span><br><span class="line">                (south_east + north_west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (north_east + south_west + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getConnectedNum</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span>, dr: <span class="hljs-built_in">int</span>, dc: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        player = self.board[r][c]</span><br><span class="line">        result = <span class="hljs-number">0</span></span><br><span class="line">        i = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            new_r = r + dr * i</span><br><span class="line">            new_c = c + dc * i</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= new_r &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= new_c &lt; <span class="hljs-number">3</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> self.board[new_r][new_c] == player:</span><br><span class="line">                    result += <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tictactoe</span>(<span class="hljs-params">self, moves: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">str</span>:</span></span><br><span class="line">        self.board = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]</span><br><span class="line">        <span class="hljs-keyword">for</span> idx, xy <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moves):</span><br><span class="line">            player = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span></span><br><span class="line">            self.board[xy[<span class="hljs-number">0</span>]][xy[<span class="hljs-number">1</span>]] = player</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># only check last move</span></span><br><span class="line">        r, c = moves[-<span class="hljs-number">1</span>]</span><br><span class="line">        win = self.checkWin(r, c)</span><br><span class="line">        <span class="hljs-keyword">if</span> win:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"B"</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Draw"</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) == <span class="hljs-number">9</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Pending"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="leetcode-794.-有效的井字游戏-中等"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/">Leetcode
794. 有效的井字游戏 (中等)</a></h3>
<blockquote>
<p>用字符串数组作为井字游戏的游戏板
board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回
true。<br> 该游戏板是一个 3 x 3 数组，由字符 " "，"X" 和 "O" 组成。字符
" " 代表一个空位。<br> 以下是井字游戏的规则：<br>
玩家轮流将字符放入空位（" "）中。<br> 第一个玩家总是放字符
“X”，且第二个玩家总是放字符 “O”。<br> “X” 和 “O”
只允许放置在空位中，不允许对已放有字符的位置进行填充。<br> 当有 3
个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。<br>
当所有位置非空时，也算为游戏结束。<br>
如果游戏结束，玩家不允许再放置字符。<br></p>
</blockquote>
<blockquote>
<p>示例 1:<br> 输入: board = ["O ", " ", " "]<br> 输出: false<br>
解释: 第一个玩家总是放置“X”。<br></p>
</blockquote>
<blockquote>
<p>示例 2:<br> 输入: board = ["XOX", " X ", " "]<br> 输出: false<br>
解释: 玩家应该是轮流放置的。<br></p>
</blockquote>
<blockquote>
<p>示例 3:<br> 输入: board = ["XXX", " ", "OOO"]<br> 输出:
false<br></p>
</blockquote>
<blockquote>
<p>示例 4:<br> 输入: board = ["XOX", "O O", "XOX"]<br> 输出: true<br>
说明:<br></p>
</blockquote>
<blockquote>
<p>游戏板 board 是长度为 3 的字符串数组，其中每个字符串 board[i]
的长度为 3。 board[i][j] 是集合 {" ", "X", "O"} 中的一个字符。</p>
</blockquote>
<p>这道题第一反应是需要DFS来判断给定状态是否可达，但其实可以用上面1275的思路，即通过检验最终棋盘的一些特点来判断给定状态是否合法。比如，X和O的数量只有可能相同，或X比O多一个。其关键在于需要找到判断状态合法的充要条件，就可以在<span class="math inline">\(O(1)\)</span> 时间复杂度完成判断。
此外，这道题给了我们井字棋所有可能状态数量的启示。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convertCell</span>(<span class="hljs-params">self, c:<span class="hljs-built_in">str</span></span>):</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">'X'</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">'O'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validTicTacToe</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span></span><br><span class="line">        turn = <span class="hljs-number">0</span></span><br><span class="line">        row, col = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line">        diag1, diag2 = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="line">                turn += self.convertCell(board[r][c])</span><br><span class="line">                row[r] += self.convertCell(board[r][c])</span><br><span class="line">                col[c] += self.convertCell(board[r][c])</span><br><span class="line">                <span class="hljs-keyword">if</span> r == c:</span><br><span class="line">                    diag1 += self.convertCell(board[r][c])</span><br><span class="line">                <span class="hljs-keyword">if</span> r + c == <span class="hljs-number">2</span>:</span><br><span class="line">                    diag2 += self.convertCell(board[r][c])</span><br><span class="line"></span><br><span class="line">        xWin = <span class="hljs-built_in">any</span>(row[r] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == <span class="hljs-number">3</span></span><br><span class="line">        oWin = <span class="hljs-built_in">any</span>(row[r] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(col[c] == -<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-keyword">or</span> diag1 == -<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> diag2 == -<span class="hljs-number">3</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (xWin <span class="hljs-keyword">and</span> turn == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (oWin <span class="hljs-keyword">and</span> turn == <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (turn == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> turn == <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> xWin <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> oWin)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="leetcode-348.-判定井字棋胜负-中等加锁"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-tic-tac-toe/">Leetcode 348.
判定井字棋胜负 (中等，加锁)</a></h3>
<blockquote>
<p>请在 n × n
的棋盘上，实现一个判定井字棋（Tic-Tac-Toe）胜负的神器，判断每一次玩家落子后，是否有胜出的玩家。<br>
在这个井字棋游戏中，会有 2
名玩家，他们将轮流在棋盘上放置自己的棋子。<br>
在实现这个判定器的过程中，你可以假设以下这些规则一定成立：<br>
每一步棋都是在棋盘内的，并且只能被放置在一个空的格子里；<br>
一旦游戏中有一名玩家胜出的话，游戏将不能再继续；<br>
一个玩家如果在同一行、同一列或者同一斜对角线上都放置了自己的棋子，那么他便获得胜利。</p>
</blockquote>
<blockquote>
<p>示例： 给定棋盘边长 n = 3, 玩家 1 的棋子符号是 "X"，玩家 2
的棋子符号是 "O"。<br> TicTacToe toe = new TicTacToe(3);<br>
toe.move(0, 0, 1); -&gt; 函数返回 0
(此时，暂时没有玩家赢得这场对决)<br> |X| | |<br> | | | | // 玩家 1 在
(0, 0) 落子。<br> | | | |<br> <br> toe.move(0, 2, 2); -&gt; 函数返回
0 (暂时没有玩家赢得本场比赛)<br> |X| |O|<br> | | | | // 玩家 2 在 (0,
2) 落子。<br> | | | |<br> <br> toe.move(2, 2, 1); -&gt; 函数返回 0
(暂时没有玩家赢得比赛)<br> |X| |O|<br> | | | | // 玩家 1 在 (2, 2)
落子。<br> | | |X|<br> <br> toe.move(1, 1, 2); -&gt; 函数返回 0
(暂没有玩家赢得比赛)<br> |X| |O|<br> | |O| | // 玩家 2 在 (1, 1)
落子。<br> | | |X|<br> <br> toe.move(2, 0, 1); -&gt; 函数返回 0
(暂无玩家赢得比赛)<br> |X| |O|<br> | |O| | // 玩家 1 在 (2, 0)
落子。<br> |X| |X|<br> <br> toe.move(1, 0, 2); -&gt; 函数返回 0
(没有玩家赢得比赛)<br> |X| |O|<br> |O|O| | // 玩家 2 在 (1, 0)
落子.<br> |X| |X|<br> <br> toe.move(2, 1, 1); -&gt; 函数返回 1
(此时，玩家 1 赢得了该场比赛)<br> |X| |O|<br> |O|O| | // 玩家 1 在 (2,
1) 落子。<br> |X|X|X|<br></p>
</blockquote>
<p>348 是道加锁题，对于每次玩家的move，可以用1275第二种解法中的checkWin
函数。下面代码给出了另一种基于1275解法一的方法：保存八个关键变量，每次落子后更新这个子所关联的某几个变量。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># AC</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicTacToe</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n:<span class="hljs-built_in">int</span></span>):</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Initialize your data structure here.</span></span><br><span class="line"><span class="hljs-string">        :type n: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        self.row, self.col, self.diag1, self.diag2, self.n = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self, row:<span class="hljs-built_in">int</span>, col:<span class="hljs-built_in">int</span>, player:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        Player {player} makes a move at ({row}, {col}).</span></span><br><span class="line"><span class="hljs-string">        @param row The row of the board.</span></span><br><span class="line"><span class="hljs-string">        @param col The column of the board.</span></span><br><span class="line"><span class="hljs-string">        @param player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="hljs-string">        @return The current winning condition, can be either:</span></span><br><span class="line"><span class="hljs-string">                0: No one wins.</span></span><br><span class="line"><span class="hljs-string">                1: Player 1 wins.</span></span><br><span class="line"><span class="hljs-string">                2: Player 2 wins.</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> player == <span class="hljs-number">2</span>:</span><br><span class="line">            player = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="hljs-keyword">if</span> row == col:</span><br><span class="line">            self.diag1 += player</span><br><span class="line">        <span class="hljs-keyword">if</span> row + col == self.n - <span class="hljs-number">1</span>:</span><br><span class="line">            self.diag2 += player</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> self.n <span class="hljs-keyword">in</span> [self.row[row], self.col[col], self.diag1, self.diag2]:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> -self.n <span class="hljs-keyword">in</span> [self.row[row], self.col[col], self.diag1, self.diag2]:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="井字棋最佳策略">井字棋最佳策略</h2>
<p>井字棋的规模可以很自然的扩展成四子棋或五子棋等，区别在于棋盘大小和胜利时的连子数量。这类游戏最一般的形式为
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M,n,k-game">M,n,k-game</a>，中文可能翻译为战略井字游戏，表示棋盘大小为M
x N，当k连子时获胜。
下面的ConnectNGame类实现了战略井字游戏（M=N）中，两个玩家轮流下子、更新棋盘状态和判断每次落子输赢等逻辑封装。其中undo方法用于撤销最后一个落子，方便在后续寻找最佳策略时回溯。</p>
<h3 id="connectngame">ConnectNGame</h3>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectNGame</span>:</span></span><br><span class="line"></span><br><span class="line">    PLAYER_A = <span class="hljs-number">1</span></span><br><span class="line">    PLAYER_B = -<span class="hljs-number">1</span></span><br><span class="line">    AVAILABLE = <span class="hljs-number">0</span></span><br><span class="line">    RESULT_TIE = <span class="hljs-number">0</span></span><br><span class="line">    RESULT_A_WIN = <span class="hljs-number">1</span></span><br><span class="line">    RESULT_B_WIN = -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N:<span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, board_size:<span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> N &lt;= board_size</span><br><span class="line">        self.N = N</span><br><span class="line">        self.board_size = board_size</span><br><span class="line">        self.board = [[ConnectNGame.AVAILABLE] * board_size <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(board_size)]</span><br><span class="line">        self.gameOver = <span class="hljs-literal">False</span></span><br><span class="line">        self.gameResult = <span class="hljs-literal">None</span></span><br><span class="line">        self.currentPlayer = ConnectNGame.PLAYER_A</span><br><span class="line">        self.remainingPosNum = board_size * board_size</span><br><span class="line">        self.actionStack = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self, r: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        :param r:</span></span><br><span class="line"><span class="hljs-string">        :param c:</span></span><br><span class="line"><span class="hljs-string">        :return: None: game ongoing</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> self.board[r][c] == ConnectNGame.AVAILABLE</span><br><span class="line">        self.board[r][c] = self.currentPlayer</span><br><span class="line">        self.actionStack.append((r, c))</span><br><span class="line">        self.remainingPosNum -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.checkWin(r, c):</span><br><span class="line">            self.gameOver = <span class="hljs-literal">True</span></span><br><span class="line">            self.gameResult = self.currentPlayer</span><br><span class="line">            <span class="hljs-keyword">return</span> self.currentPlayer</span><br><span class="line">        <span class="hljs-keyword">if</span> self.remainingPosNum == <span class="hljs-number">0</span>:</span><br><span class="line">            self.gameOver = <span class="hljs-literal">True</span></span><br><span class="line">            self.gameResult = ConnectNGame.RESULT_TIE</span><br><span class="line">            <span class="hljs-keyword">return</span> ConnectNGame.RESULT_TIE</span><br><span class="line">        self.currentPlayer *= -<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">undo</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.actionStack) &gt; <span class="hljs-number">0</span>:</span><br><span class="line">            lastAction = self.actionStack.pop()</span><br><span class="line">            r, c = lastAction</span><br><span class="line">            self.board[r][c] = ConnectNGame.AVAILABLE</span><br><span class="line">            self.currentPlayer = ConnectNGame.PLAYER_A <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.actionStack) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> ConnectNGame.PLAYER_B</span><br><span class="line">            self.remainingPosNum += <span class="hljs-number">1</span></span><br><span class="line">            self.gameOver = <span class="hljs-literal">False</span></span><br><span class="line">            self.gameResult = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'No lastAction'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getAvailablePositions</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> [(i,j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size) <span class="hljs-keyword">if</span> self.board[i][j] == ConnectNGame.AVAILABLE]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getStatus</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>([<span class="hljs-built_in">tuple</span>(self.board[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.board_size)])</span><br></pre></td></tr></tbody></table></figure>
<p>其中checkWin和1275解法二中的逻辑一致。</p>
<h3 id="minimax-算法">Minimax 算法</h3>
<p>此战略井字游戏的逻辑代码，结合之前的minimax算法，可以实现游戏最佳策略。</p>
<p>先定义一个通用的策略基类和抽象方法
action。action表示给定一个棋盘状态，返回一个动作决定。返回Tuple的第一个int值表示估计走这一步的结局，第二个值类型是Tuple[int,
int]，表示这次落子的位置，例如（1，1）。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>(<span class="hljs-params">ABC</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span></span><br><span class="line">        <span class="hljs-built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @abstractmethod</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
MinimaxStrategy
的逻辑和之前的minimax模版算法大致相同，多了保存最佳move对应的动作，用于最后返回。
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinimaxStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = copy.deepcopy(game)</span><br><span class="line">        result, move = self.minimax()</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax()</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax()</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br></pre></td></tr></tbody></table></figure>
通过上面的代码可以画出初始两步的井字棋最终结局。对于先手O来说可以落9个位置，排除对称位置后只有三种，分别为角落，边上和正中。但无论哪一个位置作为先手，最好的结局都是被对方逼平，不存在必赢的开局。所以井字棋的结局是：如果两个玩家都采用最优策略（无失误），游戏结果为双方逼平。
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_1.gv.svg">
<figcaption>
井字棋第一步结局
</figcaption>
</figure>
下面分别画出三种开局后进一步的游戏结局。
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_1.gv.svg">
<figcaption>
井字棋角落开局
</figcaption>
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_2.gv.svg">
<figcaption>
井字棋边上开局
</figcaption>
</figure>
<figure>
<img src="/zh/2020/combinatorial-game-2-tictactoe/tictactoe_2_3.gv.svg">
<figcaption>
井字棋中间开局
</figcaption>
</figure>
<h3 id="井字棋游戏状态数和解">井字棋游戏状态数和解</h3>
<p>有趣的是井字棋游戏的状态数量，简单的上限估算是<span class="math inline">\(3^9=19683\)</span>。这显然是个较宽泛的上限，因为很多状态在游戏结束后无法达到。
这篇文章 <a target="_blank" rel="noopener" href="http://www.mathrec.org/old/2002jan/solutions.html">Tic-Tac-Toe
(Naughts and Crosses, Cheese and Crackers, etc</a>
中列出了每一步的状态数，合计5478个。</p>
<table>
<thead>
<tr class="header">
<th>Moves</th>
<th>Positions</th>
<th>Terminal Positions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>9</td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td>72</td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td>252</td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>756</td>
<td></td>
</tr>
<tr class="even">
<td>5</td>
<td>1260</td>
<td>120</td>
</tr>
<tr class="odd">
<td>6</td>
<td>1520</td>
<td>148</td>
</tr>
<tr class="even">
<td>7</td>
<td>1140</td>
<td>444</td>
</tr>
<tr class="odd">
<td>8</td>
<td>390</td>
<td>168</td>
</tr>
<tr class="even">
<td>9</td>
<td>78</td>
<td>78</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>5478</td>
<td>958</td>
</tr>
</tbody>
</table>
<p>我们已经实现了井字棋的minimax策略，算法本质上遍历了所有情况，稍加改造后增加dp数组，就可以确认上面的总状态数。</p>
<figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingMinimaxStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = copy.deepcopy(game)</span><br><span class="line">        self.dpMap = {}</span><br><span class="line">        result, move = self.minimax(game.getStatus())</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimax</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        <span class="hljs-comment"># print(f'Current {len(strategy.dpMap)}')</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> gameStatus <span class="hljs-keyword">in</span> self.dpMap:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.dpMap[gameStatus]</span><br><span class="line"></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax(game.getStatus())</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, oppMove</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, move</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">            self.dpMap[gameStatus] = ret, bestMove</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.minimax(game.getStatus())</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, oppMove</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    self.dpMap[game.getStatus()] = result, move</span><br><span class="line">                game.undo()</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">            self.dpMap[gameStatus] = ret, bestMove</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    tic_tac_toe = ConnectNGame(N=<span class="hljs-number">3</span>, board_size=<span class="hljs-number">3</span>)</span><br><span class="line">    strategy = CountingMinimaxStrategy()</span><br><span class="line">    strategy.action(tic_tac_toe)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Game States Number <span class="hljs-subst">{<span class="hljs-built_in">len</span>(strategy.dpMap)}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>运行程序证实了井字棋状态数为5478，下面是一些极小规模时代码运行结果：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>3x3</th>
<th>4x4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k=3</td>
<td>5478 （Draw)</td>
<td>6035992 （Win）</td>
</tr>
<tr class="even">
<td>k=4</td>
<td></td>
<td>9722011 （Draw）</td>
</tr>
<tr class="odd">
<td>k=5</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M,n,k-game">Wikipedia
M,n,k-game</a>, 列出了一些小规模下的游戏解：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>3x3</th>
<th>4x4</th>
<th>5x5</th>
<th>6x6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k=3</td>
<td>Draw</td>
<td>Win</td>
<td>Win</td>
<td>Win</td>
</tr>
<tr class="even">
<td>k=4</td>
<td></td>
<td>Draw</td>
<td>Draw</td>
<td>Win</td>
</tr>
<tr class="odd">
<td>k=5</td>
<td></td>
<td></td>
<td>Draw</td>
<td>Draw</td>
</tr>
</tbody>
</table>
<p>值得一提的是，五子棋（棋盘15x15或以上）被 L. Victor
Allis证明是先手赢。</p>
<h3 id="alpha-beta剪枝策略">Alpha-Beta剪枝策略</h3>
<p>Alpha Beta 剪枝策略的代码如下（和之前代码比较类似，不再赘述）：
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlphaBetaStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = game</span><br><span class="line">        result, move = self.alpha_beta(self.game.getStatus(), -math.inf, math.inf)</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]], alpha:<span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span>, beta:<span class="hljs-built_in">int</span>=<span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.alpha_beta(game.getStatus(), alpha, beta)</span><br><span class="line">                game.undo()</span><br><span class="line">                alpha = <span class="hljs-built_in">max</span>(alpha, result)</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    result, oppMove = self.alpha_beta(game.getStatus(), alpha, beta)</span><br><span class="line">                game.undo()</span><br><span class="line">                beta = <span class="hljs-built_in">min</span>(beta, result)</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Alpha Beta
的DP版本中，由于lru_cache无法指定cache的有效参数，递归函数并没有传入alpha,
beta。因此我们将alpha，beta参数隐式放入自己维护的栈中，并保证栈的状态和alpha_beta_dp函数调用状态一致。
</p><figure class="highlight python hljs"><figcaption><span>{linenos</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlphaBetaDPStrategy</span>(<span class="hljs-params">Strategy</span>):</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self, game: ConnectNGame</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        self.game = game</span><br><span class="line">        self.alphaBetaStack = [(-math.inf, math.inf)]</span><br><span class="line">        result, move = self.alpha_beta_dp(self.game.getStatus())</span><br><span class="line">        <span class="hljs-keyword">return</span> result, move</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alpha_beta_dp</span>(<span class="hljs-params">self, gameStatus: <span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, ...]]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:</span></span><br><span class="line">        alpha, beta = self.alphaBetaStack[-<span class="hljs-number">1</span>]</span><br><span class="line">        game = self.game</span><br><span class="line">        bestMove = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">        <span class="hljs-keyword">if</span> game.currentPlayer == ConnectNGame.PLAYER_A:</span><br><span class="line">            ret = -math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    self.alphaBetaStack.append((alpha, beta))</span><br><span class="line">                    result, oppMove = self.alpha_beta_dp(game.getStatus())</span><br><span class="line">                    self.alphaBetaStack.pop()</span><br><span class="line">                game.undo()</span><br><span class="line">                alpha = <span class="hljs-built_in">max</span>(alpha, result)</span><br><span class="line">                ret = <span class="hljs-built_in">max</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == <span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = math.inf</span><br><span class="line">            <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> game.getAvailablePositions():</span><br><span class="line">                move = pos</span><br><span class="line">                result = game.move(*pos)</span><br><span class="line">                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> game.gameOver</span><br><span class="line">                    self.alphaBetaStack.append((alpha, beta))</span><br><span class="line">                    result, oppMove = self.alpha_beta_dp(game.getStatus())</span><br><span class="line">                    self.alphaBetaStack.pop()</span><br><span class="line">                game.undo()</span><br><span class="line">                beta = <span class="hljs-built_in">min</span>(beta, result)</span><br><span class="line">                ret = <span class="hljs-built_in">min</span>(ret, result)</span><br><span class="line">                bestMove = move <span class="hljs-keyword">if</span> ret == result <span class="hljs-keyword">else</span> bestMove</span><br><span class="line">                <span class="hljs-keyword">if</span> alpha &gt;= beta <span class="hljs-keyword">or</span> ret == -<span class="hljs-number">1</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> ret, move</span><br><span class="line">            <span class="hljs-keyword">return</span> ret, bestMove</span><br></pre></td></tr></tbody></table></figure><p></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></body></html>
    
    </div>
    
    
</article>








    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/tags/Reinforcement-Learning/">上一页</a>
    </div>
    <div class="pagination-next is-invisible is-hidden-mobile">
        <a href="/tags/Reinforcement-Learning/page/3/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/tags/Reinforcement-Learning/">1</a></li>
        
        <li><a class="pagination-link is-current" href="/tags/Reinforcement-Learning/page/2/">2</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2023 MyEncyclopedia&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true" aria-controls="dropdown-menu7">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>简体中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu">
            <div class="dropdown-content">
            
                <a href="/tags/Reinforcement-Learning/page/2/" class="dropdown-item">
                    简体中文
                </a>
            
                <a href="/en/tags/Reinforcement-Learning/page/2/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<style>
 .katex-display {
    overflow-x: auto;
    overflow-y: hidden;
    height: 100%;
  }
</style>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        // ...options...
    });
});
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>